{"meta":{"title":"没有秃头基因的燊的博客","subtitle":"还在学习","description":"折腾、学习shader中","author":"没有秃头基因的燊","url":"https://yzs020220.github.io","root":"/"},"pages":[{"title":"没有秃头基因的燊","date":"2023-01-25T13:57:47.000Z","updated":"2023-03-16T05:58:29.324Z","comments":true,"path":"about/index.html","permalink":"https://yzs020220.github.io/about/index.html","excerpt":"","text":"这个人很懒，什么都没有留下。"},{"title":"tags","date":"2022-12-28T11:57:13.000Z","updated":"2022-12-28T12:08:49.928Z","comments":true,"path":"tags/index.html","permalink":"https://yzs020220.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-02-18T12:54:25.000Z","updated":"2023-02-18T13:01:59.045Z","comments":true,"path":"categories/index.html","permalink":"https://yzs020220.github.io/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2022-12-30T02:41:55.000Z","updated":"2022-12-30T02:43:19.314Z","comments":true,"path":"search/index.html","permalink":"https://yzs020220.github.io/search/index.html","excerpt":"","text":""},{"title":"friends","date":"2022-12-28T11:59:11.000Z","updated":"2023-02-19T02:50:36.151Z","comments":true,"path":"friends/index.html","permalink":"https://yzs020220.github.io/friends/index.html","excerpt":"","text":""},{"title":"","date":"2023-09-09T10:59:34.960Z","updated":"2023-02-19T02:19:57.648Z","comments":true,"path":"css/APlayer.min.css","permalink":"https://yzs020220.github.io/css/APlayer.min.css","excerpt":"","text":".aplayer { background: #fff; font-family: Arial, Helvetica, sans-serif; margin: 5px; box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .07), 0 1px 5px 0 rgba(0, 0, 0, .1); border-radius: 2px; overflow: hidden; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; line-height: normal; position: relative } .aplayer * { box-sizing: content-box } .aplayer svg { width: 100%; height: 100% } .aplayer svg circle, .aplayer svg path { fill: #fff } .aplayer.aplayer-withlist .aplayer-info { border-bottom: 1px solid #e9e9e9 } .aplayer.aplayer-withlist .aplayer-list { display: block } .aplayer.aplayer-withlist .aplayer-icon-order, .aplayer.aplayer-withlist .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-menu { display: inline } .aplayer.aplayer-withlrc .aplayer-pic { height: 90px; width: 90px } .aplayer.aplayer-withlrc .aplayer-info { margin-left: 90px; height: 90px; padding: 10px 7px 0 } .aplayer.aplayer-withlrc .aplayer-lrc { display: block } .aplayer.aplayer-narrow { width: 66px } .aplayer.aplayer-narrow .aplayer-info, .aplayer.aplayer-narrow .aplayer-list { display: none } .aplayer.aplayer-narrow .aplayer-body, .aplayer.aplayer-narrow .aplayer-pic { height: 66px; width: 66px } .aplayer.aplayer-fixed { position: fixed; bottom: 300px; left: 0; right: 0; margin: 0; z-index: 99; overflow: visible; max-width: 400px; box-shadow: none } .aplayer.aplayer-fixed .aplayer-list { margin-bottom: 65px; border: 1px solid #eee; border-bottom: none } .aplayer.aplayer-fixed .aplayer-body { position: fixed; bottom: 300px; left: 0; right: 0; margin: 0; z-index: 99; background: #fff; padding-right: 18px; transition: all .3s ease; max-width: 400px } .aplayer.aplayer-fixed .aplayer-lrc { display: block; position: fixed; bottom: 310px; left: 0; right: 0; margin: 0; z-index: 98; pointer-events: none; text-shadow: -1px -1px 0 #fff } .aplayer.aplayer-fixed .aplayer-lrc:after, .aplayer.aplayer-fixed .aplayer-lrc:before { display: none } .aplayer.aplayer-fixed .aplayer-info { -webkit-transform: scaleX(1); transform: scaleX(1); -webkit-transform-origin: 0 0; transform-origin: 0 0; transition: all .3s ease; bottom: 300px; border-bottom: none; border-top: 1px solid #e9e9e9 } .aplayer.aplayer-fixed .aplayer-info .aplayer-music { width: calc(100% - 105px) } .aplayer.aplayer-fixed .aplayer-miniswitcher { display: block } .aplayer.aplayer-fixed.aplayer-narrow .aplayer-info { display: block; -webkit-transform: scaleX(0); transform: scaleX(0) } .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body { width: 66px !important } .aplayer.aplayer-fixed.aplayer-narrow .aplayer-miniswitcher .aplayer-icon { -webkit-transform: rotateY(0); transform: rotateY(0) } .aplayer.aplayer-fixed .aplayer-icon-back, .aplayer.aplayer-fixed .aplayer-icon-forward, .aplayer.aplayer-fixed .aplayer-icon-lrc, .aplayer.aplayer-fixed .aplayer-icon-play { display: inline-block } .aplayer.aplayer-fixed .aplayer-icon-back, .aplayer.aplayer-fixed .aplayer-icon-forward, .aplayer.aplayer-fixed .aplayer-icon-menu, .aplayer.aplayer-fixed .aplayer-icon-play { position: absolute; bottom: 27px; width: 20px; height: 20px } .aplayer.aplayer-fixed .aplayer-icon-back { right: 75px } .aplayer.aplayer-fixed .aplayer-icon-play { right: 50px } .aplayer.aplayer-fixed .aplayer-icon-forward { right: 25px } .aplayer.aplayer-fixed .aplayer-icon-menu { right: 0 } .aplayer.aplayer-arrow .aplayer-icon-loop, .aplayer.aplayer-arrow .aplayer-icon-order, .aplayer.aplayer-mobile .aplayer-icon-volume-down { display: none } .aplayer.aplayer-loading .aplayer-info .aplayer-controller .aplayer-loading-icon { display: block } .aplayer.aplayer-loading .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played .aplayer-thumb { -webkit-transform: scale(1); transform: scale(1) } .aplayer .aplayer-body { position: relative } .aplayer .aplayer-icon { width: 15px; height: 15px; border: none; background-color: transparent; outline: none; cursor: pointer; opacity: .8; vertical-align: middle; padding: 0; font-size: 12px; margin: 0; display: inline-block } .aplayer .aplayer-icon path { transition: all .2s ease-in-out } .aplayer .aplayer-icon-back, .aplayer .aplayer-icon-forward, .aplayer .aplayer-icon-lrc, .aplayer .aplayer-icon-order, .aplayer .aplayer-icon-play { display: none } .aplayer .aplayer-icon-lrc-inactivity svg { opacity: .4 } .aplayer .aplayer-icon-forward { -webkit-transform: rotate(180deg); transform: rotate(180deg) } .aplayer .aplayer-lrc-content { display: none } .aplayer .aplayer-pic { position: relative; float: left; height: 66px; width: 66px; background-size: cover; background-position: 50%; transition: all .3s ease; cursor: pointer } .aplayer .aplayer-pic:hover .aplayer-button { opacity: 1 } .aplayer .aplayer-pic .aplayer-button { position: absolute; border-radius: 50%; opacity: .8; text-shadow: 0 1px 1px rgba(0, 0, 0, .2); box-shadow: 0 1px 1px rgba(0, 0, 0, .2); background: rgba(0, 0, 0, .2); transition: all .1s ease } .aplayer .aplayer-pic .aplayer-button path { fill: #fff } .aplayer .aplayer-pic .aplayer-hide { display: none } .aplayer .aplayer-pic .aplayer-play { width: 26px; height: 26px; border: 2px solid #fff; bottom: 50%; right: 50%; margin: 0 -15px -15px 0 } .aplayer .aplayer-pic .aplayer-play svg { position: absolute; top: 3px; left: 4px; height: 20px; width: 20px } .aplayer .aplayer-pic .aplayer-pause { width: 16px; height: 16px; border: 2px solid #fff; bottom: 4px; right: 4px } .aplayer .aplayer-pic .aplayer-pause svg { position: absolute; top: 2px; left: 2px; height: 12px; width: 12px } .aplayer .aplayer-info { margin-left: 66px; padding: 14px 7px 0 10px; height: 66px; box-sizing: border-box } .aplayer .aplayer-info .aplayer-music { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; margin: 0 0 13px 5px; -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text; user-select: text; cursor: default; padding-bottom: 2px; height: 20px } .aplayer .aplayer-info .aplayer-music .aplayer-title { font-size: 14px } .aplayer .aplayer-info .aplayer-music .aplayer-author { font-size: 12px; color: #666 } .aplayer .aplayer-info .aplayer-controller { position: relative; display: flex } .aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap { margin: 0 0 0 5px; padding: 4px 0; cursor: pointer !important; flex: 1 } .aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap:hover .aplayer-bar .aplayer-played .aplayer-thumb { -webkit-transform: scale(1); transform: scale(1) } .aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar { position: relative; height: 2px; width: 100%; background: #cdcdcd } .aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-loaded { position: absolute; left: 0; top: 0; bottom: 0; background: #aaa; height: 2px; transition: all .5s ease } .aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played { position: absolute; left: 0; top: 0; bottom: 0; height: 2px } .aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played .aplayer-thumb { position: absolute; top: 0; right: 5px; margin-top: -4px; margin-right: -10px; height: 10px; width: 10px; border-radius: 50%; cursor: pointer; transition: all .3s ease-in-out; -webkit-transform: scale(0); transform: scale(0) } .aplayer .aplayer-info .aplayer-controller .aplayer-time { position: relative; right: 0; bottom: 4px; height: 17px; color: #999; font-size: 11px; padding-left: 7px } .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-time-inner { vertical-align: middle } .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon { cursor: pointer; transition: all .2s ease } .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path { fill: #666 } .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-loop { margin-right: 2px } .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon:hover path { fill: #000 } .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-menu, .aplayer .aplayer-info .aplayer-controller .aplayer-time.aplayer-time-narrow .aplayer-icon-menu, .aplayer .aplayer-info .aplayer-controller .aplayer-time.aplayer-time-narrow .aplayer-icon-mode { display: none } .aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap { position: relative; display: inline-block; margin-left: 3px; cursor: pointer !important } .aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap:hover .aplayer-volume-bar-wrap { height: 40px } .aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap { position: absolute; bottom: 15px; right: -3px; width: 25px; height: 0; z-index: 99; overflow: hidden; transition: all .2s ease-in-out } .aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap.aplayer-volume-bar-wrap-active { height: 40px } .aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap .aplayer-volume-bar { position: absolute; bottom: 0; right: 10px; width: 5px; height: 35px; background: #aaa; border-radius: 2.5px; overflow: hidden } .aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap .aplayer-volume-bar .aplayer-volume { position: absolute; bottom: 0; right: 0; width: 5px; transition: all .1s ease } .aplayer .aplayer-info .aplayer-controller .aplayer-loading-icon { display: none } .aplayer .aplayer-info .aplayer-controller .aplayer-loading-icon svg { position: absolute; -webkit-animation: rotate 1s linear infinite; animation: rotate 1s linear infinite } .aplayer .aplayer-lrc { display: none; position: relative; height: 30px; text-align: center; overflow: hidden; margin: -10px 0 7px } .aplayer .aplayer-lrc:before { top: 0; height: 10%; background: linear-gradient(180deg, #fff 0, hsla(0, 0%, 100%, 0)); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#ffffff\", endColorstr=\"#00ffffff\", GradientType=0) } .aplayer .aplayer-lrc:after, .aplayer .aplayer-lrc:before { position: absolute; z-index: 1; display: block; overflow: hidden; width: 100%; content: \" \" } .aplayer .aplayer-lrc:after { bottom: 0; height: 33%; background: linear-gradient(180deg, hsla(0, 0%, 100%, 0) 0, hsla(0, 0%, 100%, .8)); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#00ffffff\", endColorstr=\"#ccffffff\", GradientType=0) } .aplayer .aplayer-lrc p { font-size: 12px; color: #666; line-height: 16px !important; height: 16px !important; padding: 0 !important; margin: 0 !important; transition: all .5s ease-out; opacity: .4; overflow: hidden } .aplayer .aplayer-lrc p.aplayer-lrc-current { opacity: 1; overflow: visible; height: auto !important; min-height: 16px } .aplayer .aplayer-lrc.aplayer-lrc-hide { display: none } .aplayer .aplayer-lrc .aplayer-lrc-contents { width: 100%; transition: all .5s ease-out; -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text; user-select: text; cursor: default } .aplayer .aplayer-list { overflow: auto; transition: all .5s ease; will-change: height; display: none; overflow: hidden } .aplayer .aplayer-list.aplayer-list-hide { max-height: 0 !important } .aplayer .aplayer-list ol { list-style-type: none; margin: 0; padding: 0; overflow-y: auto } .aplayer .aplayer-list ol::-webkit-scrollbar { width: 5px } .aplayer .aplayer-list ol::-webkit-scrollbar-thumb { border-radius: 3px; background-color: #eee } .aplayer .aplayer-list ol::-webkit-scrollbar-thumb:hover { background-color: #ccc } .aplayer .aplayer-list ol li { position: relative; height: 32px; line-height: 32px; padding: 0 15px; font-size: 12px; border-top: 1px solid #e9e9e9; cursor: pointer; transition: all .2s ease; overflow: hidden; margin: 0 } .aplayer .aplayer-list ol li:first-child { border-top: none } .aplayer .aplayer-list ol li:hover { background: #efefef } .aplayer .aplayer-list ol li.aplayer-list-light { background: #e9e9e9 } .aplayer .aplayer-list ol li.aplayer-list-light .aplayer-list-cur { display: inline-block } .aplayer .aplayer-list ol li .aplayer-list-cur { display: none; width: 3px; height: 22px; position: absolute; left: 0; top: 5px; cursor: pointer } .aplayer .aplayer-list ol li .aplayer-list-index { color: #666; margin-right: 12px; cursor: pointer } .aplayer .aplayer-list ol li .aplayer-list-author { color: #666; float: right; cursor: pointer } .aplayer .aplayer-notice { opacity: 0; position: absolute; top: 50%; left: 50%; -webkit-transform: translate(-50%, -50%); transform: translate(-50%, -50%); font-size: 12px; border-radius: 4px; padding: 5px 10px; transition: all .3s ease-in-out; overflow: hidden; color: #fff; pointer-events: none; background-color: #f4f4f5; color: #909399 } .aplayer .aplayer-miniswitcher { display: none; position: absolute; top: 0; right: 0; height: 100%; background: #e6e6e6; width: 18px; border-radius: 0 2px 2px 0 } .aplayer .aplayer-miniswitcher .aplayer-icon { height: 100%; width: 100%; -webkit-transform: rotateY(180deg); transform: rotateY(180deg); transition: all .3s ease } .aplayer .aplayer-miniswitcher .aplayer-icon path { fill: #666 } .aplayer .aplayer-miniswitcher .aplayer-icon:hover path { fill: #000 } @-webkit-keyframes aplayer-roll { 0% { left: 0 } to { left: -100% } } @keyframes aplayer-roll { 0% { left: 0 } to { left: -100% } } @-webkit-keyframes rotate { 0% { -webkit-transform: rotate(0); transform: rotate(0) } to { -webkit-transform: rotate(1turn); transform: rotate(1turn) } } @keyframes rotate { 0% { -webkit-transform: rotate(0); transform: rotate(0) } to { -webkit-transform: rotate(1turn); transform: rotate(1turn) } } /*# sourceMappingURL=APlayer.min.css.map*/"}],"posts":[{"title":"重拾Android-踩坑之旅","slug":"重拾Android-踩坑之旅","date":"2024-01-02T03:04:22.000Z","updated":"2024-01-02T03:33:33.366Z","comments":true,"path":"posts/40031/","link":"","permalink":"https://yzs020220.github.io/posts/40031/","excerpt":"毕设又要做安卓，就把一些新的旧的坑都写在这好了","text":"毕设又要做安卓，就把一些新的旧的坑都写在这好了 预设项目报错 开幕雷击，新建项目立即报错 报错内容形式如下： Cannot access androidx.lifecycle.ViewModelStoreOwner which is a supertype of com.example.openglestest.MainActivity. Check your module classpath for missing or conflicting dependencies 一般是缺少依赖，例如在我这边缺少了lifecycle，在app下的build.gradle.kts的dependencies中加入 implementation(\"androidx.lifecycle:lifecycle-common:2.6.2\") 镜像源 优化包体下载过慢的问题，在settings.gradle.kts中，找到 google() mavenCentral() 在它们上方添加 maven &#123; url = uri(\"https://maven.aliyun.com/repository/public/\") &#125; maven &#123; url = uri(\"https://maven.aliyun.com/repositories/jcenter\") &#125; maven &#123; url = uri(\"https://maven.aliyun.com/repositories/google\") &#125; maven &#123; url = uri(\"https://maven.aliyun.com/repositories/central\") &#125; 更快速地编译 在第一次联网编译后，Gradle不需要再检查是否更新与重新下载 在View-&gt;Tool windows-&gt;Gradle中，点击打开toggle offline mode 之后除非添加了新的依赖库需要再次联网下载，否则可以离线编译快速查看修改内容","categories":[{"name":"Android","slug":"Android","permalink":"https://yzs020220.github.io/categories/Android/"}],"tags":[{"name":"Android开发","slug":"Android开发","permalink":"https://yzs020220.github.io/tags/Android%E5%BC%80%E5%8F%91/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://yzs020220.github.io/tags/Kotlin/"}]},{"title":"如何从格斗游戏中获得快乐","slug":"如何从格斗游戏中获得快乐","date":"2023-12-18T15:16:49.000Z","updated":"2024-01-02T02:53:26.814Z","comments":true,"path":"posts/38623/","link":"","permalink":"https://yzs020220.github.io/posts/38623/","excerpt":"最近又开始玩《罪恶装备：奋战》了，突然想聊聊格斗游戏","text":"最近又开始玩《罪恶装备：奋战》了，突然想聊聊格斗游戏 前言 我一直觉得格斗游戏可能是游戏类型里最为小众的，尽管其实格斗游戏可能是少有的短时间内就非常兴奋的（基本倒数一结束，便立刻全神贯注开始游玩），但是较高的操作难度也是让人望而却步。 在街机时代，菜就多练能够有效促进玩家去投币；然而现在，无论买断制还是内购制的游戏模式，足够的用户基数永远是收益的最大保障，所以，现在游戏厂商也开始想办法来扩大游戏的受众，而降低游戏门槛，也正是格斗游戏目前扩宽受众的最关键手段。 格斗游戏门槛的降低 个人认为，格斗游戏本质上最大的门槛，来源于两个需要大量练习的东西，连段与搓招。 《任天堂明星大乱斗》也许从分类上不能算格斗游戏，但是从体验上毫无疑问的是一款格斗游戏，除了个别角色之外，其操作基本上都不需要搓招，而连段也不是所有角色都需要的。由于任天堂本家游戏的方针基本上是尽可能包含全年龄的受众，作为目前游玩时长最长的一款格斗游戏，即使是现在，我依然觉得它是上手最快的格斗游戏。 《罪恶装备：奋战》一推出老玩家都直呼难度大减，但是对于格斗游戏的萌新来说，连段与搓招仍然是颇为困难的东西，不过其节奏之快，角色的伤害之高，导致也许你实际游玩也许不太需要纠结连段这回事，砍几下，锤几下，估计一局游戏也结束了。所以大致掌握喜欢的角色的搓招之后，大致就可以进行网络对战了。 《街霸６》是最近不得不提的游戏，《任天堂明星大乱斗》作为主机独占游戏在国内仍然是较为小众的，而《街霸６》推出则是现象级的爆火，首月200Ｗ的销量也许不好说格斗游戏还是小众游戏了。而《街霸６》扩充受众的一个重要手段，就是现代模式，一个提供一键必杀技，一键大招，一键连招的东西，虽然听起来非常的离谱，但是这也是在牺牲了角色更多的必杀技（一般角色搓招出的必杀技会多于现代模式预设的必杀技）以及必杀技的伤害（修正为80％）。即便如此，现代模式还是解决了格斗游戏的最大门槛，这也是我认为《街霸６》能够现象级爆火的一个重要原因。 格斗游戏如何开始 格斗游戏的最大核心乐趣 个人认为，格斗游戏的最大核心乐趣，是短时间内高频次的对策，简单来说就是猜拳，只是这个猜拳不一定是同时出的，而是他直接出了布，我立马出个剪刀，在格斗游戏中作为术语叫择，几乎各个格斗游戏中玩家总是无时无刻地处于择的阶段，不管是打还是被打，而理解了格斗游戏的最大核心乐趣，那么如何获取快乐自然是思考如何感受何谓择。 选择一个角色 关于角色选择，首先先选一个对xp的角色，如果一个角色你不喜欢，即使他强你玩他也许也不是很带劲，毕竟玩格斗游戏玩起来一个角色玩熟了会陪伴你很长的时间。 其次才是从难易度上思考，尽量挑选较为简单的角色上手，从以下方向考虑： 回报较高的方式是单次摸奖（即单次打击就有着不俗的收益） 起手后接连段确认（因为连招角的下限是你熟悉它的连招） 出招上难度较低 搓招难度很高的角色 找到最赖的招式 结合一些视频攻略理解角色最赖的招式，当然还是需要知道角色的所有招式怎么放出来 最赖的招式可以大概分为以下几种，当然有些招式同时具有以下特点： 范围大 收益高 安全（不容易被惩罚） 立回 立回简单来说是攻击到对手前的动作，接下来讲具体怎么做 一开始复读最赖的招式，后面再尝试将各种无赖招式结合起来，只要最终能够命中敌人就是有效的立回 开始对战 你已经掌握了自己的角色怎么玩了，现在需要去实际玩玩了，格斗游戏一开始的定段都会偏高，先输几把掉下来，然后正式开始和别人的游戏。 段位掉下来后你大概率不会遇到那些立回稳健，连段稳定的对手，而是那些复读最赖招式的对手，这个时候去思考如何破解对面的无赖招式，见招拆招，就是格斗游戏的第一步。随着这个过程的推进，你的水平也会慢慢提升。当你的无赖招式被对面见招拆招，你也同时了解了自己的角色。 我为什么不推荐你一上来练连招 首先我个人认为，格斗游戏中是否择对是游戏胜负的关键，连招可以让你的收益从1变成2，而立回，对角色的对策这些东西，可以让你的收益从0变成1，大部分人玩格斗游戏最开始的烦恼就是0到1的过程，而连招不仅吃大量熟练度，甚至网络问题会让你在实战中难以展现训练的成果，无疑是对萌新而言性价比最低的提升方式 我玩过的格斗游戏 聊一下我玩过的两款格斗游戏，以及游玩的经验。我个人不是高手而且也只是乐子人罢了。 任天堂明星大乱斗 掌握回场 一般角色被打到场外是跳+上B回场，因为无法回场就算一命的原因，掌握回场也是角色的下限所在 熟悉空招 大部分角色最赖的招式都在空招，所以了解角色的空招是很重要的 关于角色 角色按两个方向分类： 体型： 轻型：一般为连招角，回场能力强 中型：兼而有之 重型：回场能力弱，但技能力度大 玩法： 拳脚角：攻击距离短，一般收益依赖连招，但一般招式的帧数优秀 剑角：攻击距离长，砍起来很爽，但帧数一般 道具角：立回依赖自己的特殊机制，一般不是你对策别人是别人对策你 对新手推荐的角色，我只说我玩过的： dedede：重型+道具角，搞清楚其机制就不用搞清楚别人的了，力度本身够大，回场也不是特别差，缺点是难打剑角，但是对新手来说还是很好玩 roy：虽然拿剑但本身更像拳脚角，单次攻击15%的伤害非常可观，击杀也不困难，玩起来很爽，立回就是无限空招复读，不过回场较差 光焰：虽然光是连招角，但是大部分打出来是伪连，加上技能真的设计的很强，焰是女盖侬 盖侬：一刀30真的很棒 罪恶装备 · 奋战 对于指令的话用格斗游戏的通用说法 设备 除非你对摇杆或手柄非常熟悉（使用设备打过其他格斗游戏），否则请选择键盘降低你的挫败感 改键 跳改空格 官方教程练习 在mission中，建议通关前3大关，如果连段按不出来不用纠结 学会赖招 一般来说是I和JI 掌握5P和6P 当你被压墙角时，你会想起他们 学会使用投 如果起身时对手冲过来可以尝试起身投，还有些可以混进连招里面打破防，对投的了解会让你对猜拳有全新的理解（就好像石头剪刀多出了个布一样）","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://yzs020220.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://yzs020220.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"记近两周的两次Game Jam","slug":"记近两周的两次Game-Jam","date":"2023-11-06T15:33:37.000Z","updated":"2023-12-12T01:05:21.908Z","comments":true,"path":"posts/11270/","link":"","permalink":"https://yzs020220.github.io/posts/11270/","excerpt":"索性将两次GameJam的记录都放在一块了，目前是nago的有试玩链接","text":"索性将两次GameJam的记录都放在一块了，目前是nago的有试玩链接 吉比特GameJam 这一次开发的主题是“吸收”，做的是《液游症》。 不过这一次也是很明显的没有之前那么顺利了，虽然总体上完成了，但确实有点糙，也会说一下大概的问题。 开头 开题比较晚，六点才出的题目——“吸收”，说实在这次进度上的问题，我个人对团队的影响比较大，因为在公司被拖着没能直接6.下班，八点多才赶到了研讨室（还是七点多不太记得了）。总之就是，过去了很久还没有很成型的点子，纠结了很多。 直到九点四十，didi提出了一个还蛮有意思的点子，就是一个史莱姆分成两块（大的或小的），扔出去一块后，再次将小的块吸收回来，通过这样的玩法可以实现不同的操作，比如小史莱姆具有更好的机动性，打开开关后让大史莱姆跳到正确的位置，就可以将小史莱姆跨过陷阱直接吸回体内过关。 至此，方案敲定，第一天结束，然而还有很多没有完善的地方以及整个流程没有出来，所以也导致了很多后面的问题。 开发 说实话这是我第一次跟其他程序打配合，虽然我师弟其实也是刚刚入门，我让他按着油管的教程来做一个史莱姆，用的是Unity的Joint组件还有一个什么Render Shape(有点不记得了，可能后面他的博客如果聊这个我会po个链接)，虽然我们大家可能回想到一个很有弹性的东西，但是对美术而言，这个东西不做出来，真的很难直到是什么样，也很难知道究竟是什么素材，所以美术待机的时长明显很多。 另外一点是关卡上，虽然Tilemap本身对于平台跳跃游戏确实很适合，但是我们将尝试史莱姆的手感放在了太过于后手的位置，因为我们得先搞定史莱姆那种粘稠的感觉，现在想来，也许让整只史莱姆交给美术呈现，它的跳跃高度足够稳定，也就能更好地设计关卡了，但遗憾的是我们太想将一开始的那种模拟史莱姆的感觉先做出来了，而做手感是一件很耗时间的事情，让调整各项角色的数值放在关卡设计前，是我们这一次犯下的一个非常巨大的错误。 还有一些平台跳跃的老生常谈话题，比如地板的一些设置啊之类的，虽然最终还是完成了开发，但是也暴露了很多问题，也许这一次的经验能够比上一次较顺利的开发学到更多。 经验总结 创意选择 px跟我说如果很难决定那个创意的话，可以画一个xy轴图，横轴为实现难度，纵轴为有趣程度，这样来衡量各个创意的价值，判断在GameJam中是否可行的问题。 这样可以避免选择创意时，用很高的成本来完成一个不那么有趣的想法，或者退而求其次的为了保证最后开发的完成而仅仅选择一个差强人意的想法。如果组内声音不一样的话，还是可以用这种方法来做，在这方面还是需要程序来把关，因为还是需要主程才能给出一个更为确切的时间。 遵循上面的逻辑并不一定要在创意完全完善后，而是在体现创意上需要多少成本来决定，如果不够好那就不要可惜地尽早放弃吧。 时间规划 必须保证创意在第一天讨论的1h前确定，这很重要，因为一个创意定下来后，还需要讨论很多细节，比如设计一个样例的关卡推演当前机制下通过的方法，判断有没有漏洞等。 除此之外，总是在当前任务完成前，决定好下一步究竟要做什么，这也是很重要的一步。另外对于成员技能的了解，知道他们都能做什么，能够更好地规划他们需要做的任务，很多东西还是要分清楚。 地点选择 也许开发的地点，周围的氛围比你想象中的重要许多，如果你在一个大家不能够或不方便开口沟通的环境，那么这种大家一起完成一件事的氛围就会被破坏掉，而这不仅仅影响在做事的个人，同时对于团队的整体氛围是非常大的打击，如果真的没有这样的地点，那么也许让成员早点回去过过周末，养精蓄锐也是不错的选择。 任务分配 我不得不说，这是我第一次跟其他程序共事，给他人分配任务是一件很困难的事情，对此我长话短说，如果有个人和你的能力相近，尽量将任务对半切开分配，意思是做的任务尽量不要相互干涉，不要你等我，我等你，当然实际开发中待机的情况总归难以避免，只能说尽量减少这种无意义的等待，有的时候它不是休息，反而消磨热情。 Nago GameJam 不得不说，GameJam还得是线下赛有氛围得多，在此也得感谢Nago以及第一次GameJam的主办方Cyte-Lab，不过还是希望Nago下次选的地址有条件的话能好点，那个位置其实也不是特别的理想（缺氧+少插座） 这一次的主题是“转”。大概思路的形成过程就主要往两方面，一个是通过操作控制转，另一个就是本身就在转，最终我们定在了本身就在转上，并且想到了一个双星系统，通过切换围绕的对象来在宇宙中进行移动。 游戏的试玩链接，还是需要挂个梯：Gemini Orb 双子星 开发 然而不得不说，这次是开发上最不顺利的一次，也是开发时间最短的一次，因为我们第一次跟这边的美术打配合，然后美术很难理解我们需要的是什么，虽然我们已经说的很清楚是4个球了，但是她们那边一直在纠结，最初提供的第一版素材中，只有黑洞后背景是可用的，而控制的星球已经碰撞的星球则在周日的中午才给出来，导致这边不得不放弃了星球破碎后重新复原的动画。最后我还给场景中的星球加了一下光源，让整体的感觉好了不少，就这样上去交了。 当然，从结果来看，我们拿下了最佳人气，大家也都挺开心的。但是我还是实在高兴不起来，说实在话，也是在这次gamejam后，让我觉得gamejam并不是真的那么好玩，美术完全两个人窝在一块，而我和策划三个人各聊各的，加上这次本来就是对美术压力极小的一次，但是仍然没有完成需求，多少是有点难受的，因为待机，这也是我们花费时间最少的一次，甚至周六晚上我还回去打猎杀对决了。 经验总结 寻找志同道合的朋友 不管是最初吉比特的三个月的开发，还是第一次gamejam，在流程上顺利的很大一个特点，就是志同道合，因为当大家都觉得所开发的游戏是有价值的，才会尝试去全力以赴，向着大家所想像的那个最终作品为之努力。这次开发上最大的问题在于美术与我们的观念是有很大的冲突的，她们本来就很倾向于讲一个故事，玩法反而被放到了其次；而我们则认为尤其对gamejam拿出一个玩法是最重要的，故事可以只设定一个背景，我只需要知道操纵的角色究竟是什么就可以了，观念上的分歧导致我们难以通力合作，即使坐在一张桌子上，也难以相互沟通。 实装才能测试出问题 对于美术素材而言，只有实装并且和程序绑在一块运行，才能容易看出问题，美术短时间内出一个草稿装入程序后，再给回美术去看是最好的（想念狸鱼老师的专业），同时不仅是程序在时间上要预留bug的处理时间，美术也要一定地预留返工的时间，在最早拿不定主意的时候，更需要多出草稿来看能不能接近预料中的效果，还有就是策划能够帮忙装素材并且在这方面给出意见也是相当重要的。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://yzs020220.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://yzs020220.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"PotPlayer简单的视频超分辨率与插帧","slug":"PotPlayer简单的视频超分辨率与插帧","date":"2023-10-24T13:44:34.000Z","updated":"2023-10-24T14:07:41.659Z","comments":true,"path":"posts/38947/","link":"","permalink":"https://yzs020220.github.io/posts/38947/","excerpt":"PotPlayer光是绿色无广告就已经足以成为大部分人使用它作为视频播放器的理由，但其实只需要一些简单的设置，它就能实现现在手机厂商大肆宣传的所谓超分与插帧","text":"PotPlayer光是绿色无广告就已经足以成为大部分人使用它作为视频播放器的理由，但其实只需要一些简单的设置，它就能实现现在手机厂商大肆宣传的所谓超分与插帧 按tab能够看到播放视频的一些信息 使用GPU Windows的默认策略会让你视频播放走集显，在设置的系统-&gt;屏幕-&gt;显示卡点开PotPlayer点击选项，选择高性能即可 插帧 我个人其实不太使用这个，因为一般是看电影 倍帧 打开PotPlayer，点击左上角的标题，在下拉栏中点击选项 在视频-&gt;图像处理中勾选倍帧即可 SVP4 这个要付费所以我没有搞 超分辨率 这个个人觉得比较实用，而且效果也比较不错 无RTX系列显卡用户 同样是在选项中，点击视频，视频渲染器选择DirectX3D 11渲染器，然后勾选D3D11 GPU超分辨率 RTX系列显卡用户 20系显卡需要更新最新的Nvidia驱动，在10.10更新了对视频超分辨率的支持 下载Release MPC-VR RTX SuperRes 1.1并解压到一个你不会删除的文件夹 右键管理员身份运行Install_MPCVR_64.cmd后双击Reset_Settings.cmd 在PotPlayer的选项中选择视频渲染器为MPC视频渲染器","categories":[{"name":"杂","slug":"杂","permalink":"https://yzs020220.github.io/categories/%E6%9D%82/"}],"tags":[{"name":"杂","slug":"杂","permalink":"https://yzs020220.github.io/tags/%E6%9D%82/"},{"name":"自腾","slug":"自腾","permalink":"https://yzs020220.github.io/tags/%E8%87%AA%E8%85%BE/"}]},{"title":"Godot Engine第一课","slug":"Godot-Engine第一课","date":"2023-10-10T12:09:24.000Z","updated":"2023-10-11T09:00:02.847Z","comments":true,"path":"posts/12182/","link":"","permalink":"https://yzs020220.github.io/posts/12182/","excerpt":"看看Godot吧","text":"看看Godot吧 写在前面 关于Unity 说完全放下Unity自然是不太可能的，不过可能自己在这方面是暂时不会再往深的去钻研了，当然找工作方面的面经还是会背的，这方面缺的课有空也会去补。 虽然说目前Unity的总裁已经离职了，但是管理层的混乱想必也会让这家公司短时间内难以回到正轨，我个人当然希望Unity能够重新回到发布运行费的前一天，但是恐怕它真的说要和好如初，我可能也不太愿意吧（就像前女友找你复合一样）。 当然我也感谢Unity陪我度过了那段我最具激情的学习游戏开发的时光，作为我最趁手的工具完成了两次比赛的作品。游戏开发本就是需要一个人付出热忱的事情，虽然现在乃至以后我也不会做出什么真的摆上台面的作品，但是当你看着那个规定，进退两难，恐怕是连前进的欲望都没有了。我个人大概是一个没什么上进心的人，害就这样吧。 关于Godot 一直以来对于Unity对于Unreal的优势，无非是能做2D与开发社区的强大，然而Unity的操作往Godot注入了一批新鲜血液，对于Godot社区的壮大我个人是持乐观态度的，将来的一段时间内Godot的社区无疑会引来一段增长期。 选择Godot的本质原因是我希望我个人使用的引擎是能快速验证创意做出成品的，所以像虚幻这种大型并且从设计的出发点来讲就不是个人使用的，加之不能做2D，我就暂时不予考虑了。 Godot的各项设计对于使用过Unity的人而言其实并不是很难，其实从上手的简单程度来说，我个人认为Godot甚至简单过Unity，文章标题的第一课其实是总结一下我怎么开始学Godot的经验。 Godot学习 视频教程 虽然读英文不是很难，但如果中文教程有足够的质量为什么不选呢，推荐B站戈多翰的视频 这个视频简明并且做了教案，很多东西逻辑都说的很顺且很快，而且也不会说什么废话，不过因为说的很快所以可能视频会要求有代码功底或者编程思维 通过这个视频可以很快速地了解Godot引擎和其他引擎的不同，整个项目结构是怎么样的 实践 真正实践其实有好几种方案，可以直接上手做想做的，也可以找个教程跟着做，或者还是先从最经典的平台跳跃开始一边查文档，搜视频做，我个人选择最后一种方法 以下也给出几个我常用的网站： 官方文档：Godot Docs – master branch — Godot Engine (4.x) 简体中文文档 shader网站：Godot Shaders - Make your games beautiful! 资源商店：Godot Asset Library (godotengine.org) Godot官方示例项目：godotengine/godot-demo-projects: Demonstration and Template Projects (github.com) 反正最近就是一边上班，一边做毕设，一边准备笔试面试，一边摸Godot，反正时间挤一下还是有的，后面有空我搞定Godot的第一个demo应该也会写写博客吧，反正慢慢来","categories":[{"name":"Godot","slug":"Godot","permalink":"https://yzs020220.github.io/categories/Godot/"}],"tags":[{"name":"Godot","slug":"Godot","permalink":"https://yzs020220.github.io/tags/Godot/"}]},{"title":"一些经典的算法与模板--笔试用","slug":"一些经典的算法与模板-笔试用","date":"2023-09-09T11:39:43.000Z","updated":"2023-10-17T15:28:50.600Z","comments":true,"path":"posts/8026/","link":"","permalink":"https://yzs020220.github.io/posts/8026/","excerpt":"很久没有写博客了，最近也是换了电脑，也就把博客迁移过来顺便写一篇博客吧","text":"很久没有写博客了，最近也是换了电脑，也就把博客迁移过来顺便写一篇博客吧 前言 最近也是金九银十的秋招季，投出去的简历也是陆陆续续受到了答复，笔试自己也要开始来准备了，总之好好抓紧吧。 笔试中，算法毫无疑问是一个大头，很多东西可能不考，唯独算法一定会考，要过第一趟笔试，算法是无法避免的，很多东西还是得多多规划总结，才没那么容易忘，所以还是写写好。 如何入手 当你拿到一道题目，首先应该按顺序干如下几件事： 看懂题目在说什么 搞明白题目需要你做什么 找到思路 写代码 某种程度上说，并不是完全按照步骤一步步做，因为从其他步骤也可能更好地入手，对这几方面大概探一下吧 题目在说什么 对于算法，我们大多数时候需要的是针对输入做一个输出，所以这个问题可以被简化为： 输入 输出 条件 重点关注以上三点就可以理解题目在说什么了 需要做什么 在明白输入输出条件后，我们还需要明白题目需要做什么，也就是所谓操作，一般来说分成如下两种： 数据处理：将抽象的数据转换为算法能够进行处理的数据结构 搜索求解：寻找问题的答案 找到思路 这一步骤可谓是最难的了，基本上也是这部分才是算法真正考验的地方，我还是大体来说一下这个思路怎么出来的过程吧（我自己的经验） 模拟：模拟问题的操作来求出结果，一般在小规模问题下做一遍也更能理解题目含义 可行解：是否能有暴力的方法能够求出，还是需要做其他文章 复杂度分析：数据总共有多少，如何去遍历，真正笔试时候还是要以求解优先，但是对于问题求解的规模是怎么样的也更能辅助你获得答案 确认算法：以上三步服务于这一步 实验：在小规模问题下实验思路的可行性 写代码 能用模板多用模板，不仅加快速度，更重要的是降低失误，对于像二分查找这种容易搞混的东西，在考场才研究+1-1这种细枝末节的东西往往花费时间，更搞乱了自己的心态，所以大体来说还是需要让自己做的更胸有成竹一些，写代码的步骤大概就是这样，少点犹豫。 输入处理成数据结构 套模板 输出 题型的模板究竟都有那些，主流的哪几类算法是怎么运作的，接下来就会大概谈谈。 算法及其模板 DFS 使用递归的回溯法 class Node&#123; int val; vector&lt;Node> childNodes; &#125; void DFS(Node node, int steps, int n) &#123; if(steps == n) return; for(Node child : node.childNodes) &#123; // 做操作 DFS(child, steps + 1, n); // 撤销操作 &#125; &#125; BFS 相较于DFS，一般能算出最优，而且不依赖递归，更容易debug找问题，不过如果是需要记录之前的状态，它会比DFS要难写不少（需要保存） class Node&#123; int val; vector&lt;Node> childNodes; &#125; void BFS(Node root) &#123; queue&lt;Node> q; q.push(root); while(!q.empty()) &#123; // 获取队头 Node node = q.front(); q.pop(); for(Node child : node.childNodes) &#123; q.push(child); &#125; &#125; &#125; 上述两种算法都可以用备忘录来优化 滑动窗口算法 因为不怎么用经常忘掉，大体来说是维护窗口，一般这类题目的特征是当序列的子串不满足条件时，序列一定不满足条件，而一般题目目的是寻找最大窗口 void SlidingWindow(string s, string t) &#123; unordered_map&lt;char, int> need, window; for (char c : t) need[c]++; int left = 0, right = 0; int valid = 0; while(right &lt; s.size()) &#123; char c = s[right]; right++; // 更新窗口数据 // 判断窗口左边是否需要收缩 while (window need shrink) &#123; char c = s[left]; left++; // 更新窗口 &#125; &#125; &#125; 不要倒在起点 与力扣不同，笔试的环境不一定足够好（比如不允许使用自己的IDE），总之还是需要做好一些准备的 特殊输入处理 不带次数直到结束 while(cin >> n); 根据每行获得输入 #include&lt;iostream> #include&lt;sstream> #include&lt;string> using namespace std; int main() &#123; string line; while(getline(cin, line)) &#123; stringstrem ss; ss &lt;&lt; line; int tmp; while(ss >> tmp); &#125; &#125; 模板类的使用 vector 构造 vector&lt;T> v; vector&lt;T> v(n); // 数量为n vector&lt;T> v(n, val); // 数量为n，值为val 插入 v.push_back(a); // 尾部添加 v.insert(it, a); // 在迭代器的前一个位置添加 删除 v.pop_back(); // 尾部删除 v.erase(it); // 删除迭代指向 v.clear(); // 清空 常用的指向 v.front(); // 返回首元素引用 v.back(); // 返回尾元素引用 v.begin(); // 迭代器指向首元素 v.end(); // 迭代器指向 增加删除vector中下标为i的元素 v.insert(v.begin() + i, num); // 插入num v.erase(v.begin() + i); // 删除 其他 v.size(); // 数组大小 unordered_set 初始化 unordered_set&lt;T> set; // T不能用vector但可以用string 当你需要存储vector时可以如此操作 unordered_set&lt;string> set; string str = \"\"; for(auto a: v) &#123; str += to_string(a) + \"-\"; &#125; set.emplace(str); 添加元素 set.emplace(val); set.insert(val); // 效率低点 查找该元素个数 set.count(key); 查找该元素引用（先确定元素个数不为０） set.find(key); 删除元素 set.erase(val); 其他 排序 sort从小到大排序 #include&lt;algorithm> vector&lt;int> v; sort(v.begin(), v.end()); // 升序 从大到小 sort(v.begin(), v.end(), greater&lt;int>()); // 降序 自定义 // 根据第二个元素从小到大 bool cmp(vector&lt;int> a, vector&lt;int> b) &#123; return a[1] &lt; b[1]; &#125; vector&lt;vector&lt;int>> nums; sort(nums.begin(), nums.end(), cmp);","categories":[{"name":"学","slug":"学","permalink":"https://yzs020220.github.io/categories/%E5%AD%A6/"}],"tags":[{"name":"学","slug":"学","permalink":"https://yzs020220.github.io/tags/%E5%AD%A6/"},{"name":"自用","slug":"自用","permalink":"https://yzs020220.github.io/tags/%E8%87%AA%E7%94%A8/"}]},{"title":"使用超链接防止你的C盘不知不觉中爆满","slug":"使用超链接防止你的C盘不知不觉中爆满","date":"2023-07-26T02:59:41.000Z","updated":"2023-07-26T03:15:55.145Z","comments":true,"path":"posts/25194/","link":"","permalink":"https://yzs020220.github.io/posts/25194/","excerpt":"可惜没有早点遇见你——mklink \\j","text":"可惜没有早点遇见你——mklink \\j 适用场景 某些你发现越用越大的文件夹，但是又不清楚在哪里进行更改路径从而调到其他盘，可能一般这种设置在软件里找不到就在环境变量或注册表里面，不过这样还是太难找了，而且可能里面的文件夹里又要设置多次，这种时候超链接就很有用了。 超链接是什么 我们经常能够看到快捷方式，超链接也是类似的，当它访问一个设置了超链接的文件夹会跳转到目标文件夹里，这样我们就可以在不更改软件设置的情况下，将原文件夹的路径实际更改为另一个盘中的路径。 如何使用 设置超链接的命令 mklink \\j \"原文件夹路径\" \"目标文件夹路径\" 例如我要移动Unity的缓存文件到D盘新设置的文件夹中，需要如下几个步骤 剪切原文件夹C:\\Users\\username(你的用户名)\\AppData\\Local\\Unity到目标文件夹的地址D:\\WorkSpace\\Local\\Unity 输入命令 mklink /j \"C:\\Users\\username(你的用户名)\\AppData\\Local\\Unity\" \"D:\\WorkSpace\\Local\\Unity\" 就是这么简单，其他的例如Unity的Asset Store文件夹（在C:\\Users\\username(你的用户名)\\AppData\\Roaming\\Unity）也能这么使用","categories":[{"name":"杂","slug":"杂","permalink":"https://yzs020220.github.io/categories/%E6%9D%82/"}],"tags":[{"name":"杂","slug":"杂","permalink":"https://yzs020220.github.io/tags/%E6%9D%82/"},{"name":"自用","slug":"自用","permalink":"https://yzs020220.github.io/tags/%E8%87%AA%E7%94%A8/"}]},{"title":"CIGA GAMEJAM 南山站-记第一次GAMEJAM","slug":"CIGA-GAMEJAM-南山站-记第一次GAMEJAM","date":"2023-07-15T09:09:09.000Z","updated":"2023-07-15T14:18:00.163Z","comments":true,"path":"posts/14513/","link":"","permalink":"https://yzs020220.github.io/posts/14513/","excerpt":"终于是有空写写GameJam这个激动人心的活动了，写这篇博客也希望以后能回想起这个快乐的时光，也po一下试玩链接-Don’t touch 喵(可能需要梯子)吧","text":"终于是有空写写GameJam这个激动人心的活动了，写这篇博客也希望以后能回想起这个快乐的时光，也po一下试玩链接-Don’t touch 喵(可能需要梯子)吧 赛前 还是px认识的人多啊，开赛前的组队全权交给了px，实际上大家也都相处的很好，难得的又收获了一份友谊。赛前px还在群里发一堆乱七八糟的视频，什么GameJam经验之类的，嘛，我觉得GameJam最为重要的一个目标，一定是把游戏做完，在开题前看看视频，也是一个不错的选项吧。 头脑风暴 开题 开题“touch”实在是太宽泛了，一开始很容易先想到手游，可是手游是实际上的touch而不是游戏内的touch，要从玩法的角度上来想，其实难度也就来了。 我本来感觉开始的时候互相还不太放得开（唯一认识四个人的在上班），但是到我们真正选好座位，坐下来脑暴，我们的思想就热情地拥抱在了一起。 脑暴的大致环节是列一堆乱七八糟的点子，然后把这些点子有机结合一下。 最开始阿亮先提出了一个可能是喷喷玩多了想到的点子，这个游戏的玩法大致就是会有人在追逐而且路上会留下墨水，然后玩家不能touch这个墨水，不过玩家有一把喷墨的枪，CD到了就能射，射出的墨水自己也可以走。 这个想法也不错，但是它真的太喷喷了，而且他一开始还跟我说这个最好360度，我说这个写起来还是有点麻烦，而对于两个美术来说，这个东西太过于抽象了，也很难发挥我们两个美术的配置（阿亮还设计了一个四向的关卡，在我脑海里它的画面能跟ET还有吃豆人扳手腕）。 玩法确定 然后才是我们做的这个，奇怪的是其实跟上一个想法是有联系的（这个东西说给玩的人那真的完全不是一个东西），因为亮预设的是拿钥匙开门，我们讨论了一下拿钥匙完成应该也有相当的风险，于是就变成了猫用手沾番茄酱，然后去摸主人，因为猫走在路上，番茄酱会沾到地上，也就会掉完，所以必须在一定距离内将番茄酱沾到主人的身上，于是这个玩法的雏形就这么定了下来，然后我们去吃饭了（其实我走的时候还一直在思考这就是玩法了？再怎么说这也不太行吧，不过肚子也饿了，该吃饭了）。 吃完饭之后，我们才开始真正定下来我们要做的，因为主人不会想被沾到番茄酱，也不愿意在厨房看到自己家的猫，所以猫要偷偷摸摸地在厨房里，拿到番茄酱，并且沾到主人身上，于是我们游戏的核心机制就变成了一个潜行的机制。 我不得不说这个走向真的是出乎意料了，它真的越来越不“touch”了的感觉，但是大家也都觉得这个东西是挺有意思的，阿亮跟我都是《耻辱》的忠实粉丝，而我更是《杀手》的狂热玩家（虽然其实总共也就150h而已啦），但是感觉能做一个至少自己是蛮喜欢的游戏类型，很棒！ 核心敲定了，开始敲细节，因为我们预订的是一个下午加晚上确定完所有，第二天全力开发，第三天再修修补补。于是我们就开始吵架了，最为关键的，就是怎么失败，也就是怎么被发现。 吵架 这个地方我们确实是各执己见，两个美术可能已经没有什么困惑了，而两个策划和一个程序（怎么我作为程序也吵得那么欢）却在吵架，因为我觉得这个地方是一个非常难得的一个体验，所以我可能写的也会比较多。主要就是我们对怎么样猫被发现，产生了争执： 亮：从现实的角度出发，当主人转身的时候，他就看到了一个毛茸茸的玩意，他就得去抓他，因为他知道你在厨房了，所以你必须在他真正看清你之前，找到地方藏起来，否则就被发现。 px：从玩家的角度出发，被发现的时候主人会先来尝试抓你，但是他还没完全走过来把你抓住之前你可以赶紧藏起来，这样就有一种追逐战的感觉。 我：感觉很和稀泥，但是最后还是我提出的方案（我其实是因为作为程序要实现，所以这方面我必须很明确他们的意图，所以我才跟他们吵）被采用了，我们将警戒度分为了问号与感叹号，问号代表主人好像看到了，感叹号代表真的看到了，然后好像看到了的话，主人会逐渐靠近，并且越近问号增长的越快，问号增长完就会变成感叹号，这个时候猫还可以藏在2级（我们定义躲藏进特殊物体为２级，躲藏进安全区域为１级）来躲避主人，虽然最后感觉复杂了很多，但是我们总算敲定了一个大家都没有疑惑的方法。 吵完这个之后，我们大概罗列了美术与程序的需求上的优先级，然后就各回各家，第二天早上起来准备全力干活。 开发 这个地方可能我作为程序就是埋头苦干罢了，因为我们其实是一个猫猫在厨房跳来跳去，所以一开始是平台跳跃的内容，然后一开始的手感其实卡了一会，因为我其实是第一次做就是没有键程的固定跳跃（因为关卡需要），大概试了几种实现方式就解决了，也是小问题。 后面的话也比较顺利吧，策划那边给的需求也比较清晰，美术和程序手上也一直有活干，没有各等各的情况，需求表列完后，px帮忙写UI，亮反而跑去画开场CG了。 关于开场CG，我个人也是很喜欢这个为什么猫要沾番茄酱到主人身上的理由： 喵喵，你是一只叫做塔什Touche的小猫，你很喜欢番茄酱。但是主人阿法罗Affaro不喜欢番茄酱。Touche曾经见过女主人艾莉娅Eria在Affaro身上留下红色印子，这让Affaro很高兴！于是Touche决定也用这种方法让Affaro爱上番茄酱…… 开场CG 到基本框架出来后，我们第一天的任务也就完成了，然后回去睡觉。 到第二天的时候其实也不能说我们的时间就非常的充裕，我程序这边早上在写bug（我们本来想给主人加个东张西望的状态，但是因为这个扭头的操作是用协程写的，如果中间玩家的操作触发了改变了主人的状态，因为扭完头后主人会恢复巡逻状态，而如果此时它本来应该是警戒状态，那么它不该恢复），那由于时间问题，我还是取消了这个东张西望的逻辑（感觉其实只是细节上的，删了也影响不大），但是时间还是确实花费掉了，最后的几个小时，我完善了猫躲进物品里的逻辑，然后px搞定了UI的显示，然后再合力装完胜利和结束的CG，我们的作品也就完成了。 鸭力山大 摆摊试玩 我实在是很喜欢这个环节，在这个环节，你能亲眼目睹自己的游戏怎么被人玩，评价如何，改进的建议等等，作为程序，我还能看到别的程序来我这里故意测bug（哈哈，不过大家对bug更多的是相视一笑，不过我的水平也还确实有问题就是了）。从整体上看，我们的游戏还是得到了很多的好评，这种能够跟在玩你游戏的人面对面的体验真的非常难得。 大屏幕展示试玩现场 反馈 试玩这个阶段最奇特的，就是大家不一定按照你所想的玩游戏，潜行游戏的核心其实是路线规划与探索（探索才知道路线），不过首先的第一点反馈，就是平台不明显，因为我们的平台是和背景容为一体的，所以一开始在场景中寻找可能的平台（其实我们的平台都是平行于地板的），也是我们的一个探索的部分，不过这一方面自然也有问题，因为我们发现不少人发现不了毛巾架是平台，同时我们设计了不少上平台的路，但玩家都选择了固定的一条路线去走。 第二点的反馈是，我们在安全区域并没有做额外的提示，导致玩家并不知道在场景内的阴影是不会被发现的，而且他也给了我们建议，就是能够在猫的背上做阴影来说明猫在影子下。 第三点的反馈是，希望能在靠近可交互物品时有按键提示（本来预定做但没时间做的，说明这个优先级其实应该往前放）。 玩别人的作品 哈哈，玩别人的作品当然也是一件很有意思的事情，我印象比较深刻的有几个吧 打假拳，就是你要努力被人打倒，但是又不能被观众发现，主要是双人游戏共用一个手柄，还要抢着按对方的按键让对方出招（现实世界的touch了），玩起来很欢乐 两个手相碰的，实际上玩起来蛮欢乐的，就是碰的时候不能太大力也不能太小力，两个人要控制好碰的时机和距离 凉医，我觉得是我们赛区最好的，用振动马达来把脉，完美贴合touch这个主题了，不过我现场没玩到没评分，还是后面在群里下安装包玩的，真的很棒 我还通关了一个滑滑冰的，就是两个人滑冰碰到一块就胜利，灵感来自UT的滑冰，我跟作者也聊了一会这个玩法的局限性（因为自己有试过滑行这个逻辑，但觉得这个玩法做拓展难度太大了） 关于作品最后的碎碎念 我们的作品本身在引导上还没有完全完善，我们本来是希望猫能从窗户出发，而且给窗户做一个躲藏的设计，这样玩家就知道有颜色的物品都是可以交互的，并且开始的平台也会告诉玩家，场景中有很多这样的平台需要去寻找。 本来还计划做出闹钟定时响起吸引主人的操作，这个也是没来得及完成，这方面也会需要音效方面的逻辑，确实是来不及弄。不过其实试玩后我才感受到，GameJam实际上更应该注重一个最主要的体验，一些像物品这种小的逻辑，在GameJam中玩家不一定会玩的到，而在开发中添加一点新东西其实就是整套逻辑，所以还是要尽量避免就是一套逻辑只用在一件物品上，我们的冰箱就是这样，实际上因为这件物品的逻辑太过特殊，很多玩家根本不明白交互后冰箱打开创造平台并会吸引主人，其他物品都有隐藏的功能，而玩家打开冰箱反而吸引主人，导致在试玩阶段我没有见到一个玩家选择冰箱的路线（甚至很多玩家一打开冰箱就被发现了，可能会被玩家认为是一个所谓的坑）。所以无论从开发还是从玩家的角度来说，我觉得这都是一件需要注意的事情。 GameJam的大部分作品只会被玩一次，所以引导是非常重要的，因为第一次的游戏体验就几乎是所有的游戏体验了，不管是有人在旁边引导也好，还是关卡内的设计也好。 对于我们的作品来说，我觉得我们的作品绝对称得上是有趣的，开发的时候觉得有趣，玩的时候也觉得有趣，对我们团队来说，能看到玩我们的游戏的人真的露出笑容，那就是最有成就感的时候。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://yzs020220.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://yzs020220.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"Unity延时操作","slug":"Unity延时操作","date":"2023-07-06T12:18:33.000Z","updated":"2023-07-06T13:26:47.361Z","comments":true,"path":"posts/61203/","link":"","permalink":"https://yzs020220.github.io/posts/61203/","excerpt":"继续写新的博客，生活也要敢于迈出新的步伐，博客内容参考雨松大大的《Unity3D游戏开发》","text":"继续写新的博客，生活也要敢于迈出新的步伐，博客内容参考雨松大大的《Unity3D游戏开发》 定时器的代码以及调用 全代码如下： using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.Events; public class WaitTimeManager &#123; // 内部类 class TaskBehaviour : MonoBehaviour &#123; &#125; private static TaskBehaviour m_task; /// &lt;summary> /// 构造方法 /// &lt;/summary> static WaitTimeManager() &#123; GameObject go = new GameObject(\"#WaitTimeManager#\"); GameObject.DontDestroyOnLoad(go); m_task = go.AddComponent&lt;TaskBehaviour>(); &#125; /// &lt;summary> /// 返回协程任务 /// &lt;/summary> /// &lt;param name=\"time\">等待时间&lt;/param> /// &lt;param name=\"callback\">无参匿名方法&lt;/param> /// &lt;returns>&lt;/returns> static IEnumerator Coroutine(float time, UnityAction callback) &#123; yield return new WaitForSeconds(time); if (callback != null) &#123; callback(); &#125; &#125; /// &lt;summary> /// 外部调用启动协程任务 /// &lt;/summary> /// &lt;param name=\"time\">等待时间&lt;/param> /// &lt;param name=\"callback\">无参匿名方法&lt;/param> /// &lt;returns>协程任务&lt;/returns> static public Coroutine WaitTime(float time, UnityAction callback) &#123; return m_task.StartCoroutine(Coroutine(time, callback)); &#125; /// &lt;summary> /// 取消协程任务 /// &lt;/summary> /// &lt;param name=\"coroutine\">协程&lt;/param> static public void CancelWait(ref Coroutine coroutine) &#123; if(coroutine != null) &#123; m_task.StopCoroutine(coroutine); coroutine = null; &#125; &#125; &#125; 调用示例如下： Coroutine coroutine = WaitTimeManager.WaitTime(5f, delegate &#123; Debug.Log(\"等待5s后回调\"); &#125;); // 或用lambda表达式 Coroutine coroutine = WaitTimeManager.WaitTime(5f, () => &#123; Debug.Log(\"等待5s后\") &#125;); // 取消等待 WaitTimeManager.CancelWait(ref coroutine); 代码详解 我第一次看这个代码的时候，感觉比较奇怪，其实这个代码确实算是比较难以理解，在网上大家也是更加关心功能，我也找不到类似的解析，其实这个代码只是将单例与内部类结合起来以精简代码(我是这么理解的) /// &lt;summary> /// 构造方法 /// &lt;/summary> static WaitTimeManager() &#123; GameObject go = new GameObject(\"#WaitTimeManager#\"); // 创建一个GameObject GameObject.DontDestroyOnLoad(go); // 设置为不被销毁 // 添加内部类到GameObject并指定WaitTimeManager中的静态m_task为新建的组件 m_task = go.AddComponent&lt;TaskBehaviour>(); &#125; 我们可以在Hierachy下的DontDestoyOnLoad中找到这个GameObject，并且看到它其中的m_task，之后我们调用的WaitTimeManager中的方法，都是通过这个m_task来启动或取消协程任务","categories":[{"name":"Unity","slug":"Unity","permalink":"https://yzs020220.github.io/categories/Unity/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://yzs020220.github.io/tags/C/"},{"name":"Unity","slug":"Unity","permalink":"https://yzs020220.github.io/tags/Unity/"}]},{"title":"Unity3d客户端面经准备","slug":"Unity3d客户端面经准备","date":"2023-06-04T02:29:05.000Z","updated":"2023-10-17T15:51:53.981Z","comments":true,"path":"posts/21944/","link":"","permalink":"https://yzs020220.github.io/posts/21944/","excerpt":"边敲边记，打起精神，屡败屡战","text":"边敲边记，打起精神，屡败屡战 语言相关 面向对象语言的三大特性 继承、封装、多态 继承 继承可以使得子类具有父类的各种属性和方法，而不需要再次编写相同的代码。在令子类继承父类的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类的原有属性和方法，使其获得与父类不同的功能。 封装 隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读取和修改的访问级别。 多态 相同的消息可能会送给多个不同类别的对象，系统根据对象所属类别，引发对应类别的方法，而有不同的行为。 虚函数 虚函数(多态的实现方式)：当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定。 虚函数表指针(vptr)会指向一张名为“虚函数表”的表(在堆中)，表中数据为函数指针，调用时通过对象内存找到对应虚函数的实现区域并调用。 构造函数不能是虚函数，而析构函数可以是虚函数且最好设置为虚函数(避免内存泄漏)。 new和malloc的区别 malloc和free是库函数，new和delete是C++操作符，new自己计算空间的大小，而malloc需要指定大小 C#装箱拆箱 装箱就是将值转换为引用类型，拆箱就是将引用类型转换为值类型 const修饰符的用法 const常用来定义一个常量，这个常量是不可变的，也就是一旦被定义后不可以对其进行修改。 常见的用法：const变量为只读，不应被改变，可以通过编译的错误提示来检查错误，提高程序的安全性和可靠性。 注意不能与static修饰符同时使用，如const static int value是错误的 static修饰符的用法 static是静态的，不变的，在某一个类中只有一个，不会因实例化对象的不同而不同。在声明一个类时使用static关键字，具有两个方面的意义：防止程序员在代码中实例化该静态类；防止在类的内部声明任何实例字段或方法 静态类的主要特性： 仅包含静态成员 无法实例化 静态类的本质，是一个抽象的密封类，所以不能被继承，也不能被实例化 不能包含实例构造函数 如果一个类下面的所有成员，都需要被共享，那么可以把这个类定义为静态类 一般在单例模式下被使用 内存泄漏 向系统申请分配内存进行使用，但是使用完没有释放内存。 以发生的方式分类，内存泄漏可以分为4类： 常发性内存泄漏：发生发生内存泄漏的代码被多次执行到，每次被执行的时候都会导致一块内存泄漏 偶发性内存泄漏：发生内存泄漏的代码只在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的，对于特定环境，偶发性也许变成了常发性 一次性内存泄漏：发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块且仅一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存。 隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束时才释放内存。严格来说没有发生内存泄漏，但是不及时释放内存也可能导致最终耗尽系统的内存，所以称为隐式内存泄漏 从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到 智能指针 C++在STL中提供了四种智能指针：auto_ptr, unique_ptr, shared_ptr, weak_ptr，auto_ptr在C++98中提出，在C++11中被摒弃，并提出unique_ptr代替auto_ptr unique_ptr 旨在替代不安全的auto_ptr。它持有对对象的独有权，两个unique_ptr不能指向一个对象，即unique_ptr不共享它所管理的对象。它无法复制到其他unique_ptr，无法通过值传递到函数，也无法通过值传递到函数，也无法用于需要副本的任何标准模板库算法。只能移动unique_ptr，即对资源管理权转移，并且原始unique_ptr不再拥有此资源 unique_ptr&lt;int> ptrA(new int(1)); // 构建 unique_ptr&lt;int> ptrB = std::move(ptrA); // 所有权转移 ptrB.reset(ptrA.release()); // 所有权转移 unique_ptr与原始指针一样有效，并可用于STL容器。 实现方式是将拷贝构造函数和赋值操作符都声明为delete或private auto_ptr 与unique_ptr类似，但是允许拷贝，由于拷贝后原对象变得无效，再次访问原对象会导致程序崩溃(而unique_ptr则会在编译过程中报错)，在访问unique_ptr前，可以使用get()进行判空操作 unique_ptr&lt;string> upt1 = std::move(upt); if(upt.get() != nullptr) &#123; // do something &#125; unique_ptr还扩展了auto_ptr的功能 可放在容器中 vector&lt;unique_ptr&lt;string>> vs&#123; new string(\"AA\"), new string(\"BB\") &#125;; 管理动态数组 unique_ptr&lt;int[]> p (new int[3]&#123;1,2,3&#125;); p[0] = 0; 自定义资源删除操作 void end_connection(connection *p) &#123;disconnect(*p);&#125; shared_ptr 引用计数放在堆上，多个shared_ptr的对象引用计数都指向同一个堆地址 实现手写 class Point&#123; private: int x, y; public: Point(int xVal=0, int yVal=0) : x(xVal), y(yVal) &#123;&#125; int getX() const &#123;return x;&#125; int getY() const &#123;return y;&#125; void setX(int xVal) &#123;x = xVal;&#125; void setY(int yVal) &#123;y = yVal;&#125; &#125; class RefPtr&#123; private: friend class SmartPtr; RefPtr(Point *ptr):p(ptr), count(1) &#123;&#125; ~RefPtr()&#123;delete p;&#125; int count; Point *p; &#125; class SmartPtr&#123; private: RefPtr* rp; public: // 构造函数 SmartPtr() &#123; rp = nullptr; &#125; SmartPtr(Point* ptr) : rp(new RefPtr(ptr)) &#123;&#125; SmartPtr(const SmartPtr &amp;sp) : rp(sp.rp) &#123; rp->count += 1; &#125; // 重载运算符 SmartPtr&amp; operator=(const SmartPtr&amp; rhs) &#123; rhs.rp->count += 1; if (rp != nullptr &amp;&amp; --rp->count == 0) &#123; delete rp; &#125; rp = rhs.rp; &#125; Point* operator->() &#123; return rp->p; &#125; Point&amp; operator*() &#123; return *(rp->p); &#125; ~SmartPtr()&#123; if(--rp->count == 0) delete rp; else cout &lt;&lt; rp->count &lt;&lt; \"pointers left\\n\"; &#125; &#125; 智能指针的使用注意事项 优先使用make_shared和make_unique是为了避免内存泄漏 不使用相同的内置指针值初始化，或reset多个智能指针 不delete get()返回的指针 不使用get()初始化或reset另一个智能指针 get()返回的智能指针可能变成dangling pointer 如果智能指针管理的内存不是new出来的，需要提供删除器 算法与数据结构 红黑树 节点颜色有红色和黑色 根节点必为黑色 所有叶子节点都是黑色(空节点) 任意节点到叶子节点经过的黑色节点数节目相同 不会有连续的红色节点 排序算法 归并排序 为两个已排序的序列申请空间，在设定两个指针，将较小的元素放入空间中，以此反复。 算法复杂度： 空间复杂度：O(n)O(n)O(n) 最坏时间复杂度：O(nlg⁡n)O(n\\lg n)O(nlgn) 最好时间复杂度：O(nlg⁡n)O(n\\lg n)O(nlgn) 平均时间复杂度：O(nlg⁡n)O(n\\lg n)O(nlgn) void MergeSort(int num[], int size) &#123; int len, start, end; // len为已有序数组的长度 for (len = 1; len &lt; size; len *= 2) &#123; for (start = 0, end = start + len * 2 - 1; start &lt; size; start += len * 2, end += len * 2) &#123; int *left = new int[len]; int *right = new int[len]; int rightlen = 0, leftlen = 0; // 拷贝数据进左右队列 for (int i = 0; i &lt; len &amp;&amp; start + i &lt; size; i++) &#123; left[i] = num[start + i]; leftlen++; &#125; for (int i = 0; i &lt; len &amp;&amp; start + len + i &lt; size; i++) &#123; right[i] = num[start + len + i]; rightlen++; &#125; int i = 0, j = 0; for (int index = start; index &lt; start + len * 2 &amp;&amp; index &lt; size; index++) &#123; // 左或右队列已全部放入 if (i >= leftlen) &#123; num[index] = right[j]; j++; &#125; else if (j >= rightlen) &#123; num[index] = left[i]; i++; &#125; // 比较左右队列的当前数字，小的放入 else if (left[i] &lt;= right[j] || j >= rightlen) &#123; num[index] = left[i]; i++; &#125; else &#123; num[index] = right[j]; j++; &#125; &#125; delete[] left; delete[] right; &#125; &#125; &#125; 快速排序 选定一个基准值(最右)，左边下标往右跑，比它大的放到空位上，再右边下标往左跑，比它小的放到空位上，再更换下标以此类推，直到左右下标相遇(left&gt;right)，将值放入空位上，在分为左边和右边来进行递归操作 算法复杂度： 空间复杂度：O(lg⁡n)O( \\lg n)O(lgn) 最坏时间复杂度：O(n2)O(n^2)O(n2) 最好时间复杂度：O(nlg⁡n)O(n \\lg n)O(nlgn) 平均时间复杂度：O(nlg⁡n)O(n\\lg n)O(nlgn) #include &lt;stack> using namespace std; class Seg &#123; public: int start, end; Seg(int _start, int _end) &#123; start = _start; end = _end; &#125; &#125;; void QuickSort(int *num, int size) &#123; stack&lt;Seg> st; Seg firstSeg(0, size - 1); st.push(firstSeg); while (st.size() > 0) &#123; int start, end, pivot; Seg seg = st.top(); st.pop(); start = seg.start, end = seg.end; pivot = start; bool isDone = false; int left, right, key; left = pivot + 1, right = end, key = num[pivot]; while (left &lt;= right) &#123; isDone = false; while (num[right] >= key) &#123; right--; if (right &lt;= pivot) &#123; isDone = true; break; &#125; &#125; if (isDone) break; num[pivot] = num[right]; pivot = right; while (num[left] &lt;= key) &#123; left++; if (left >= pivot) &#123; isDone = true; break; &#125; &#125; if (isDone) break; num[pivot] = num[left]; pivot = left; &#125; num[pivot] = key; if (start &lt; pivot - 1) &#123; Seg leftSeg(start, pivot - 1); st.push(leftSeg); &#125; if (end > pivot + 1) &#123; Seg rightSeg(pivot + 1, end); st.push(rightSeg); &#125; &#125; &#125; 堆排(TopK) TopK问题描述：快速在一个无序序列中找到最大/最小的k个元素 最大k个：小顶堆；最小k个：大顶堆 小顶堆： #include &lt;vector> #include &lt;queue> using namespace std; void TopK(int *num, int size) &#123; priority_queue&lt;int, vector&lt;int>, greater&lt;int>> q; // 大顶堆用less for(int i=0;i&lt;size;i++) &#123; if(q.size()>=10) &#123; if(q.top()&lt;num[i]) &#123; q.pop(); q.push(num[i]); &#125; &#125; else &#123; q.push(num[i]); &#125; &#125; for(int i = 0; i &lt; 10;i++) &#123; num[size-i-1] = q.top(); q.pop(); &#125; &#125; Unity Unity的脚本生命周期 参考事件函数的执行顺序 - Unity 手册，抽取了比较重要的部分 加载第一个场景时 场景开始时调用以下函数，为场景中的每个对象调用一次： Awake：始终在Start函数前并在实例化后调用此函数(每次激活也会调用) OnEnable：在启用对象后立即调用此函数，创建示例时也会执行调用(仅在对象处于激活状态时调用) Editor 不在游戏过程中，在编辑器下 Reset：使用Reset命令可以初始化脚本的属性(即将脚本附加到对象时，设定属性参数) 在第一次帧更新之前 Start：仅当启用脚本示例后，才会在第一次帧更新之前调用Start 帧之间 OnApplicationPause：允许发出一个额外帧来显示图形指示暂停状态 更新顺序 FixedUpdate：进行所有物理计算和更新，应用物理无需乘以Time.deltaTime，因为其调用基于可靠的计时器，独立于帧率 Update：没帧调用一次Update。用于帧更新的主要函数 LateUpdate：在Update完成后执行，一般用于摄像机的移动和旋转计算，确保角色在摄像机跟踪位置前已完全移动 销毁对象时 OnDestroy：对象存在的最后一帧完成所有帧更新之后，调用此函数 渲染管线 应用阶段 准备好场景数据，粗粒度剔除(culling)，将数据加载到显存 渲染图元，设置好每个模型的渲染状态 调用DrawCall 几何阶段 顶点着色器：坐标变换，逐顶点光照(输出顶点颜色) 裁剪：根据相机的角度以及配置(如裁剪图元的正面或背面)进行裁剪 屏幕映射：不可编程，将每个图元的xy坐标转换到屏幕座标系 光栅化阶段 三角形设置：计算三角网格表示数据的过程 三角形遍历：检查像素是否被一个三角网格所覆盖，如果被覆盖就生成一个片元(并不是真正意义上的像素，而是多种状态的集合，这些状态用于计算每个像素的最终颜色) 片元着色器：输入为对顶点着色器输出数据的插值得到的结果，输出为一个或多个的颜色值。 逐片元操作：解决片元的可见性，通过所有测试才写入颜色缓冲区。 UI合批 UGUI中Canvas可以嵌套子Canvas，合批是以Canvas为单位的。 合批的基本条件是两个控件使用的材质球(shader)和贴图要完全相同。 方法：使用图集(Editor-&gt;Project Setting-&gt;Editor下Sprite Packer选择Always Enable，右键Create-&gt;Sprite Atlas创建图集) 合批 要求相同的材质 静态合批 静态合批是将静态(不移动)GameObjects组合成大网格，然后进行绘制，静态合批需要额外的内存来存储合并的几何体。 动态合批 动态合批是将一些足够小的网格，在CPU上转换它们的顶点，将许多顶点组合在一起并一次性绘制。 动态合批有节点数的限制(不超过900个顶点和不超过300个顶点的网格)。 不同材质的阴影会动态合批，只要绘制阴影的pass是相同的，因为阴影和其他贴图等数据无关。 GPU Instancing（更深入的话） GPU Instancing可以使用一个DrawCall渲染多个相同网格的物体，不过也有一些其他的约束： SRP下使用可以GPU instance可以用Graphics.DrawMeshInstanced SkinnedMeshRenderers不支持GPU Instancing 图形学 三维空间变换（MVP） 待补充 Model Transform 控制物体的位置，旋转，缩放 View Transform 照相机的状态 Projection Transform 投影矩阵，一般的有正交投影和透视投影 设计模式（现在经常不考） 面向对象设计原则 单一职责原则 一个类只负责一个功能领域中的相应职责。或者说，一个类，最好只做一件事，只有一个引起它变化的原因。 开闭原则 一个软件实体应当对拓展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行拓展。 里氏替换原则 所有引用基类（父类）的地方必须能透明的使用其子类的对象，并且保证原来程序的逻辑行为不变以及正确性不被破坏。 里氏替换原则是实现开闭原则的重要方式之一。将父类设计为抽象类或接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时子类示例替换父类示例，可以很方便扩展系统的功能，无须修改原有子类的代码，增加新的功能可以通过增加新的子类来实现。 依赖倒置原则 抽象不应该依赖于细节，细节应当依赖于抽象。换句话说，要针对接口编程，而不是针对实现编程。 接口隔离原则 使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些他不需要的接口。 合成复用原则 尽量使用对象组合，而不是继承来达到复用的目的。 迪米特法则 一个软件实体应当尽可能少地与其他实体发生相互作用。 工厂模式 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。这满足创建型模式中所要求的“创建与使用相分离”的特点。 例：技能作为一系列类，可以使用工厂模式创建 观察者模式 观察者模式定义了对象间的一对多关系，当一个对象状态发生变化，所有依赖于它的对象都将得到通知并自动更新。 发布-订阅者模式 是一种消息范式，消息的发送者(发布者)不会将消息直接发送给特定的接收者(订阅者)，而是将消息分为不同的类别，无需了解哪些订阅者可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在。 单例模式 在C#应用中，单例对象能保证在一个CLR中，该对象只有一个实例存在。而且自行实例化并向整个系统提供这个实例，避免频繁创建对象，节约内存。 public class Singleton &#123; private static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance() &#123; if(instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 饿汉模式 在类加载的时候立刻实例化，后续使用只出现一份实例 懒汉模式 在调用实例方法的时候再进行实例化，在不想使用时不会实例化 饱汉模式 直接new出来 代理模式 一个是真正的你要访问的对象，一个是代理对象，真正对象与代理对象实现同一个接口，先访问代理类再访问真正要访问的对象。 多用于代理text，button等组件，以及委托 命令模式 一种以数据驱动的设计模式，属于行为型模式。请求以命令的形式包裹在对象中并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把命令传给相应的对象，该对象执行命令。 命令模式将“请求”封装成对象，以便使用不同的请求，队列或日志来参数化其他对象，同时支持可撤销的操作。","categories":[{"name":"Unity","slug":"Unity","permalink":"https://yzs020220.github.io/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://yzs020220.github.io/tags/Unity/"},{"name":"学","slug":"学","permalink":"https://yzs020220.github.io/tags/%E5%AD%A6/"},{"name":"自用","slug":"自用","permalink":"https://yzs020220.github.io/tags/%E8%87%AA%E7%94%A8/"}]},{"title":"Unity数据持久化-json","slug":"Unity数据持久化-json","date":"2023-05-22T14:47:52.000Z","updated":"2023-05-22T15:39:02.992Z","comments":true,"path":"posts/30759/","link":"","permalink":"https://yzs020220.github.io/posts/30759/","excerpt":"谈谈关于如何在Unity中将数据转为json文件来进行存储与读取，使用的都是JsonUtility中的方法，非常的便捷","text":"谈谈关于如何在Unity中将数据转为json文件来进行存储与读取，使用的都是JsonUtility中的方法，非常的便捷 新建SaveSystem类 新建一个SaveSystem类来方便方法的调用 using System; using System.IO; using UnityEngine; public class SaveSystem : MonoBehaviour &#123; &#125; 数据写入json文件并存储 在SaveSystem类下写存储方法，简单来说，先通过ToJson方法将数据转换为json格式的文本，在将文本写入到文件中。其中perisistentDataPath是一个根据不同平台对应的不同路径(例如windows和android的路径并不相同) /// &lt;summary> /// 将数据存入json文件 /// &lt;/summary> /// &lt;param name=\"fileName\">文件名及路径&lt;/param> /// &lt;param name=\"data\">数据&lt;/param> public static void SaveToJson(string fileName, object data) &#123; var json = JsonUtility.ToJson(data); var path = Path.Combine(Application.persistentDataPath, fileName) + \".json\"; try &#123; File.WriteAllText(path, json); #if UNITY_EDITOR Debug.Log($\"success to save data to &#123;path&#125;\"); #endif &#125; catch (SystemException) &#123; #if UNITY_EDITOR Debug.Log($\"fail to save data to &#123;path&#125;\"); #endif &#125; &#125; 方法的调用示例 假设我们要存出一个Student类（需要注意只有能够序列化的数据类型能够被存储，类型不受支持的字段以及私有(private)字段或使用 NonSerialized 属性标记的字段会被忽略） public class Student &#123; public string name; public int id; &#125; 调用上面的方法将其转换为json文件并进行存储 var student = new Student(); student.name = \"Mike\"; student.id = 12; SaveSystem.SaveToJson(\"student01\", student); 这样就可以进行存储了，windows下的json文件路径为C:\\User\\UserName(你自己的用户名)\\AppData\\LocalLow\\DefaultCompany\\project(项目名称)\\ 数据读取与实例化(一般的) 读取文件其实也非常简单，只需要使用FromJson方法将json文本转换为对应类型的object就可以了 /// &lt;summary> /// 将数据通过json文件读取 /// &lt;/summary> /// &lt;param name=\"fileName\">文件名及路径&lt;/param> /// &lt;typeparam name=\"T\">读取数据类型&lt;/typeparam> /// &lt;returns>&lt;/returns> public static T LoadFromJson&lt;T>(string fileName) &#123; var path = Path.Combine(Application.persistentDataPath, fileName) + \".json\"; try &#123; var json = File.ReadAllText(path); var data = JsonUtility.FromJson&lt;T>(json); #if UNITY_EDITOR Debug.Log($\"success to load data from &#123;path&#125;\"); #endif return data; &#125; catch (SystemException) &#123; #if UNITY_EDITOR Debug.Log($\"fail to load data from &#123;path&#125;\"); #endif return default; &#125; &#125; 需要注意的是，FromJson方法只支持普通类和结构；不支持派生自 UnityEngine.Object 的类（如 MonoBehaviour 或 ScriptableObject）。具体请查看官方文档中的JsonUtility-FromJson - Unity 脚本 API 方法的调用，还是以Student类举例 var student = SaveSystem.LoadFromJson&lt;Student>(\"student01\") 点击查看SaveSystem类的完整代码 using System; using System.IO; using UnityEngine; public class SaveSystem : MonoBehaviour &#123; /// &lt;summary> /// 将数据存入json文件 /// &lt;/summary> /// &lt;param name=\"fileName\">文件名及路径&lt;/param> /// &lt;param name=\"data\">数据&lt;/param> public static void SaveToJson(string fileName, object data) &#123; var json = JsonUtility.ToJson(data); var path = Path.Combine(Application.persistentDataPath, fileName) + \".json\"; try &#123; File.WriteAllText(path, json); #if UNITY_EDITOR Debug.Log($\"success to save data to &#123;path&#125;\"); #endif &#125; catch (SystemException) &#123; #if UNITY_EDITOR Debug.Log($\"fail to save data to &#123;path&#125;\"); #endif &#125; &#125; /// &lt;summary> /// 将数据通过json文件读取 /// &lt;/summary> /// &lt;param name=\"fileName\">文件名及路径&lt;/param> /// &lt;typeparam name=\"T\">读取数据类型&lt;/typeparam> /// &lt;returns>&lt;/returns> public static T LoadFromJson&lt;T>(string fileName) &#123; var path = Path.Combine(Application.persistentDataPath, fileName) + \".json\"; try &#123; var json = File.ReadAllText(path); var data = JsonUtility.FromJson&lt;T>(json); #if UNITY_EDITOR Debug.Log($\"success to load data from &#123;path&#125;\"); #endif return data; &#125; catch (SystemException) &#123; #if UNITY_EDITOR Debug.Log($\"fail to load data from &#123;path&#125;\"); #endif return default; &#125; &#125; &#125; ScriptableObject类的读取 由于ScriptableObject可以很方便地在Unity中进行编辑，并且作为仅存储数据的用途非常的轻量化，所以也特别地讲一下 假设我们有一个Teacher类继承了ScriptableObject [Serializable][CreateAssetMenu(menuName = \"Teacher\")] public class Teacher : ScriptableObject &#123; public string name; public int id; &#125; 我们在代码中创建了实例并且对其进行了存储 var teacher = ScriptableObject.CreateInstance&lt;Teacher>(); teacher.name = \"Ben\"; teacher.id = 0; SaveSystem.SaveToJson(\"teacher01\", teacher); 接下来我们需要读取数据，首先需要在Teacher类下实现LoadFromDisk方法，与SaveSystem中的LoadFromJson方法不同的点在于，我们需要使用的方法不是FromJson而是FromJsonOverwrite public bool LoadFromDisk(string fileName) &#123; var path = Path.Combine(Application.persistentDataPath, fileName) + \".json\"; try &#123; var json = File.ReadAllText(path); JsonUtility.FromJsonOverwrite(json, this); #if UNITY_EDITOR Debug.Log($\"success to load data from &#123;path&#125;\"); #endif return true; &#125; catch (SystemException) &#123; #if UNITY_EDITOR Debug.Log($\"fail to load data from &#123;path&#125;\"); #endif return false; &#125; &#125; 然后再创建示例并调用该方法，即可读取数据 var teacher = ScriptableObject.CreateInstance&lt;Teacher>(); teacher.LoadFromDisk(\"teacher01\");","categories":[{"name":"Unity","slug":"Unity","permalink":"https://yzs020220.github.io/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://yzs020220.github.io/tags/Unity/"}]},{"title":"第一次看汪峰演唱会","slug":"第一次看汪峰演唱会","date":"2023-05-16T02:31:37.000Z","updated":"2023-05-19T03:21:02.969Z","comments":true,"path":"posts/4516/","link":"","permalink":"https://yzs020220.github.io/posts/4516/","excerpt":"在5月13号的晚上去看了汪峰老师的演唱会，真的太赞了","text":"在5月13号的晚上去看了汪峰老师的演唱会，真的太赞了 我怎么喜欢上汪峰 在我小学的时候，那个时候流行着脍炙人口的《飞得更高》，《勇敢的心》，《春天里》，记得当时看中国好声音最喜欢的就是那一首《存在》。小的时候，只是很喜欢这样的旋律，觉得听了汪峰老师的歌，人就受到了激励，那个时候网络也没有那么流行，上网只是为了打游戏，周一到周五都是好好学习，天天向上。小时候去KTV，就很喜欢唱汪峰的歌，低音不多，对小孩子而言唱这些歌反而很轻松。 到了中学的时候，我就不再主听华语歌曲了。初中的时候，大家听欧美歌曲居多，也会相互分享，也曾和几个朋友站到舞台上去唱歌。从唱的角度上讲，汪峰的歌曲在我变声期的时候是一点都唱不了了。当然在那个时期，电子乐，舞曲等更带感的音乐也确实更吸引那个时候的我。 等到了大学，在疫情放开后的一天，突然刷到一个视频，谈到汪峰，我才发现我已经很久没有听过汪峰老师的歌了，或者说我没有静下心来慢慢听听，它们只是躺在我的歌单里，被随机播放突然地捡起。可能也是网易云没有版权的原因，所以我甚至不知道汪峰老师出了新专辑的信息（总是上不去微博热搜，笑）。 那个时候听《也许我可以无视死亡》这张专辑，确实没有想到他在五十岁的年纪，还能带来这么震撼人心的作品，这张专辑我认为绝对是汪峰最近的一次巅峰了，虽然《2020》这张专辑也是非常的优秀，但是《也许我可以无视死亡》更加的成熟，没有那么的实验性，所以听感上也更加舒服。 也是到这个时候，我对于汪峰的歌曲才有了小时候没有的理解，汪峰的词，绝大部分都不是简单的正能量，而小时候的我确实是理解不了的，随着年岁的增长，加上中学时期的大量阅读量，这个时候我才大概对于汪峰的歌曲有了真正的共鸣。也是这样，我才真正成为了汪峰的粉丝。 深圳春茧体育场的演唱会 在去的路上，我还一直以为没什么人，毕竟是第一次去演唱会，直到走到天桥，才明白这浩浩荡荡的人流有着同一个目的地。进场不能带水，这个确实是不知道，走进去才知道有发雨衣，跟舍友坐下（可恶，因为社恐不敢一个人去演唱会，就请了一个人陪我去听），大概等了20分钟吧，差不多7：40左右开场，在一串炫目的灯光秀之后，音乐的盛宴就开始了。 说实话，第一首《像梦一样自由》演唱会前没怎么听过，但是很好听，回来一直放，不过还是演唱会的感觉更舒服，汪峰老师也就抱着吉他在缓缓升起的高台上登场了。 像梦一样自由 接着估计从设计上也是为了热场，从最新的两张专辑中选了《二手灵魂》，《如刀》和《坏掉》，现场加上那个绚丽的大屏幕，真的非常的带感，看着乐队的吉他手，鼓手那忘我的表演，我会觉得这种感觉是真的摇滚的感觉，能看得出来舞台上的人非常的享受，我也很享受这三首都是我非常喜欢的歌曲，《二手灵魂》吐槽了追逐潮流的人们背后是空洞的灵魂（很符合UnFollow这个演唱会主题），《坏掉》更像表达一种对社会的破败的放任自流的态度。 大概在中间那一段，有好几首比较经典的歌曲，在雨中的《在雨中》，一响起所有人都能唱的《飞得更高》，《勇敢的心》，也有舒缓的新歌《飞鸟》（这首也是我非常喜欢的歌曲）。 我印象比较深刻的应该是汪峰老师真的唱了《每个人都在失去》，也许，当疫情瞬间放开，有很多人听到这首歌响起，也会深有感触吧。也有那一首《你是我心爱的姑娘》，大家打着手电筒，摇晃着手臂，也看到汪峰老师拿起小提琴为大家演奏一段优美的弦乐。 每个人都在失去青春 在演出接近尾声的时候，汪峰还是唱起了那几首最脍炙人口的歌曲。一首《一起摇摆》响起，就再也没有坐下来过，这也是整场演唱会最嗨的时候了。全场合唱《我爱你中国》应该是最为震撼的了，“希望你能够知道你对我的意义，无论在何时何地你就像我的生命”，也许在这个肆力宣传着国家保护个体的时代，我也有点忘记了中国二字对于我心中的意义了，即使我们是再渺小的个体，也有能放光发热的地方。在深圳唱《北京北京》是一个有点尴尬的地方，虽然汪峰也会为了在深圳开演唱会而唱“深圳，深圳”，但还是有点没内味。《春天里》大概不是我这个年纪能够很理解的，但是旁边的那位大哥唱的涕泗横流，我也能够大概感受到在深圳奉献了自己的青春之后，对过去的追忆，对未来的寄望。在演出的最后，汪峰还是唱起了那首《光明》，汪峰老师的状态确实不错，虽然截掉了中间一段，但是在最难唱的“呼喊”那里在已经唱满了两小时之后还是高水准地发挥了出来。在放纵了情感后，人们终究要回到生活的节奏上，去相信光明就在远方，让生活继续下去。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://yzs020220.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://yzs020220.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"看了看老番《只有我不在的街道》","slug":"看了看老番-只有我不在的街道","date":"2023-05-07T02:56:22.000Z","updated":"2023-05-07T04:44:17.875Z","comments":true,"path":"posts/9271/","link":"","permalink":"https://yzs020220.github.io/posts/9271/","excerpt":"大概是在最近这几年没有那么完整地一口气看完一部动漫，这一部动漫我也有所耳闻，但听名字本来还以为又是青春疼痛文学，在没有什么番想看的情况下随手点进去看看怎么样，结果一口气看完了","text":"大概是在最近这几年没有那么完整地一口气看完一部动漫，这一部动漫我也有所耳闻，但听名字本来还以为又是青春疼痛文学，在没有什么番想看的情况下随手点进去看看怎么样，结果一口气看完了 谈谈番的定位 首先是毫无疑问的剧情向作品，作为一部主打悬疑的作品，在双线并行的手法下并不会让观众觉得剧情混乱，不经推敲，当然悬疑作品能不能真的让人出乎意料那对现在有大量悬疑作品阅历的我来说已经是很少能给我耳目一新的感觉，但是能够把观众一集一集地抓进去无疑在叙事节奏上是成功的。其次，比起许多悬疑作品里人物干巴巴的性格，《只有我不在的街道》不管是主角还是其伙伴，还是他的母亲都是特点鲜明的角色。相比于现代社会一众快餐动漫来说，只有我不在的街道值得慢慢品味。 聊聊感受 虽然上面已经是在谈感受了，不过上面更多的是讲动漫的亮点吧。也许是我最近的经历和男主的成长历程在某些地方上有了雷同，长久以来男主一直觉得没能保护身边的人而自责，到他成长到跟伙伴一起商量，而不是单靠自己绞尽脑汁来完成事情，这种经历跟我最近在吉比特比赛的小组内做游戏开发也比较像吧。 在这之前，我大概也是一个人闭门造车，但是一个人能做的事毕竟是有限的，”把所有事情与过错都揽到自己身上，是一种自大“，现在的项目已经做到了仅凭我一个人完全做不到的地方，就像主角只依靠自己绝对达不到的结局。而合作之间，在真的熟识以前，真的会有所怀疑，我特别喜欢那一句：”说‘我相信‘本身不就代表了有所怀疑吗，因为真的在内心里完全相信是不用说出这句话的，但我觉得这表达的更是我希望去相信你“。也许解释起来会有点绕，但是人就是生性多疑的生物，人连自己都怀疑更何况其他人呢，但是我相信，表达的是一种希望，表达的是我希望去相信你，所以只管放手做吧，这个相信的对象是自己也好，他人也好，这才是相信作为言语的意义。 关于结局，虽然我觉得对于二次元磕cp的会觉得有点不好接受吧，但是这样的处理，更加反映人物的成长，更加现实，在结尾的收尾也给人一种将整个圆画完整的感觉。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://yzs020220.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://yzs020220.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"2.5D视错觉小游戏","slug":"2-5D视错觉小游戏","date":"2023-03-23T01:07:49.000Z","updated":"2023-03-23T04:21:29.704Z","comments":true,"path":"posts/36275/","link":"","permalink":"https://yzs020220.github.io/posts/36275/","excerpt":"分享一下我做的一个Unity小demo，玩法大致类似于纪念碑谷(Monument Valley)","text":"分享一下我做的一个Unity小demo，玩法大致类似于纪念碑谷(Monument Valley) 项目地址 yzs020220/MonumentValley-like-demo 玩法实现 玩法的实现主要参考了油管博主MixAndJam的视频：视频地址，输入使用了Unity Input System来实现相机旋转 监听鼠标点击与位置 鼠标左键点击 新建Action命名为Move，Action Type选择为Button，Action下新建binding，Path选择为Left Button[Mouse] 在角色控制脚本中编写OnMove方法 public void OnMove(InputAction.CallbackContext context) &#123; if (context.started) &#123; // 角色移动 &#125; &#125; 鼠标位置 在Unity Input System中新建Action，Action Type选择Value，Control Type选择Vector 2，Action下新建Binding，Path选择为Position[Mouse] 获取鼠标位置 在角色控制脚本中编写OnGetScreenPositon方法 private Vector2 _clickScreenPos; public void OnGetScreenPosition(InputAction.CallbackContext context) &#123; _clickScreenPos = context.ReadValue&lt;Vector2>(); &#125; 在PlayerInput中将其调用 新建empty，添加Player Input, Behavior选择Invoke Unity Event, 在PlayerInput中调用方法 在PlayerInput中调用方法 射线检测方块 检测自身所站的方块 在自身位置向下射出一个射线检测碰撞体，如果碰撞体带有方块的脚本，那么返回方块 void RayCastDown() &#123; Ray playerRay = new Ray(transform.GetChild(0).position, -transform.up); RaycastHit playerHit; if (Physics.Raycast(playerRay, out playerHit)) &#123; if (playerHit.transform.GetComponent&lt;Walkable>() != null) &#123; curCube = playerHit.transform; &#125; &#125; &#125; 检测鼠标点击的方块 在OnMove方法下检测(左键点击目标方块)，射线检测跟上面基本相似 public void OnMove(InputAction.CallbackContext context) &#123; if (context.started) &#123; RayCastDown(); Ray mouseRay = Camera.main.ScreenPointToRay(_clickScreenPos); RaycastHit mouseHit; if (Physics.Raycast(mouseRay, out mouseHit)) &#123; if (mouseHit.transform.GetComponent&lt;Walkable>() != null) &#123; clickedCube = mouseHit.transform; &#125; &#125; &#125; &#125; 移动到方块 这一部分出了如何形成图的方法和MixAndJam的视频不同，其他基本是一样的 图的形成 方块是相互独立的，我们可以通过获取它们在屏幕上的位置，比较两个方块之间的距离将它们连接起来，给方块脚本Walkable.cs设置possiblePaths变量 public List&lt;WalkPath> possiblePaths = new List&lt;WalkPath>(); 在EnvironmentUpdate.cs中，添加PathUpdate方法通过方块的屏幕位置将方块相互连接 public Walkable[] platform; public Walkable cube0, cube1; // 传入两个相邻的方块以获得它们之间的屏幕坐标(二维向量)距离 public void PathUpdate() &#123; Vector2 cubeSp0 = cube0.GetScreenPoint(); Vector2 cubeSp1 = cube1.GetScreenPoint(); float _dist = (cubeSp0 - cubeSp1).magnitude; for (int i = 0; i &lt; platform.Length - 1; i++) &#123; for (int j = i + 1; j &lt; platform.Length; j++) &#123; platform[i].GetScreenPoint(); platform[j].GetScreenPoint(); Vector2 iScreenPos = new Vector2(platform[i].screenPoint.x, platform[i].screenPoint.y); Vector2 jScreenPos = new Vector2(platform[j].screenPoint.x, platform[j].screenPoint.y); _platformDist = (iScreenPos - jScreenPos).magnitude; if (Mathf.Abs(_platformDist - _dist) &lt; .5f) &#123; WalkPath walkPath0 = new WalkPath(); WalkPath walkPath1 = new WalkPath(); walkPath0.target = platform[i].transform; walkPath1.target = platform[j].transform; walkPath0.active = true; walkPath1.active = true; platform[i].possiblePaths.Add(walkPath1); platform[j].possiblePaths.Add(walkPath0); &#125; &#125; &#125; &#125; 根据图以及自身所在方块和点击方块生成路径 基本上是按照视频来的，但是我当时写的时候没想太多，其实应该直接用BFS会更好解释(以后有空再改吧，先贴上代码) 点击展开代码 void FindPath() &#123; List&lt;Transform> nextCubes = new List&lt;Transform>(); List&lt;Transform> pastCubes = new List&lt;Transform>(); foreach (WalkPath path in curCube.GetComponent&lt;Walkable>().possiblePaths) &#123; if (path.active) &#123; nextCubes.Add(path.target); path.target.GetComponent&lt;Walkable>().previousBlock = curCube; &#125; &#125; pastCubes.Add(curCube); ExploreCube(nextCubes, pastCubes); BuildPath(); &#125; void ExploreCube(List&lt;Transform> nextCubes, List&lt;Transform> visitedCubes) &#123; Transform current = nextCubes.First(); nextCubes.Remove(current); if(current == clickedCube) return; foreach (WalkPath path in current.GetComponent&lt;Walkable>().possiblePaths) &#123; if (!visitedCubes.Contains(path.target) &amp;&amp; path.active) &#123; nextCubes.Add(path.target); path.target.GetComponent&lt;Walkable>().previousBlock = current; &#125; &#125; visitedCubes.Add(current); if (nextCubes.Any()) &#123; ExploreCube(nextCubes, visitedCubes); &#125; &#125; void BuildPath() &#123; Transform cube = clickedCube; while (cube != curCube) &#123; finalPath.Add(cube); if (cube.GetComponent&lt;Walkable>().previousBlock != null) cube = cube.GetComponent&lt;Walkable>().previousBlock; else return; &#125; finalPath.Insert(0, clickedCube); FollowPath(); &#125; 移动到方块 用DoTween移动就行(在PackageManager下安装) void FollowPath() &#123; Sequence s = DOTween.Sequence(); walking = true; for (int i = finalPath.Count - 1; i > 0; i--) &#123; s.Append(transform.DOMove(finalPath[i].GetComponent&lt;Walkable>().GetWalkPoint() + characterOffset, .2f).SetEase(Ease .Linear)); &#125; s.Append(transform.DOMove(clickedCube.GetComponent&lt;Walkable>().GetWalkPoint() + characterOffset, .2f).SetEase(Ease.Linear)); s.AppendCallback(() => Clear()); &#125; 最后在OnMove方法中调用寻找路径方法即可： public void OnMove(InputAction.CallbackContext context) &#123; if (context.started) &#123; RayCastDown(); Ray mouseRay = Camera.main.ScreenPointToRay(_clickScreenPos); RaycastHit mouseHit; if (Physics.Raycast(mouseRay, out mouseHit)) &#123; if (mouseHit.transform.GetComponent&lt;Walkable>() != null) &#123; clickedCube = mouseHit.transform; DOTween.Kill(gameObject.transform); finalPath.Clear(); FindPath(); &#125; &#125; &#125; &#125; 相机旋转 功能在我的另一篇博客都有实现，只要在相机旋转完成时再次调用路径更新方法即可 初识Unity Input System 视觉效果完善 上面的功能做完之后，你会发现角色从原来方块走到世界座标系中不是相互连接的方块会出现方块与角色相互遮挡，这是因为当角色的路径穿过方块，就会出现所谓的穿模，然而这里我们要实现的就是路径穿过方块所以其实没有办法避免，使用视错觉显得方块是相邻的本身就是一个谎言，那就得有另一个谎言来把这个谎圆起来。 简单来说，其实我们只要让角色显示在脚下的方块前就可以了，因为角色总是踩在方块上面，所以我们只要让角色都显示出来就好了，最简单的实现方法就是使用两个相机，新建一个新的相机，RenderType选择Overlay，Culling Mask选择Player(角色要设置为这个Layer)，然后在原相机上的stack中添加该相机，并在原相机的Culling Mask中取消选择Player，这样我们就是实现了这个视觉效果 新建相机原相机 如果你想为它添加阴影，你可以将角色复制一份然后设置为其他图层，Cast Shadow选择为Shadow Only(只投射阴影) 我这里是很偷懒地给角色这个方块为了一圈剔除背面的Plane(如果你要控制方块总是显示那一个平面也可以用这个方法)","categories":[{"name":"Unity","slug":"Unity","permalink":"https://yzs020220.github.io/categories/Unity/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://yzs020220.github.io/tags/C/"},{"name":"Unity","slug":"Unity","permalink":"https://yzs020220.github.io/tags/Unity/"}]},{"title":"C#格式字符串","slug":"C-格式化字符串","date":"2023-03-18T01:10:11.000Z","updated":"2023-03-18T02:15:43.918Z","comments":true,"path":"posts/7149/","link":"","permalink":"https://yzs020220.github.io/posts/7149/","excerpt":"其实没有专门学过C#，在网上看代码学习时其实还有很多可能会困惑的地方，所以就一边看《C#图解教程》，一边记录一些觉得需要记录的地方","text":"其实没有专门学过C#，在网上看代码学习时其实还有很多可能会困惑的地方，所以就一边看《C#图解教程》，一边记录一些觉得需要记录的地方 格式字符串 我还记得以前写kotlin的时候，格式字符串是一个非常好用的东西，比C++的转格式然后再+不仅方便而且可读性也很强。C#作为高级语言(比C++更高级)，在这方面也做了改进。 旧的格式 在字符串中使用替换标记&#123;index&#125;在格式字符串中标出位置，后面跟着的参数为替换值，替换值从0开始编号，替换标记的index就是替换值的编号。 下方给出的示例，3为替换值0，6为替换值1: 代码输出Console.WriteLine(\"Two sample integers are &#123;0&#125; and &#123;1&#125;.\", 3, 6);Two sample integers are 3 and 6. 新的格式 在C# 6.0版本中引入了一种代码可读性更强的方式表述参数化字符串的语法，称为字符串插值，通过在替换标记内插入变量名实现。实际上，替换标记告诉编译器这个变量将被视为一个变量，而不是字符串字面量——前提是在字符串前面加上了$符号 代码输出int var1 = 3; int var2 = 6; Console.WriteLine($\"Two sample integers are &#123;var1&#125; and &#123;var2&#125;\");Two sample integers are 3 and 6. 在Unity中也是一样可以使用的，例如打印日志将Console.WriteLine替换为Debug.Log即可 多重标记和值 就是能够使用任意数量的替换标记和值 值可以以任何顺序使用 值可以在格式字符串中替换任意次 旧的格式新的格式输出Console.WriteLine(\"Three sample integers are &#123;1&#125;, &#123;0&#125; and &#123;1&#125;\", 3, 6);int var1 = 3; int var2 = 6; Console.WriteLine($\"Three sample integers are &#123;var2&#125;, &#123;var1&#125; and &#123;var2&#125;\");Three sample integers are 6, 3 and 6. 格式化数字字符串 因为我不常用所以不会展开讲 index指定哪一项变量(同上文写法)，alignment指定字段宽度以及是否右对齐或左对齐(可选)，format指定项的格式(可选)，格式如下： {index, alignment: format} 左右对齐 正数为右对齐，负数为左对齐，整数表示字段使用字符的最少数量。 简单来说，整数代表的是当字符串长度不够长时，如右对齐情况，会在左边添加空格直到空格+字符串的长度达到整数(即字段使用字符的最少数量)。 例如，右对齐参数为10，替换值为500，那就要在前面补7个空格(左对齐就在后面补)： 代码输出int var1 = 500; int var2 = 10; Console.WriteLine($\"|&#123;var1, 10&#125;|\"); Console.WriteLine($\"|&#123;var2, 10&#125;|\");| 500| | 10| format 比较冗长，关于format的参数可以查看微软的官方文档","categories":[{"name":"C#","slug":"C","permalink":"https://yzs020220.github.io/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://yzs020220.github.io/tags/C/"}]},{"title":"初识Unity Input System","slug":"初识Unity-Input-System","date":"2023-03-13T06:44:36.000Z","updated":"2023-03-23T02:36:10.194Z","comments":true,"path":"posts/54306/","link":"","permalink":"https://yzs020220.github.io/posts/54306/","excerpt":"在一次想做鼠标拖拽摄像机旋转的时候，了解到Unity Input System，就大致介绍一下Unity Input System的基本使用以及如何实现一个简单的右键拖拽控制相机旋转","text":"在一次想做鼠标拖拽摄像机旋转的时候，了解到Unity Input System，就大致介绍一下Unity Input System的基本使用以及如何实现一个简单的右键拖拽控制相机旋转 官方文档 Quick start guide | Input System | 1.3.0 (unity.cn) 为什么用Input System 不同于主机平台，游戏在PC平台上可能需要同时处理不同设备的输出，同时一个游戏也可能会迁移到移动端，为多个平台做映射是一件非常令人头疼的事情。Input System将多个设备或UI上的操作都映射到了一个行为(Action)上，通过这种方法就可以使得多个设备之间的操作不会产生冲突，同时Input System还提供了很多内部实现(比如监听鼠标的移动，手柄操纵杆返回二维向量等)，一定程度上简化了需要写的代码。 Input System还有一套Player的移动系统以及UI的系统，需要在Scene的GameObject中新建一个Player Input，然后Create Action就可以快速创建默认的InputActions。 什么时候不用Input System 如果只是需要做一个普通的原型或者不考虑多平台，可能就还是直接写代码会比较方便。 如果需要在移动方式等有所创新，那么原本Unity的那套输入系统能够让你更快更自由地实现你的想法。 如果游戏有较多UI需要交互的时候可以不用Input System，虽然Input System是支持UI的，但是UI本身的控件等方法Unity都已经写好了，还使用Input System反而会使得写起来有点麻烦。 除开以上场景外，它还有诸多限制，具体请自己查看官方文档：Known Limitations | Input System | 1.3.0 (unity.cn) 使用Input System 打开Package Manager，在Unity Registry分类下找到Input System导入，它会替换你当前使用的输入系统。 新建Player Input与Input Actions 在场景中创建空物体，并添加脚本Player Input，如果要创建默认Input Actions(默认包含上下左右移动以及视角移动开火等方法，以及UI的监听事件)，如果要创建自己的，也可以直接右键Create-&gt;Input Actions PlayerInput窗口 窗口属性说明 为了大致地说明窗口的各个位置分别用来做什么，此处就用默认的Input Actions来说明 Input Actions窗口 Actions 如果你没有多设备，也没有多个Action Maps，那么只看Actions和Bindings就够了。 Action的使用方法 Action的创建在该栏的右上角的加号，一般地对于一个Action，在名字前加上On就是它的调用方法，例如名字为Move，它在脚本中的调用方法为(其实起名可以不这样起，但是传入的参数都是context) public void OnMove(InputAction.CallbackContext context) &#123; // 根据Action Type的不同，context的属性也会 Vector2 dir = context.ReadValue&lt;Vector2>(); &#125; 当你在这个窗口选择其中一个Action时，右边的窗口就会出现Action Properties Action Properties属性说明 Action Type有三个选项 Value: 一个值 代码用法(以二维向量为例) Vector2 vec2 = context.ReadValue&lt;Vector2>(); Button: 一个按钮，按下一次按钮方法会被调用三次并更改三个bool值属性 public void OnTouch(InputAction.CallbackContext context) &#123; bool started = context.started; // 按钮开始被按下 bool performed = context.performed; // 按钮正在被按下 bool canceled = context.canceled; // 按钮被释放 &#125; Pass Through: 跟Value相似，但是同时接受多个设备的输入 Interactions: 控制按钮按下释放的检测时间，摇杆死区等，一般不修改都使用默认值 Processors: 对于输入的处理，比如归一化方向的输入 Binding 在Action下创建或选择Binding可以看到右边出现Binding Properties，点击Path后点击Listen可以绑定到你输入的键位或搜索具体的键位进行绑定。 在下方的Use in Control Scheme可以选择当前绑定使用在哪个控制方案下(如果有更多控制方案)。 在Actions下的binding中勾选对应的Control Scheme Control Schemes Control Schemes(控制方案)位于窗口的左上角，打开下拉菜单，在这里你可以选择或新建设备的控制方案，并在之后的binding(绑定)中勾选对应的控制方案(例如左操纵杆就只勾选Gamepad)，当使用该设备时，Actions将自动选择对应的binding Action Maps 在最左边的是Action Maps，这里存放的是输入与操作对应的映射图，主要用在例如角色开启菜单就可以将原本控制角色的输入设备用于UI的点击，这时就需要转换映射关系，例如我们这里将映射从Player转换到UI，代码如下： public PlayerInput playerInput; playerInput.SwitchCurrentActionMap(\"UI\"); 在场景中调用方法 在场景中的PlayerInput选择使用的Actions，Behavior选择Invoke Unity Events，在Events下我们可以找到我们创建的映射图(Action Map)，展开后就能看到我们的各个Action了，在对应的Action中选择当前控制的对象以及对象上要相应的方法(先选择控制的对象，再选择对象脚本内的方法)。例如： 这里展示的是鼠标控制相机旋转以及角色旋转的Action 相机旋转的实现 这里说的还是有点混乱，这里就来说一下如何实现鼠标旋转相机的效果，这里附上我看的教程地址：油管教程 鼠标偏移量的获取 新建Action命名为Look，Action Type为Value(或Pass Through)，Control Type为Vector2，Action下新建binding，Path选择为Delta[Mouse] 在相机控制脚本中编写OnLook方法 private Vector2 _delta; // 鼠标偏移量 public void OnLook(InputSystem.CallbackContext context) &#123; _delta = context.ReadValue&lt;Vector2>(); &#125; 获取鼠标右键是否按下 新建Action命名为Rotate，Action Type选择为Button，Action下新建binding，Path选择为Right Button[Mouse] 在相机控制脚本中编写OnRotate方法 private bool _isRotating; public void OnRotate(InputSystem.CallbackContext context) &#123; // 监听右键是否按下 _isRotating = context.started || context.performed; &#125; 记得在PlayerInput中调用方法 相机旋转实现 我们获得了鼠标相对上一个位置的偏移量，以及目前是否在按下右键，那么就像当于我们或去了是否在按下右键拖拽鼠标的信息，接下来只需要实现相机的旋转(这里实现的是相机的横向旋转，即只改变相机旋转的y值)即可。 private float _xRotation; [SerializeField] private float rotationSpeed = .5f; private void Awake() &#123; _xRotation = transform.rotation.eulerAngles.x; &#125; private void LateUpdate() &#123; if (_isRotating) &#123; // 只修改Rotation的y transform.rotation = Quaternion.Euler(_xRotation, transform.rotation.eulerAngles.y + _delta.x * rotationSpeed, 0.0f); &#125; &#125; 到了这一步就已经可以实现相机的旋转了，不过如果需要吸附相机的y值到45、135、225、315度，那么就看一下下面的步骤。 相机吸附 判断当前角度在哪个区间，要吸附到哪个角度 private Vector3 SnappedVector() &#123; var endValue = 0.0f; var currentY = Mathf.Ceil(transform.rotation.eulerAngles.y); endValue = currentY switch &#123; >= 0 and &lt;= 90 => 45.0f, >= 91 and &lt;= 180 => 135.0f, >= 181 and &lt;= 270 => 225.0f, _ => 315.0f &#125;; return new Vector3(_xRotation, endValue, 0f); &#125; 使用DoTween将为相机吸附做一个流畅的动画(DoTween调用OnComplete方法记得O是大写，isBusy用于判断是否完成动画了) private void SnapRotation() &#123; transform.DORotate(SnappedVector(), 0.5f) .SetEase(Ease.OutBounce) .OnComplete(() => &#123; isBusy = false; &#125;); &#125; 最后再在OnRotate方法中，当右键释放时执行这两个方法 public void OnRotate(InputAction.CallbackContext context) &#123; _isRotating = context.started || context.performed; if (context.canceled) &#123; isBusy = true; SnapRotation(); &#125; &#125; 到这里右键点击旋转相机，松开右键相机吸附的效果就完成了","categories":[{"name":"Unity","slug":"Unity","permalink":"https://yzs020220.github.io/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://yzs020220.github.io/tags/Unity/"}]},{"title":"Unity版本管理与多人协同-Plastic SCM食用指南","slug":"Unity版本管理与多人协同-PlasticSCM食用指南","date":"2023-03-09T07:29:28.000Z","updated":"2023-03-09T08:25:21.107Z","comments":true,"path":"posts/18456/","link":"","permalink":"https://yzs020220.github.io/posts/18456/","excerpt":"最近在跟几个人一块做一个游戏，版本管理与多人协同就成了一个非常重要的问题","text":"最近在跟几个人一块做一个游戏，版本管理与多人协同就成了一个非常重要的问题 如何让成员加入组织(单人可以忽略该步骤) 在Unity Hub中点击头像-&gt;管理组织，进入网页，选择自己的组织，在成员&amp;群组中点击查看所有在点击添加成员(个人许可证用户的组织只能有三个成员)。 询问成员注册Unity ID的邮箱，并输入邮箱邀请成员加入组织，通过后成员就会出现在组织中。 启用Plastic SCM进行版本管理 对于新建的项目，在新建项目时，勾选启用版本管理并同意政策条款即可 对于已经创建的项目，将鼠标悬停在项目名上即会出现托管到版本控制系统，点击即可 使用Plastic SCM进行版本控制 点击Window-&gt;Plastic SCM即可打开Plastic SCM窗口 签入更改 在对分支进行修改后，如要应用更改，在Plastic SCM窗口中选择待定更改(pending)，在点击签入更改(checkin)即可。建议在取得阶段性成果时签入更改，以免之后出现问题无法回滚。 变更集 在变更集中，你能找到所有进行的变更以及其创建者和创建事件，选中变更集能看到其从那个变更集中变更以及所做的修改。 分支 在分支中右键任一分支，可以为其创建子分支，子分支会继承main分支下的所有内容(之后对子分支或父分支的修改都是相互独立的，需要手动进行合并)，多人协同时需要创建多个分支在对主分支发起合并。 右键任一分支可将工作区切换到该分支上。 在Plastic SCM中对分支进行合并 Plastic SCM会自动解决大部分冲突，但有的时候也会有一些冲突需要进行手动解决。 点击Plastic SCM窗口右上角的分支图标，选择分支资源管理器即可打开管理器 合并到其他分支 每一个节点代表一个资源集，最新的在右手边(箭头代表从何处变更)，右键要合并的节点，选择从该分支合并到… 然后选择你要合并的分支，再点击应用更改即可 手动解决冲突 很多时候会有冲突需要解决，尤其是对Scene场景中的物体做了更改，就需要手动解决，一般显示有冲突待解决，右键再次发起合并会告诉你待解决的冲突项是哪些，右键选择保留源(当前你发起合并的分支)或保留目标(你要合并到的分支)上的文件即可解决冲突，选错了也可以右键删除资源集。","categories":[{"name":"Unity","slug":"Unity","permalink":"https://yzs020220.github.io/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://yzs020220.github.io/tags/Unity/"},{"name":"PlasticSCM","slug":"PlasticSCM","permalink":"https://yzs020220.github.io/tags/PlasticSCM/"}]},{"title":"关于2.5D的一些乱七八糟的事","slug":"关于2-5D的一些乱七八糟的事","date":"2023-03-07T10:28:04.000Z","updated":"2023-03-13T15:16:57.876Z","comments":true,"path":"posts/9745/","link":"","permalink":"https://yzs020220.github.io/posts/9745/","excerpt":"最近在写的都与2.5D有关，随手记录一些好玩的东西。","text":"最近在写的都与2.5D有关，随手记录一些好玩的东西。 2D还是3D？ 2.5D是一个很奇妙的东西，对2.5D是非常难以下定义的，你不能说2.5D的逻辑是2D的，因为有很多使用这一视角的3D游戏，在这上面有很多需要使用Y轴的游戏，玩法上是2D无法实现的。但是你若说2.5D是3D的，但是又有很多伪3D游戏的视角是2.5D。这个定义争论起来其实很多时候没有什么意义，我个人更加倾向于将它看成一个视角就好了，在这个特殊的视角下，可以像纪念碑谷一样通过切换成正交相机来形成一些特殊的玩法，又或者像很多战棋，moba类游戏方便玩家观察到一个更全局的场景(而不像3D游戏一般被限制在身前的视角)，也有像八方旅人那样使用透视相机使得2D场景也有了远近关系，视觉效果上好看了非常多。总而言之，2.5D相对于2D与3D相机各有优点。 在2D还是3D下实现？ 在早期只有2D的游戏中，2.5D是通过特殊手段在2D的引擎上实现的特殊效果，在现在3D游戏早已走进千家万户的时代，也几乎很难找到一个只能实现2D的引擎类，在3D上做实现其实是更加舒服的，我个人归纳的大致理由如下： 2D需要做坐标和游戏内空间坐标的映射，而3D几乎只用旋转相机就能做到 对于美术来说，2D的地板UI都得去倾斜(其实转一下压一下也差不多)，3D则不会有这个问题 2D上想实现2.5D的光影效果是很困难的，而3D则不会有这个问题 不过2D其实也不是不能做就是了。 关于2.5D相机角度 2.5D相机角度比较舒服的旋转角度是(35, 45, 0)，y轴自由加减90度都可以，在这个旋转角度下看场景，如果相机设置为正交，则该角度下，一个旋转角度为(0, 0, 0)的方块看起来是几乎由3个完全一样的棱形组成的。 如果使用Unity中的Cinemachine，注意Follow是保持角度移动位置，LookAt是保持位置旋转角度，要保持旋转角度，我们需要在LookAt中留空。 在这个视角下我们就可以实现一些视错觉(记得使用Unity Scene视窗中的磁吸工具)，例如： 其实方块并不是全都相连的，但在相机中却是相连的 我们可以通过获取物体在相机的位置并忽视深度使得它们能够形成可以通行的路径，这样也就有很多好玩的玩法，纪念碑谷以及许多跟它有相似之处的都有用到这种视错觉。 2.5D影子-简单的Shader Graph 实现2D sprite在3D场景下的影子，这里参考了油管博主Sonny Williams的教学视频，Shader Graph如下图所示： 简单的来说实现思路就是新建Lit Shader在右边的Graph Inspector窗口中勾选Alpha Clipping(根据透明度挖空形状)，Threshold属性是alpha小于多少就把它挖空，否则保留。 对应shader新建完material后，更换对应Sprite中Sprite Renderer的material为我们新建的这个material，并且在右上角选择Debug模式将Cast Shadows设置为on 选择Debug模式Cast Shadows设置为on 简略效果预览","categories":[{"name":"Unity","slug":"Unity","permalink":"https://yzs020220.github.io/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://yzs020220.github.io/tags/Unity/"},{"name":"Unity Shader","slug":"Unity-Shader","permalink":"https://yzs020220.github.io/tags/Unity-Shader/"}]},{"title":"也许是最后一次换主题了","slug":"也许是最后一次换主题了","date":"2023-02-25T04:15:54.000Z","updated":"2023-03-16T06:07:09.841Z","comments":true,"path":"posts/30460/","link":"","permalink":"https://yzs020220.github.io/posts/30460/","excerpt":"换到volantis之后，大概是不会再换了，也聊一下Fluid和Volantis的差别","text":"换到volantis之后，大概是不会再换了，也聊一下Fluid和Volantis的差别 喜新厌旧也有终点 人总是喜新厌旧，但是没有什么是完美的，争论什么东西更好，很多时候也没有意义，在一次次尝试后，最终也会觉得在这上面花费的成本太高了。可能还会有更好的等待着你，但那个时候未必会有那个精力来去迎接了。 我为什么要换主题 我是一个太爱折腾的人，给主题加着加着东西，突然了解到了一个东西叫pjax(作用是已加载的不需要在打开新的网页不需要重复加载，如播放器和看板娘)，而刚巧Fluid开发者说他短期内不会有这个打算，工作量也太大了。不过没有pjax播放器就不能一直放，看板娘也要经常重复加载，对于我来说，我已经花费不少时间去做了这两个东西了，当我知道这两者的体验能够更好的时候，我就很难忍受现在这个体验了，所以最终还是咬牙换主题了。 我已经不太想去谈论Cards主题了，哪怕我对于第一个使用的主题多么有感情，也必须承认Cards虽然做的很用心，但是对比起其他stars数非常高的主题，它实在是没有办法和那几个主题掰手腕。在github顺着stars数一路向下找支持pjax的主题，我终于遇到了volantis，在此以前我所使用的两个主题都是主打轻量和简约，但我还是很喜欢volantis，我到底是一个爱折腾的人，简约只是我喜欢的外在风格，但我却中意留下大量折腾空间的内核，这一次更换主题耗费的时间比上一次还多，我感觉我确实也不会再去做主题的更换了，估计也只会在这上面去做更改了。 主题的选择 怎么选主题，最关键的还是要看人，如果只是想要写文章，那么像Fluid这种你再怎么配也不会差太多，界面美观，支持的各种东西也比较全的估计会更加合适。像volantis这样你从官方网站点进示例博客都有40多个的，你就会不自觉地想动手去改，去让它更对自己的胃口，volantis确实提供了非常全面的修改选项，在github上更是同时有稳定版和尝鲜版，如果你本身就是想做一个比较有个人特色的博客网站，那么它无疑是很不错的，在拥有高度的可自定义选项的同时对各项的插件也比较的全面。 volantis与Fluid 我觉得既然说了，那就得谈谈两者的差别。 pjax 这是我更换主题的最大原因，我个人觉得pjax对于网页的加载速度来说是很不错的，可惜的是Fluid却是原生不支持，而volantis默认开启。 代码高亮 Fluid的深色模式支持更加优秀，代码高亮主题也可以切换，而volantis只能使用一个代码高亮主题，不能够在深色模式进行切换(也许自定义可以实现但原生不支持)，并且在折叠插件下代码还会变成一行(issues已经有人反映了)，不过Fluid还需要spoiler插件支持感觉更难受(所有Hexo主题都能用spoiler)。 麻了，volantis简直不是给人拿来写代码的，如果需要写代码强烈建议配置prismjs，highlightjs甚至没法配置行号并且会跟hexo渲染器配置好的highlightjs起冲突，不得不说在代码高亮方面Fluid确实做的很优秀。 目录按钮 在页面缩小后会出现目录按钮，这个在Cards主题中就有，而在Fluid中没有，曾是我一度一来最为遗憾的事情(习惯了)，到后面我也觉得有没有其实也可以接受了，毕竟不是所有的文章都真的非常的长(虽然我个人确实有几篇文章真的很长)。volantis就很巧妙的放在了顶部导航栏，上滑与下滑显示不一样的内容，这一点我觉得很赞。 样式的不同 显而易见，volantis是那种侧边栏加文章，Fluid是文章作主体，没有谁好谁坏，看个人偏好。 首页文章样式 我曾经称赞过Cards主题的首页卡片式布局，可以让文章在没有封面图和无封面图两种情况同时存在都不会觉得不协调，而volantis同为卡片式布局也能做到(但是不得不说封面图属性叫headimg就很难受，很容易看成heading，如果加个下划线那就没那么容易看错了)，但像Fluid这种将文章封面图放在侧边的主题则基本上不太好把两者的样式放在一起。 美观 像Fluid的配色与布局，基本上什么都不用配都是挺好看的，而volantis官方博客却给人一种太过朴素的感觉，不得不说，volantis在拥有丰富自定义选项的同时，也失去了开箱即用的便利性。只能说用volantis的不同的人，博客的风格也是感觉有差别的，而用Fluid则会让人感觉好像都长得一样，但我还是觉得Fluid很好看。 该好好写博客了 给博客网站作美化是一件很快乐的事情，就好像给自己心爱的玩具上颜色，挂装备，但是不管怎么说，博客终究是一个需要内容来支撑的地方，因为样式总会有更换的终点，而内容却会不断地增加。所以以后有空估计也不会再投入到美化博客这方面了，是时候回归博客的主要用途——写博客上面了。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://yzs020220.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yzs020220.github.io/tags/Hexo/"},{"name":"Cards主题","slug":"Cards主题","permalink":"https://yzs020220.github.io/tags/Cards%E4%B8%BB%E9%A2%98/"},{"name":"volantis主题","slug":"volantis主题","permalink":"https://yzs020220.github.io/tags/volantis%E4%B8%BB%E9%A2%98/"},{"name":"Fluid主题","slug":"Fluid主题","permalink":"https://yzs020220.github.io/tags/Fluid%E4%B8%BB%E9%A2%98/"}]},{"title":"Hexo博客添加live2d看板娘-可换装，增删模型","slug":"Hexo博客添加看板娘-可换装，增删模型","date":"2023-02-18T02:11:35.000Z","updated":"2023-03-07T07:27:00.270Z","comments":true,"path":"posts/41158/","link":"","permalink":"https://yzs020220.github.io/posts/41158/","excerpt":"记录如何折腾左下角的看板娘，包括live2d_widget的使用，如何自己修改live2d_api中的模型并直接访问或上传到NPM上再通过CDN加速访问，以及如何调整模型的大小进行适配。","text":"记录如何折腾左下角的看板娘，包括live2d_widget的使用，如何自己修改live2d_api中的模型并直接访问或上传到NPM上再通过CDN加速访问，以及如何调整模型的大小进行适配。 live2d_widget的使用 将stevenjoezhang/live2d-widget的项目通过git clone拷贝到主题的source目录下 在主题目录的layout文件夹中找到head文件并在其中添加代码(若有PJAX放到PJAX刷新区域外更好) &lt;script src=\"/live2d-widget/autoload.js\">&lt;/script> 修改live2d_widget文件夹下的autoload.js文件，更换live2d_path为 const live2d_path = \"/live2d-widget/\"; 在initWidget中，注释掉apiPath(原api地址已不可用)并修改cdnPath，原作者的cdn地址不能换装，可以用Live2d Widget | Akilarの糖果屋中的cdn地址(可换装且模型比较多，我也是在此基础上改的，我的live2d_api) // 三个cdnPath选一个，分别是原作者，Akilar站长，我的 cdnPath: \"https://fastly.jsdelivr.net/gh/fghrsh/live2d_api/\" cdnPath: \"https://npm.elemecdn.com/akilar-live2dapi@latest/\" cdnPath: \"https://gcore.jsdelivr.net/npm/yzs-live2d_src@1.1.0/\" 或者使用本地的地址，将live2d_api放在博客的原网站下(反正免费的CDN加速在国内基本上不得行，基本上需要梯子，所以直接在网站内访问的速度也可以，如果有条件用gitee也可以直接用gitee，不过注意在tips下删掉一些句子)，具体操作见下文 cdnPath: \"/live2d_api/\" 修改完后deploy就可以用了 如果看板娘说的话太羞耻了，可以在waifu-tips.json中更改 如果被挡住的话是因为在插件的z-index默认为-1(修改为999就是最顶层，值越大所在的图层就越高)，在waifu.css文件中修改即可，调整插件大小也是在这个文件中，修改对应部分的width和height即可 #waifu &#123; z-index: 999; &#125; 修改live2d_api fork并克隆仓库到本地 先把live2d_api fork到自己的仓库里，可以fork我的也可以fork Akilarlxh/live2d_api 将自己的仓库git clone下来 如何增删模型即缩放调整 以下操作都在本地的live2d_api文件夹中进行操作 删除模型 在model_list.json中删除对应的models名称，messages对应的是更换看板娘时看板娘会说的话(跟models的顺序对应) 在model文件夹中删除对应名称的文件夹 增加模型 由于live2d_widget仅支持Cubism2.1，虽然issues上有兼容目前所有live2d格式的issues，但我目前没有尝试过(比较麻烦，暂时不想加新的模型，就这样吧) 如果只使用Cubism2.1，我个人推荐去看看xiazeyu/live2d-widget-models和xiaoski/live2d_models_collection，收录的不少而且都是可用的，在网上找的话Cubism2.1的模型已经不多了 在将上面两个项目中通过git clone或npm install后，把对应的模型文件夹拉到model文件夹下 修改模型文件夹中的那个指定各个文件路径的json文件为index.json，一般这个文件叫name.model.json，一般来说修改到这个步骤的模型文件就已经可用了 在model_list.json文件中的models中添加对应的文件夹名字并添加对应的messages即可 修改模型的大小与位置 由于一般拿到的模型可能大小不对，所以也给出了模型的位置及大小的方法 打开需要修改的模型的文件夹中的name.model.json文件，添加或修改layout部分 \"layout\": &#123; \"center_x\": 0, // 模型中心对应的横坐标，默认为0 \"center_y\": -0.2, // 模型中心对应的纵坐标，默认为0 \"width\": 1.5 // 模型的大小，默认为2 &#125;, 调整到自己需要的比例还挺麻烦的，上面的参数是xiaoski/live2d_models_collection中我调整康娜缩放及位置的参数，应该其他的模型也基本可用(我没试过) 修改完之后就是上传到博客或上传到npm了。 上传到博客上并访问 因为国内jsDelivr已经几乎不可用了，所以直接上传也是不错的选择(还不限大小)。 将修改后的live2d_api仓库拷贝到主题的source文件夹下(在博客根目录的source下会导致里面的很多文件会进行渲染)，修改live2d-widget中的autoload.js中的cdnPath： cdnPath: \"/live2d_api/\" NPM上传并通过CDN访问 为什么是npm，github打包之后发布release版本后，等待一段时间也可以通过cdn访问，可惜cdn访问github仓库，必须控制在50MB以内，而npm则可以到100MB，更不用说npm发布的包可以通过unpkg访问，就是我的仓库通过unpkg访问实在是太慢了，所以我还是用的cdn。 注册npm帐号 在npm官网注册帐号 在api文件夹下打开cmd 如果有使用过npm镜像请先关闭 输入命令登录 npm adduser 按照提示输入邮箱和密码 查看一下是否登录成功 npm whoami 如果提示网络错误可以设置代理 npm config set proxy http://127.0.0.1:port npm config set https-proxy http://127.0.0.1:port 修改package.json的信息并发布 先初始化 npm init 修改api文件夹中的package.json的信息，将几处都换成你自己的链接，注意版本之后每一次发布都要比上一次更大 \"name\": \"资源名，尽量不要包含数字，容易被ban\", \"version\": \"你的版本\", \"author\": \"你的npm用户名字\", 发布资源(会比较久，看大小和网速) npm publish --public 通过CDN或unpkg访问 一般上传到npm后基本能立刻通过CDN访问到(可以在浏览器打开查看)，但是不能超过100MB，格式如下(gcore的访问速度更好一点) https://cdn.jsdelivr.net/npm/资源名@版本/ https://fastly.jsdelivr.net/npm/资源名@版本/ https://gcore.jsdelivr.net/npm/资源名@版本/ unpkg也可以使用，就是收录速度实在太慢了，还经常内部的文件夹打不开，不过它确实能加载更大的项目，格式如下(饿了么的源好一点) https://npm.elemecdn.com/资源名@版本/ https://unpkg.com/资源名@版本/","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://yzs020220.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yzs020220.github.io/tags/Hexo/"},{"name":"live2d_widget","slug":"live2d-widget","permalink":"https://yzs020220.github.io/tags/live2d-widget/"},{"name":"live2d_api","slug":"live2d-api","permalink":"https://yzs020220.github.io/tags/live2d-api/"},{"name":"NPM","slug":"NPM","permalink":"https://yzs020220.github.io/tags/NPM/"},{"name":"CDN","slug":"CDN","permalink":"https://yzs020220.github.io/tags/CDN/"}]},{"title":"Hexo添加全局音乐播放-APlayer(包含位置修改)","slug":"为你的博客添加全局音乐播放-APlayer-包含位置修改","date":"2023-02-15T10:42:07.000Z","updated":"2023-03-08T02:26:53.603Z","comments":true,"path":"posts/47641/","link":"","permalink":"https://yzs020220.github.io/posts/47641/","excerpt":"使用APlayer+MetingJS方便快捷地为你的博客添加歌单，qq音乐不能外链，建议网易","text":"使用APlayer+MetingJS方便快捷地为你的博客添加歌单，qq音乐不能外链，建议网易 全局添加音乐播放器 APlayer提供了吸底模式，在主题文件夹下的/source/layout/_partials/head.ejs下加入以下代码即可(如果是其他主题，找到head对应的文件渲染成html即可) &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css\">&lt;!--我的APlayer的样式--> &lt;script src=\"https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js\">&lt;/script>&lt;!--APlayer的依赖--> &lt;script src=\"https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js\">&lt;/script>&lt;!--Meting的依赖--> &lt;meting-js server=\"tencent\" type=\"playlist\" autoplay=false fixed=true lrc-type=0 id=\"8807687250\"> &lt;/meting-js> 参数说明： 见MetingJS参数说明与APlayer参数说明，补充一下说明文档讲的有点含糊的： 参数 默认值 说明 lrcType 0 0代表不显示歌词，1代表读取字符串，2代表读取html，3代表读取lrc文件(如果你使用歌单选3或0，一般也是) 文章内使用 直接将html复制粘贴进文章的md文档的对应位置即可 播放列表展示 &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css\">&lt;!--APlayer的样式--> &lt;script src=\"https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js\">&lt;/script>&lt;!--APlayer的依赖--> &lt;script src=\"https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js\">&lt;/script>&lt;!--Meting的依赖--> &lt;meting-js server=\"netease\" type=\"playlist\" autoplay=false lrc-type=3 id=\"7893371839\"> &lt;/meting-js> 迷你模式展示 &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css\">&lt;!--APlayer的样式--> &lt;script src=\"https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js\">&lt;/script>&lt;!--APlayer的依赖--> &lt;script src=\"https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js\">&lt;/script>&lt;!--Meting的依赖--> &lt;meting-js server=\"netease\" type=\"playlist\" autoplay=false mini=true id=\"7893371839\"> &lt;/meting-js> 修改吸底模式的位置 我是因为左下角有看板娘所以要修改它的位置，有的时候隐藏任务栏后，任务栏跳出来也会挡住播放器。 打开APlayer.min.css的链接可以看到它的代码，如果你懒得找，我在这里直接提供了代码(不过这个会很长，我会告诉你在哪里改)： APlayer.min.css代码折叠(点击展开) .aplayer &#123; background: #fff; font-family: Arial, Helvetica, sans-serif; margin: 5px; box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .07), 0 1px 5px 0 rgba(0, 0, 0, .1); border-radius: 2px; overflow: hidden; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; line-height: normal; position: relative &#125; .aplayer * &#123; box-sizing: content-box &#125; .aplayer svg &#123; width: 100%; height: 100% &#125; .aplayer svg circle, .aplayer svg path &#123; fill: #fff &#125; .aplayer.aplayer-withlist .aplayer-info &#123; border-bottom: 1px solid #e9e9e9 &#125; .aplayer.aplayer-withlist .aplayer-list &#123; display: block &#125; .aplayer.aplayer-withlist .aplayer-icon-order, .aplayer.aplayer-withlist .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-menu &#123; display: inline &#125; .aplayer.aplayer-withlrc .aplayer-pic &#123; height: 90px; width: 90px &#125; .aplayer.aplayer-withlrc .aplayer-info &#123; margin-left: 90px; height: 90px; padding: 10px 7px 0 &#125; .aplayer.aplayer-withlrc .aplayer-lrc &#123; display: block &#125; .aplayer.aplayer-narrow &#123; width: 66px &#125; .aplayer.aplayer-narrow .aplayer-info, .aplayer.aplayer-narrow .aplayer-list &#123; display: none &#125; .aplayer.aplayer-narrow .aplayer-body, .aplayer.aplayer-narrow .aplayer-pic &#123; height: 66px; width: 66px &#125; .aplayer.aplayer-fixed &#123; position: fixed; bottom: 300px; left: 0; right: 0; margin: 0; z-index: 99; overflow: visible; max-width: 400px; box-shadow: none &#125; .aplayer.aplayer-fixed .aplayer-list &#123; margin-bottom: 65px; border: 1px solid #eee; border-bottom: none &#125; .aplayer.aplayer-fixed .aplayer-body &#123; position: fixed; bottom: 300px; left: 0; right: 0; margin: 0; z-index: 99; background: #fff; padding-right: 18px; transition: all .3s ease; max-width: 400px &#125; .aplayer.aplayer-fixed .aplayer-lrc &#123; display: block; position: fixed; bottom: 310px; left: 0; right: 0; margin: 0; z-index: 98; pointer-events: none; text-shadow: -1px -1px 0 #fff &#125; .aplayer.aplayer-fixed .aplayer-lrc:after, .aplayer.aplayer-fixed .aplayer-lrc:before &#123; display: none &#125; .aplayer.aplayer-fixed .aplayer-info &#123; -webkit-transform: scaleX(1); transform: scaleX(1); -webkit-transform-origin: 0 0; transform-origin: 0 0; transition: all .3s ease; bottom: 300px; border-bottom: none; border-top: 1px solid #e9e9e9 &#125; .aplayer.aplayer-fixed .aplayer-info .aplayer-music &#123; width: calc(100% - 105px) &#125; .aplayer.aplayer-fixed .aplayer-miniswitcher &#123; display: block &#125; .aplayer.aplayer-fixed.aplayer-narrow .aplayer-info &#123; display: block; -webkit-transform: scaleX(0); transform: scaleX(0) &#125; .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body &#123; width: 66px !important &#125; .aplayer.aplayer-fixed.aplayer-narrow .aplayer-miniswitcher .aplayer-icon &#123; -webkit-transform: rotateY(0); transform: rotateY(0) &#125; .aplayer.aplayer-fixed .aplayer-icon-back, .aplayer.aplayer-fixed .aplayer-icon-forward, .aplayer.aplayer-fixed .aplayer-icon-lrc, .aplayer.aplayer-fixed .aplayer-icon-play &#123; display: inline-block &#125; .aplayer.aplayer-fixed .aplayer-icon-back, .aplayer.aplayer-fixed .aplayer-icon-forward, .aplayer.aplayer-fixed .aplayer-icon-menu, .aplayer.aplayer-fixed .aplayer-icon-play &#123; position: absolute; bottom: 27px; width: 20px; height: 20px &#125; .aplayer.aplayer-fixed .aplayer-icon-back &#123; right: 75px &#125; .aplayer.aplayer-fixed .aplayer-icon-play &#123; right: 50px &#125; .aplayer.aplayer-fixed .aplayer-icon-forward &#123; right: 25px &#125; .aplayer.aplayer-fixed .aplayer-icon-menu &#123; right: 0 &#125; .aplayer.aplayer-arrow .aplayer-icon-loop, .aplayer.aplayer-arrow .aplayer-icon-order, .aplayer.aplayer-mobile .aplayer-icon-volume-down &#123; display: none &#125; .aplayer.aplayer-loading .aplayer-info .aplayer-controller .aplayer-loading-icon &#123; display: block &#125; .aplayer.aplayer-loading .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played .aplayer-thumb &#123; -webkit-transform: scale(1); transform: scale(1) &#125; .aplayer .aplayer-body &#123; position: relative &#125; .aplayer .aplayer-icon &#123; width: 15px; height: 15px; border: none; background-color: transparent; outline: none; cursor: pointer; opacity: .8; vertical-align: middle; padding: 0; font-size: 12px; margin: 0; display: inline-block &#125; .aplayer .aplayer-icon path &#123; transition: all .2s ease-in-out &#125; .aplayer .aplayer-icon-back, .aplayer .aplayer-icon-forward, .aplayer .aplayer-icon-lrc, .aplayer .aplayer-icon-order, .aplayer .aplayer-icon-play &#123; display: none &#125; .aplayer .aplayer-icon-lrc-inactivity svg &#123; opacity: .4 &#125; .aplayer .aplayer-icon-forward &#123; -webkit-transform: rotate(180deg); transform: rotate(180deg) &#125; .aplayer .aplayer-lrc-content &#123; display: none &#125; .aplayer .aplayer-pic &#123; position: relative; float: left; height: 66px; width: 66px; background-size: cover; background-position: 50%; transition: all .3s ease; cursor: pointer &#125; .aplayer .aplayer-pic:hover .aplayer-button &#123; opacity: 1 &#125; .aplayer .aplayer-pic .aplayer-button &#123; position: absolute; border-radius: 50%; opacity: .8; text-shadow: 0 1px 1px rgba(0, 0, 0, .2); box-shadow: 0 1px 1px rgba(0, 0, 0, .2); background: rgba(0, 0, 0, .2); transition: all .1s ease &#125; .aplayer .aplayer-pic .aplayer-button path &#123; fill: #fff &#125; .aplayer .aplayer-pic .aplayer-hide &#123; display: none &#125; .aplayer .aplayer-pic .aplayer-play &#123; width: 26px; height: 26px; border: 2px solid #fff; bottom: 50%; right: 50%; margin: 0 -15px -15px 0 &#125; .aplayer .aplayer-pic .aplayer-play svg &#123; position: absolute; top: 3px; left: 4px; height: 20px; width: 20px &#125; .aplayer .aplayer-pic .aplayer-pause &#123; width: 16px; height: 16px; border: 2px solid #fff; bottom: 4px; right: 4px &#125; .aplayer .aplayer-pic .aplayer-pause svg &#123; position: absolute; top: 2px; left: 2px; height: 12px; width: 12px &#125; .aplayer .aplayer-info &#123; margin-left: 66px; padding: 14px 7px 0 10px; height: 66px; box-sizing: border-box &#125; .aplayer .aplayer-info .aplayer-music &#123; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; margin: 0 0 13px 5px; -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text; user-select: text; cursor: default; padding-bottom: 2px; height: 20px &#125; .aplayer .aplayer-info .aplayer-music .aplayer-title &#123; font-size: 14px &#125; .aplayer .aplayer-info .aplayer-music .aplayer-author &#123; font-size: 12px; color: #666 &#125; .aplayer .aplayer-info .aplayer-controller &#123; position: relative; display: flex &#125; .aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap &#123; margin: 0 0 0 5px; padding: 4px 0; cursor: pointer !important; flex: 1 &#125; .aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap:hover .aplayer-bar .aplayer-played .aplayer-thumb &#123; -webkit-transform: scale(1); transform: scale(1) &#125; .aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar &#123; position: relative; height: 2px; width: 100%; background: #cdcdcd &#125; .aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-loaded &#123; position: absolute; left: 0; top: 0; bottom: 0; background: #aaa; height: 2px; transition: all .5s ease &#125; .aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played &#123; position: absolute; left: 0; top: 0; bottom: 0; height: 2px &#125; .aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played .aplayer-thumb &#123; position: absolute; top: 0; right: 5px; margin-top: -4px; margin-right: -10px; height: 10px; width: 10px; border-radius: 50%; cursor: pointer; transition: all .3s ease-in-out; -webkit-transform: scale(0); transform: scale(0) &#125; .aplayer .aplayer-info .aplayer-controller .aplayer-time &#123; position: relative; right: 0; bottom: 4px; height: 17px; color: #999; font-size: 11px; padding-left: 7px &#125; .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-time-inner &#123; vertical-align: middle &#125; .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon &#123; cursor: pointer; transition: all .2s ease &#125; .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path &#123; fill: #666 &#125; .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-loop &#123; margin-right: 2px &#125; .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon:hover path &#123; fill: #000 &#125; .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-menu, .aplayer .aplayer-info .aplayer-controller .aplayer-time.aplayer-time-narrow .aplayer-icon-menu, .aplayer .aplayer-info .aplayer-controller .aplayer-time.aplayer-time-narrow .aplayer-icon-mode &#123; display: none &#125; .aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap &#123; position: relative; display: inline-block; margin-left: 3px; cursor: pointer !important &#125; .aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap:hover .aplayer-volume-bar-wrap &#123; height: 40px &#125; .aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap &#123; position: absolute; bottom: 15px; right: -3px; width: 25px; height: 0; z-index: 99; overflow: hidden; transition: all .2s ease-in-out &#125; .aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap.aplayer-volume-bar-wrap-active &#123; height: 40px &#125; .aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap .aplayer-volume-bar &#123; position: absolute; bottom: 0; right: 10px; width: 5px; height: 35px; background: #aaa; border-radius: 2.5px; overflow: hidden &#125; .aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap .aplayer-volume-bar .aplayer-volume &#123; position: absolute; bottom: 0; right: 0; width: 5px; transition: all .1s ease &#125; .aplayer .aplayer-info .aplayer-controller .aplayer-loading-icon &#123; display: none &#125; .aplayer .aplayer-info .aplayer-controller .aplayer-loading-icon svg &#123; position: absolute; -webkit-animation: rotate 1s linear infinite; animation: rotate 1s linear infinite &#125; .aplayer .aplayer-lrc &#123; display: none; position: relative; height: 30px; text-align: center; overflow: hidden; margin: -10px 0 7px &#125; .aplayer .aplayer-lrc:before &#123; top: 0; height: 10%; background: linear-gradient(180deg, #fff 0, hsla(0, 0%, 100%, 0)); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#ffffff\", endColorstr=\"#00ffffff\", GradientType=0) &#125; .aplayer .aplayer-lrc:after, .aplayer .aplayer-lrc:before &#123; position: absolute; z-index: 1; display: block; overflow: hidden; width: 100%; content: \" \" &#125; .aplayer .aplayer-lrc:after &#123; bottom: 0; height: 33%; background: linear-gradient(180deg, hsla(0, 0%, 100%, 0) 0, hsla(0, 0%, 100%, .8)); filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=\"#00ffffff\", endColorstr=\"#ccffffff\", GradientType=0) &#125; .aplayer .aplayer-lrc p &#123; font-size: 12px; color: #666; line-height: 16px !important; height: 16px !important; padding: 0 !important; margin: 0 !important; transition: all .5s ease-out; opacity: .4; overflow: hidden &#125; .aplayer .aplayer-lrc p.aplayer-lrc-current &#123; opacity: 1; overflow: visible; height: auto !important; min-height: 16px &#125; .aplayer .aplayer-lrc.aplayer-lrc-hide &#123; display: none &#125; .aplayer .aplayer-lrc .aplayer-lrc-contents &#123; width: 100%; transition: all .5s ease-out; -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text; user-select: text; cursor: default &#125; .aplayer .aplayer-list &#123; overflow: auto; transition: all .5s ease; will-change: height; display: none; overflow: hidden &#125; .aplayer .aplayer-list.aplayer-list-hide &#123; max-height: 0 !important &#125; .aplayer .aplayer-list ol &#123; list-style-type: none; margin: 0; padding: 0; overflow-y: auto &#125; .aplayer .aplayer-list ol::-webkit-scrollbar &#123; width: 5px &#125; .aplayer .aplayer-list ol::-webkit-scrollbar-thumb &#123; border-radius: 3px; background-color: #eee &#125; .aplayer .aplayer-list ol::-webkit-scrollbar-thumb:hover &#123; background-color: #ccc &#125; .aplayer .aplayer-list ol li &#123; position: relative; height: 32px; line-height: 32px; padding: 0 15px; font-size: 12px; border-top: 1px solid #e9e9e9; cursor: pointer; transition: all .2s ease; overflow: hidden; margin: 0 &#125; .aplayer .aplayer-list ol li:first-child &#123; border-top: none &#125; .aplayer .aplayer-list ol li:hover &#123; background: #efefef &#125; .aplayer .aplayer-list ol li.aplayer-list-light &#123; background: #e9e9e9 &#125; .aplayer .aplayer-list ol li.aplayer-list-light .aplayer-list-cur &#123; display: inline-block &#125; .aplayer .aplayer-list ol li .aplayer-list-cur &#123; display: none; width: 3px; height: 22px; position: absolute; left: 0; top: 5px; cursor: pointer &#125; .aplayer .aplayer-list ol li .aplayer-list-index &#123; color: #666; margin-right: 12px; cursor: pointer &#125; .aplayer .aplayer-list ol li .aplayer-list-author &#123; color: #666; float: right; cursor: pointer &#125; .aplayer .aplayer-notice &#123; opacity: 0; position: absolute; top: 50%; left: 50%; -webkit-transform: translate(-50%, -50%); transform: translate(-50%, -50%); font-size: 12px; border-radius: 4px; padding: 5px 10px; transition: all .3s ease-in-out; overflow: hidden; color: #fff; pointer-events: none; background-color: #f4f4f5; color: #909399 &#125; .aplayer .aplayer-miniswitcher &#123; display: none; position: absolute; top: 0; right: 0; height: 100%; background: #e6e6e6; width: 18px; border-radius: 0 2px 2px 0 &#125; .aplayer .aplayer-miniswitcher .aplayer-icon &#123; height: 100%; width: 100%; -webkit-transform: rotateY(180deg); transform: rotateY(180deg); transition: all .3s ease &#125; .aplayer .aplayer-miniswitcher .aplayer-icon path &#123; fill: #666 &#125; .aplayer .aplayer-miniswitcher .aplayer-icon:hover path &#123; fill: #000 &#125; @-webkit-keyframes aplayer-roll &#123; 0% &#123; left: 0 &#125; to &#123; left: -100% &#125; &#125; @keyframes aplayer-roll &#123; 0% &#123; left: 0 &#125; to &#123; left: -100% &#125; &#125; @-webkit-keyframes rotate &#123; 0% &#123; -webkit-transform: rotate(0); transform: rotate(0) &#125; to &#123; -webkit-transform: rotate(1turn); transform: rotate(1turn) &#125; &#125; @keyframes rotate &#123; 0% &#123; -webkit-transform: rotate(0); transform: rotate(0) &#125; to &#123; -webkit-transform: rotate(1turn); transform: rotate(1turn) &#125; &#125; /*# sourceMappingURL=APlayer.min.css.map*/ 在主题文件夹下的source/css文件夹下新建文件APlayer.min.css，并在第一步中的head文件中更换该文件的路径： &lt;link rel=\"stylesheet\" href=\"你的域名/css/APlayer.min.css\">&lt;!--APlayer的样式--> &lt;script src=\"https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js\">&lt;/script>&lt;!--APlayer的依赖--> &lt;script src=\"https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js\">&lt;/script>&lt;!--Meting的依赖--> &lt;meting-js server=\"tencent\" type=\"playlist\" autoplay=false fixed=true lrc-type=0 id=\"8807687250\"> &lt;/meting-js> 修改bottom属性即可(距离底部的距离)： .aplayer.aplayer-fixed &#123; position: fixed; bottom: 300px; left: 0; right: 0; margin: 0; z-index: 99; overflow: visible; max-width: 400px; box-shadow: none &#125; .aplayer.aplayer-fixed .aplayer-body &#123; position: fixed; bottom: 300px; left: 0; right: 0; margin: 0; z-index: 99; background: #fff; padding-right: 18px; transition: all .3s ease; max-width: 400px &#125; .aplayer.aplayer-fixed .aplayer-info &#123; -webkit-transform: scaleX(1); transform: scaleX(1); -webkit-transform-origin: 0 0; transform-origin: 0 0; transition: all .3s ease; bottom: 300px; border-bottom: none; border-top: 1px solid #e9e9e9 &#125;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://yzs020220.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yzs020220.github.io/tags/Hexo/"},{"name":"Fluid","slug":"Fluid","permalink":"https://yzs020220.github.io/tags/Fluid/"},{"name":"音乐","slug":"音乐","permalink":"https://yzs020220.github.io/tags/%E9%9F%B3%E4%B9%90/"}]},{"title":"我曾想做的平行线","slug":"我曾想做的平行线","date":"2023-02-13T01:05:33.000Z","updated":"2023-03-03T05:45:46.562Z","comments":true,"path":"posts/12027/","link":"","permalink":"https://yzs020220.github.io/posts/12027/","excerpt":"也许在读计算机这个专业前，每个人都有想过自己以后做的事，我曾想做一个网站或APP，叫平行线。在这里，大家不会相互评论，没有那么多社交压力。","text":"也许在读计算机这个专业前，每个人都有想过自己以后做的事，我曾想做一个网站或APP，叫平行线。在这里，大家不会相互评论，没有那么多社交压力。 文字的力量 “读万卷书，行万里路”，我曾经无比相信文字的力量。小学的时候，应老师的需要，我们要在QQ空间里写日记。毫无疑问，以文字的方式去表达自己，大多数时候会比现在的朋友圈有深度的多，朋友圈不能写字吗？当然可以，但是在朋友圈写太多字，周围人也许甚至不会点开去查看，也许不被人看到也不会有什么关系，但更关键的是，会被人认为很奇怪，“怎么别人都在发图，只有你说一堆屁话“。在我看来，在朋友圈书写文字，不适合表达自我，而适合表达情绪。表达情绪只需要些许字即可，朋友圈就应该足够短，最好只有图片。在减少了发布者消耗的时间的同时也减少了阅读者消耗的时间，确实是一项巨大的成功，然而当周围人朋友圈发的多了，我点赞点的手也累了，有的时候不看，三天就过去了，根本不想翻，然而等到跟别人聊天的时候，聊着聊着我不知道某件事，他又说”我发了朋友圈“，没看就是没看啦，虽然当然也不会怎么样。聊天也是用文字，可以让人更加深入地了解对方，也许打一次电话比刷你一年朋友圈了解你更多，说到底看朋友圈大部分时候只能看出sb. do sth.，对阅读者来说无法更进一步了解发布者，但是它又切切实实地会给予你社交上的压力。 开始写博客 我曾想做的网站或APP有做吗？没有，我这个计算机废物根本不会写网站，课内学的都是AI方向的，自己想搞的都是游戏方向的，虽然我会写APP但我网络一点都不懂，一个计算机网络都要到大三下学期才能学。仔细想想，我当时想做的这玩意也非常不成熟，纯文字，没有评论，推送机制是纯随机，当时根本就不懂这些东西，连服务器是啥都不明白。当我真正接触博客，我才发现天啊，早就有人把我曾经想做的做出来了，虽然博客没有推送机制，但是除此以外，高度的自定义，静态网页+github pages都不需要服务器，在这里真的是想写多少写多少，不需要写的时候还在纠结到底谁可见，说到底也没多少人知道我在写博客，博客才真正是表达自己的地方。 感谢Hexo，它真的做了一件很了不起的事情。👍","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://yzs020220.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://yzs020220.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"常用网站汇总","slug":"常用网站汇总","date":"2023-02-02T09:35:13.000Z","updated":"2023-03-03T05:45:46.563Z","comments":true,"path":"posts/41576/","link":"","permalink":"https://yzs020220.github.io/posts/41576/","excerpt":"收集了一些常用网站，主要是博客的搭建以及写作相关。","text":"收集了一些常用网站，主要是博客的搭建以及写作相关。 设计相关 作为一个代码人，设计上的东西实在是不能用太困难的工具，这里包含了在博客以及一些其他地方用的设计相关的网站。 配色网站 作为一个口红色号都分不清的死直男，配色网站绝对不可或缺。 Paletton - The Color Scheme Designer，做配色的，选取主色后，拖动中间的小圆点就可以选取五个颜色，按住shift可以单独拖动一个圆点，也可以直接拖动其中的圆点增大颜色与颜色之间的对比度PREVIEW选项可以查看改颜色中的文字显示清不清晰 🎨 Material Design Colors, Color Palette，好用的Material Design调色板(感谢google) 来自Ant Design的基础色板也是很不错的 博客封面制作 直接搜索图片(特定想用某个图片做封面时) GIPHY - Be Animated一个gif收录网站，挺不错的 首页 - Canva可画，海报制作，很常用，里面有很多素材，上手也非常简单(免费版基本够用) 代码相关 代码对比/归并，查漏补缺，为什么这份代码能跑，那份不能跑 搜索引擎与各大论坛 写作相关 LaTeX公式手册(全网最全) - 樱花赞 - 博客园 (cnblogs.com)，我曾经很依赖于图片识别，直到我开始写博客 Markdown 语法速查表 | Markdown 官方教程，有时要输什么会不记得 emoji-cheat-sheet，emoji列表😏,虽然一般不会专门去查。 在线LaTeX公式编辑器-编辑器，可以图片识别，我曾经很喜欢，现在不用了","categories":[{"name":"杂","slug":"杂","permalink":"https://yzs020220.github.io/categories/%E6%9D%82/"}],"tags":[{"name":"杂","slug":"杂","permalink":"https://yzs020220.github.io/tags/%E6%9D%82/"},{"name":"自用","slug":"自用","permalink":"https://yzs020220.github.io/tags/%E8%87%AA%E7%94%A8/"}]},{"title":"Hexo评论系统对比推荐","slug":"hexo评论系统对比","date":"2023-02-01T09:14:29.000Z","updated":"2023-03-03T05:45:46.569Z","comments":true,"path":"posts/44102/","link":"","permalink":"https://yzs020220.github.io/posts/44102/","excerpt":"本篇包含Giscus, Utterances, Gitalk, Gitment, Waline, Twikoo, Valine。","text":"本篇包含Giscus, Utterances, Gitalk, Gitment, Waline, Twikoo, Valine。 写在前面 如何选择评论系统毫无疑问是困扰不少hexo使用者的问题，然而关于这个问题，很多博客可能写在了非常早的时间，每个人的使用场景也不太一样，我将会根据自己所使用过的几个评论系统进行对比，并且给出自己的偏好(从更推荐到不推荐)。 我没有使用过需要第三方服务的，我觉得为了评论注册一个帐号颇为繁琐，更何况国内的基本需要备案 Github全家桶 我相信用hexo的有很大部分人都是使用hexo+github pages来部署博客的，也不是所有人都会专门买域名和服务器，那么白嫖github的资源当然直接白嫖到底了，而且大部分使用github的评论系统部署起来都非常方便。最为重要的，是其他的大部分评论系统经常需要代理，而基于github的评论系统在大多数情况下都能够正常地使用。 Giscus 目前在用的评论系统，非常推荐。 基于github discussions 具有在Github全家桶中独一无二的文章反应功能(可选) 支持自定义主题，官方提供的自定义主题还挺符合Fluid的深色配色 授权合理，只需授权giscus app代表他本人发帖即可 支持直接在评论下回复并对评论进行反应 Utterances giscus的前辈，还是giscus好用，但它的诞生解决了gitalk的授权问题。 基于github issues 支持自定义主题 授权合理，只需授权utterances app即可 支持对评论进行反应 Gitalk 不推荐，授权权限太高了，甚至允许网站拥有者对评论者的repo进行更改，如果遇到使用gitalk的博客，也请三思是否登录。 基于github issues Gitment 不可用，Gitment已经停止维护了，然而在网上搜却总是先跳出来Gitment，Gitment也与Gitalk类似。 基于LeanCloud或Vercel，或需要Docker Vercel是多么好的东西啊，可惜Vercel.app被污染了所以导致它在国内被墙了，所以使用Vercel的评论系统都需要翻墙或者使用二级域名，LeanCloud国际版在国内是无法使用的，国内版又要备案。这里提到的评论系统都不需要登录，邮箱仅仅用于获取头像。 Waline valine进化版，如果以后我有自己的域名，我一定会选择它(很全面，就不一一细说了)。 非常方便的支持表情库添加(贴吧表情是我的最爱)，每个表情库下还有按钮分门别类，表情仓库可以看hanasaki-misaki/Waline-emoji，里面还有脚本支持自己添加表情包，引用请查看创建自己的表情预设 | Waline 文章反应(是因为waline有这个功能才养刁了我的品味，还默认是贴吧表情太棒了) 支持评论回复功能 Twikoo 基于腾讯云有很不错的支持，有腾讯云服务器可以考虑使用，界面也挺美观的。 除了没有文章反应基本与Waline相同 Valine Waline的前身，还是Waline好用点。 个人选择 由于个人没有服务器没有域名，只能当白嫖党，又希望评论系统能从国内访问，所以就选择了github全家桶的Giscus。如果不介意只能从国内访问，那么Waline+Vercel+LeanCloud也是免费的。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://yzs020220.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yzs020220.github.io/tags/Hexo/"},{"name":"折腾","slug":"折腾","permalink":"https://yzs020220.github.io/tags/%E6%8A%98%E8%85%BE/"}]},{"title":"最优化方法例题解法","slug":"最优化方法例题解法","date":"2023-01-30T09:21:45.000Z","updated":"2023-03-08T05:36:52.107Z","comments":true,"path":"posts/60607/","link":"","permalink":"https://yzs020220.github.io/posts/60607/","excerpt":"简略记录了例题以及解法，没事，李老师会预判你的预判，自求多福","text":"简略记录了例题以及解法，没事，李老师会预判你的预判，自求多福 Chapter1 利润最大化问题(没考) 步骤如下： 将最大化问题与条件转换为矩阵形式，如： max 40x1+50x2 s.t. x1+2x2≤40max \\space 40x_1+50x_2 \\space s.t. \\space x_1 + 2x_2 \\le 40 max 40x1​+50x2​ s.t. x1​+2x2​≤40 变成 令x=[x1x2],a=[4050],b=[12]令x=\\begin{bmatrix} x_1 \\\\ x_2\\end{bmatrix}, a=\\begin{bmatrix} 40 \\\\ 50\\end{bmatrix}, b=\\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix} 令x=[x1​x2​​],a=[4050​],b=[12​] max aTx s.t. bTx≤40max \\space a^T x \\space s.t. \\space b^Tx \\le 40 max aTx s.t. bTx≤40 使用线性规划法求解问题，画出坐标图 最大化y=aTxy=a^Txy=aTx即最大化该直线的截距，找到直线经过的最高点并计算出此时的最优解。 Chapter2 判断是否为线性函数(没考) 两条性质： 齐次性（homogeneity）：f(kx)=kf(x)f(kx)=kf(x)f(kx)=kf(x) 叠加性（Additivity）：f(x+y)=f(x)+f(y)f(x+y)=f(x)+f(y)f(x+y)=f(x)+f(y) 验证或找到反例即可 反例可先判断其不为仿射函数（一个线性函数加上常数）： f(αx+βy)=αf(x)+βf(y), α+β=1,α,β∈R,x,y∈Rnf(\\alpha x + \\beta y)=\\alpha f(x) + \\beta f(y), \\space \\alpha + \\beta =1,\\alpha, \\beta \\in \\mathbb{R},x,y \\in \\mathbb{R} ^n f(αx+βy)=αf(x)+βf(y), α+β=1,α,β∈R,x,y∈Rn 求一阶泰勒近似(考了) 代公式就好 f^(x)=f(z)+∇f(z)T(x−z)∇f(z)=[∂f∂x1(z)⋮∂f∂xn(z)]\\hat{f}(x)=f(z)+\\nabla f(z)^T(x-z) \\\\ \\nabla f(z)=\\begin{bmatrix} \\frac{\\partial f}{\\partial x_1}(z) \\\\ \\vdots \\\\ \\frac{\\partial f}{\\partial x_n}(z) \\end{bmatrix} f^​(x)=f(z)+∇f(z)T(x−z)∇f(z)=⎣⎢⎢⎡​∂x1​∂f​(z)⋮∂xn​∂f​(z)​⎦⎥⎥⎤​ Chapter3 写出各种范数(考了，送分) ℓ1\\ell_1ℓ1​-范数（曼哈顿范数） ∣∣x∣∣1=∣x1∣+∣x2∣+⋯+∣xn∣,x,y∈Rn,α∈R||x||_1=|x_1|+|x_2|+ \\cdots +|x_n|,x,y \\in \\bold{R}^n,\\alpha \\in \\bold{R} ∣∣x∣∣1​=∣x1​∣+∣x2​∣+⋯+∣xn​∣,x,y∈Rn,α∈R ℓ2\\ell_2ℓ2​-范数（欧几里得范数，一般的∣∣⋅∣∣||\\cdot||∣∣⋅∣∣也是） ∣∣x∣∣2=(x12+x22+⋯+xn2)=xTx=(⟨x,x⟩)12||x||_2=\\sqrt{(x_1^2+x_2^2+ \\cdots +x_n^2)}=\\sqrt{x^Tx}=(\\langle x,x \\rangle )^\\frac{1}{2} ∣∣x∣∣2​=(x12​+x22​+⋯+xn2​)​=xTx​=(⟨x,x⟩)21​ ℓp\\ell_pℓp​-范数 ∣∣x∣∣p=(∣x1∣p+∣x2∣p+⋯+∣xn∣p)1p,x∈Rn||x||_p=(|x_1|^p+|x_2|^p+\\cdots+|x_n|^p)^\\frac{1}{p},x \\in \\mathbb{R}^n ∣∣x∣∣p​=(∣x1​∣p+∣x2​∣p+⋯+∣xn​∣p)p1​,x∈Rn ℓ∞\\ell_\\infinℓ∞​-范数 ∣∣x∣∣∞=max⁡1≤i≤n∣xi∣,x∈Rn||x||_\\infin = \\max_{1 \\le i \\le n} |x_i|,x \\in \\bold{R}^n ∣∣x∣∣∞​=1≤i≤nmax​∣xi​∣,x∈Rn ℓ0\\ell_0ℓ0​-范数 （非0元素的个数） ∣∣x∣∣0=nnz(x)||x||_0=nnz(x) ∣∣x∣∣0​=nnz(x) 柯西-施瓦茨不等式 可用于证明ℓ2\\ell_2ℓ2​-范数的三角不等性 ∣⟨x,y⟩∣2≤⟨x,x⟩⟨y,y⟩=∣∣x∣∣22∣∣y∣∣22|\\langle x,y \\rangle |^2 \\le \\langle x,x \\rangle \\langle y,y \\rangle = ||x||_2^2 ||y||_2^2 ∣⟨x,y⟩∣2≤⟨x,x⟩⟨y,y⟩=∣∣x∣∣22​∣∣y∣∣22​ Minkowshi不等式 可用于证明ℓp\\ell_pℓp​-范数的三角不等性 (∑i=1n∣xi+yi∣p)1p≤(∑i=1n∣xi∣p)1p+(∑i=1n∣yi∣p)1p,p≥1,x,y∈Rn(\\sum_{i=1}^n |x_i+y_i|^p)^\\frac{1}{p} \\le (\\sum_{i=1}^n|x_i|^p)^\\frac{1}{p} + (\\sum_{i=1}^n|y_i|^p)^\\frac{1}{p},p \\ge 1, x,y \\in \\bold{R}^n (i=1∑n​∣xi​+yi​∣p)p1​≤(i=1∑n​∣xi​∣p)p1​+(i=1∑n​∣yi​∣p)p1​,p≥1,x,y∈Rn Hölder不等式 ∑i=1n∣xiyi∣≤(∑i=1n∣xi∣p)1p(∑i=1n∣yi∣p)1p,1p+1q=1,1\\sum_{i=1}^n |x_iy_i| \\le (\\sum_{i=1}^n|x_i|^p)^\\frac{1}{p} (\\sum_{i=1}^n|y_i|^p)^\\frac{1}{p},\\frac{1}{p}+\\frac{1}{q}=1,1 i=1∑n​∣xi​yi​∣≤(i=1∑n​∣xi​∣p)p1​(i=1∑n​∣yi​∣p)p1​,p1​+q1​=1,1 判断是否为范数 非负性：∣∣x∣∣≥0,x∈Rn且∣∣x∣∣=0⇔x=0||x|| \\ge 0,x\\in \\mathbb{R}^n 且 ||x||=0 \\Leftrightarrow x=0∣∣x∣∣≥0,x∈Rn且∣∣x∣∣=0⇔x=0 齐次性：∣∣αx∣∣=∣α∣∣∣x∣∣,α∈R且x∈Rn||\\alpha x||=|\\alpha|||x||,\\alpha \\in \\mathbb{R}且x \\in \\mathbb{R}^n∣∣αx∣∣=∣α∣∣∣x∣∣,α∈R且x∈Rn 三角不等性：∣∣x+y∣∣≤∣∣x∣∣+∣∣y∣∣,x,y∈Rn||x+y|| \\le ||x||+||y||,x,y \\in \\mathbb{R}^n∣∣x+y∣∣≤∣∣x∣∣+∣∣y∣∣,x,y∈Rn 特殊范数的三角不等性 ℓ2\\ell_2ℓ2​-范数需要使用柯西-施瓦茨不等式 ∣∣x+y∣∣22=⟨x+y,x+y⟩=⟨x,x⟩+⟨x,y⟩+⟨y,x⟩+⟨y,y⟩=∣∣x∣∣22+2⟨x,y⟩+∣∣y∣∣22≤∣∣x∣∣22+2∣∣x∣∣2∣∣y∣∣2+∣∣y∣∣22=(∣∣x∣∣2+∣∣y∣∣2)2\\begin{aligned}||x+y||_2^2 &amp;=\\langle x+y,x+y \\rangle \\\\ &amp;= \\langle x,x \\rangle + \\langle x,y \\rangle + \\langle y,x \\rangle + \\langle y,y \\rangle \\\\ &amp;= ||x||_2^2 + 2 \\red {\\langle x,y \\rangle} + ||y||_2^2 \\\\ &amp; \\le ||x||_2^2 + 2\\red{||x||_2||y||_2}+ ||y||_2^2 \\\\ &amp;= (||x||_2+||y||_2)^2\\end{aligned} ∣∣x+y∣∣22​​=⟨x+y,x+y⟩=⟨x,x⟩+⟨x,y⟩+⟨y,x⟩+⟨y,y⟩=∣∣x∣∣22​+2⟨x,y⟩+∣∣y∣∣22​≤∣∣x∣∣22​+2∣∣x∣∣2​∣∣y∣∣2​+∣∣y∣∣22​=(∣∣x∣∣2​+∣∣y∣∣2​)2​ 则∣∣x+y∣∣2≤∣∣x∣∣2+∣∣y∣∣2||x+y||_2 \\le ||x||_2+||y||_2∣∣x+y∣∣2​≤∣∣x∣∣2​+∣∣y∣∣2​得证 ℓp\\ell_pℓp​-范数使用Minkowshi不等式可直接证明 (∑i=1n∣xi+yi∣p)1p≤(∑i=1n∣xi∣p)1p+(∑i=1n∣yi∣p)1p,p≥1,x,y∈Rn(\\sum_{i=1}^n |x_i+y_i|^p)^\\frac{1}{p} \\le (\\sum_{i=1}^n|x_i|^p)^\\frac{1}{p} + (\\sum_{i=1}^n|y_i|^p)^\\frac{1}{p},p \\ge 1, x,y \\in \\bold{R}^n (i=1∑n​∣xi​+yi​∣p)p1​≤(i=1∑n​∣xi​∣p)p1​+(i=1∑n​∣yi​∣p)p1​,p≥1,x,y∈Rn Chapter4 证明一个函数是凸函数(考了复合函数，做不出来) 证明： f(αx+(1−α)y)≤αf(x)+(1−α)f(y),∀x,y∈Ω,α∈R,0≤α≤1f(\\alpha x + (1-\\alpha )y) \\le \\alpha f(x) + (1-\\alpha) f(y), \\\\ \\forall x,y \\in \\Omega,\\alpha \\in \\bold R, 0\\le\\alpha\\le 1 f(αx+(1−α)y)≤αf(x)+(1−α)f(y),∀x,y∈Ω,α∈R,0≤α≤1 证明引理(好像是附加题，反正做不到) 可微函数fff是凸函数的充要条件： f(y)≥f(x)+⟨∇f(x),y−x⟩,∀x,yf(y) \\ge f(x) + \\langle \\nabla f(x), y-x \\rangle , \\forall x,y f(y)≥f(x)+⟨∇f(x),y−x⟩,∀x,y n=1(一维情况) 可微函数fff是凸函数是式子的充分条件： 根据函数fff是凸函数可得： f(x+t(y−x))=f((1−t)x+ty)≤(1−t)f(x)+tf(y)f(x+t(y-x))=f((1-t)x+ty) \\le (1-t)f(x)+tf(y) f(x+t(y−x))=f((1−t)x+ty)≤(1−t)f(x)+tf(y) 上式两端同除ttt可得： f(y)≥f(x)+f(x+t(y−x))−f(x)tf(y) \\ge f(x) + \\frac{f(x+t(y-x))-f(x)}{t} f(y)≥f(x)+tf(x+t(y−x))−f(x)​ 令t→0t\\to 0t→0，得证(得到式子) 可微函数fff是凸函数是式子的必要条件： 令z=αx+(1−α)x,0≤α≤1z=\\alpha x + (1-\\alpha)x,0\\le \\alpha \\le 1z=αx+(1−α)x,0≤α≤1，根据式子可得： f(x)≥f(z)+f′(z)(x−z), f(y)≥f(z)+f′(z)(y−z)f(x) \\ge f(z)+f&#x27;(z)(x-z), \\ f(y) \\ge f(z)+f&#x27;(z)(y-z) f(x)≥f(z)+f′(z)(x−z), f(y)≥f(z)+f′(z)(y−z) 将第一个不等式乘以α\\alphaα，第二个不等式乘以1−α1-\\alpha1−α，并将两者相加即可得： αf(x)+(1−α)f(y)≥f(z)\\alpha f(x) + (1-\\alpha)f(y) \\ge f(z) αf(x)+(1−α)f(y)≥f(z) 即可得到函数fff是凸的 n&gt;1(一般情况) 令 g(t)=f(ty+(1−t)x),g′(t)=∇f(ty+(1−t)x)T(y−x)g(t)=f(ty+(1-t)x), \\\\ g&#x27;(t)=\\nabla f(ty+(1-t)x)^T(y-x) g(t)=f(ty+(1−t)x),g′(t)=∇f(ty+(1−t)x)T(y−x) 可微函数fff是凸函数是式子的充分条件： 由于函数fff是凸的，所以函数ggg是凸的。满足 g(1)≥g(0)+g′(0)(1−0)g(1) \\ge g(0) + g&#x27;(0)(1-0) g(1)≥g(0)+g′(0)(1−0) 即 f(y)≥f(x)+∇f(x)T(y−x)f(y)\\ge f(x)+\\nabla f(x)^T(y-x) f(y)≥f(x)+∇f(x)T(y−x) 可微函数fff是凸函数是式子的必要条件： 令ty+(1−t)x∈domf,tˉy+(1−tˉ)x∈domfty+(1-t)x \\in \\bold{dom} f,\\bar ty+(1-\\bar t)x \\in \\bold{dom} fty+(1−t)x∈domf,tˉy+(1−tˉ)x∈domf，根据式子可得： f(ty+(1−t)x)≥f(tˉy+(1−tˉ)x)+∇f(tˉy+(1−tˉ)x)T(y−x)(t−tˉ)f(ty+(1-t)x)\\ge f(\\bar ty+(1-\\bar t)x) + \\nabla f(\\bar ty+(1-\\bar t)x)^T(y-x)(t-\\bar t) f(ty+(1−t)x)≥f(tˉy+(1−tˉ)x)+∇f(tˉy+(1−tˉ)x)T(y−x)(t−tˉ) 即g(t)≥g(tˉ)+g′(tˉ)(t−tˉ)g(t)\\ge g(\\bar t) + g&#x27;(\\bar t)(t-\\bar t)g(t)≥g(tˉ)+g′(tˉ)(t−tˉ)，说明函数ggg是凸的 Chapter5 标准正交分解 a1,⋯ ,ana_1,\\cdots, a_na1​,⋯,an​是n维向量的一个标准正交基，对于任意n维向量x： x=(a1Tx)a1+⋯+(anTx)anx=(a_1^Tx)a_1+\\cdots+(a_n^Tx)a_n x=(a1T​x)a1​+⋯+(anT​x)an​ 则称其为x在标准正交基下的标准正交分解 Gram-Schmidt(正交化)算法(考了) 反复操作直到i=ni=ni=n qi~=ai−(q1Tai)q1−⋯−(qi−1Tai)qi−1\\tilde{q_i}=a_i-(q_1^Ta_i)q_1-\\cdots-(q_{i-1}^Ta_i)q_{i-1} qi​~​=ai​−(q1T​ai​)q1​−⋯−(qi−1T​ai​)qi−1​ qi=qi~∣∣qi~∣∣2q_i=\\frac{\\tilde{q_i}}{||\\tilde{q_i}||_2} qi​=∣∣qi​~​∣∣2​qi​~​​ Chapter6 主要是矩阵运算，注意定义与维度以及有时需要将矩阵拆成向量进行运算即可 Chapter7 是否存在左逆(考了) 若矩阵AAA的列向量线性无关(先看维度)，则存在左逆： A+=(ATA)−1ATA^+=(A^TA)^{-1}A^T A+=(ATA)−1AT 使得 A+A=(ATA)−1ATA=(ATA)−1(ATA)=IA^+A=(A^TA)^{-1}A^TA=(A^TA)^{-1}(A^TA)=I A+A=(ATA)−1ATA=(ATA)−1(ATA)=I 是否存在右逆(考了) 若矩阵AAA的行向量线性无关(先看维度)，则存在右逆： A†=AT(AAT)−1A^\\dagger=A^T(AA^T)^{-1} A†=AT(AAT)−1 使得 AA†=AAT(AAT)−1=(AAT)−1(AAT)=IAA^\\dagger=AA^T(AA^T)^{-1}=(AA^T)^{-1}(AA^T)=I AA†=AAT(AAT)−1=(AAT)−1(AAT)=I 是否存在逆(考了) 存在左逆(或右逆)，若矩阵为方阵，则存在逆矩阵 Chapter8 判断是否为正交矩阵(算考了) 矩阵A需满足： ATA=IA是方的}⇒AAT=I\\left. \\begin{aligned} A^TA=I \\\\ A是方的 \\end{aligned}\\right \\} \\Rightarrow AA^T=I ATA=IA是方的​}⇒AAT=I Chapter9 QR分解(考了) 如果矩阵A∈Rm×nA\\in \\R^{m\\times n}A∈Rm×n的列向量线性无关，则可以分解为一组标准正交向量QQQ与上三角矩阵RRR A=[a1a2⋯an]=[q1q2⋯qn][R11R12⋯R1n0R22⋯R2n⋮⋮⋱⋮00⋯Rnn]=QR\\begin{aligned} A&amp;=\\begin{bmatrix}a_1&amp; a_2&amp; \\cdots &amp; a_n\\end{bmatrix} \\\\ &amp;=\\begin{bmatrix}q_1&amp; q_2&amp; \\cdots &amp; q_n \\end{bmatrix} \\begin{bmatrix} R_{11}&amp; R_{12}&amp; \\cdots &amp; R_{1n} \\\\ 0&amp; R_{22} &amp; \\cdots &amp; R_{2n} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; \\cdots &amp; R_{nn} \\end{bmatrix} \\\\ &amp;= QR \\end{aligned} A​=[a1​​a2​​⋯​an​​]=[q1​​q2​​⋯​qn​​]⎣⎢⎢⎢⎢⎡​R11​0⋮0​R12​R22​⋮0​⋯⋯⋱⋯​R1n​R2n​⋮Rnn​​⎦⎥⎥⎥⎥⎤​=QR​ Gram-Schmidt正交化 qi~=a−(q1Tai)q1−⋯−(qi−1Tai)qi−1\\tilde{q_i}=a_-(q_1^Ta_i)q_1-\\cdots-(q_{i-1}^Ta_i)q_{i-1} qi​~​=a−​(q1T​ai​)q1​−⋯−(qi−1T​ai​)qi−1​ Rji=(qjTai)R_{ji}=(q_j^Ta_i) Rji​=(qjT​ai​) 一般要求Rii&gt;0R_{ii}&gt;0Rii​&gt;0使得QQQ和RRR是唯一的 使用QR分解求逆(考了) 具有线性无关列向量的矩阵AAA的伪逆为 A+=(ATA)−1ATA^+=(A^TA)^{-1}A^T A+=(ATA)−1AT 将AAA的伪逆表示为QR因子： A+=((QR)T(QR))−1(QR)T=(RTQTQR)−1RTQT=(RTR)−1RTQT=R−1R−TRTQT=R−1QT\\begin{aligned} A^+&amp;= \\left( (QR)^T(QR) \\right)^{-1}(QR)^T \\\\ &amp;= (R^TQ^TQR)^{-1}R^TQ^T \\\\ &amp;= (R^TR)^{-1}R^TQ^T \\\\ &amp;= R^{-1}R^{-T}R^TQ^T \\\\ &amp;= R^{-1}Q^T \\end{aligned} A+​=((QR)T(QR))−1(QR)T=(RTQTQR)−1RTQT=(RTR)−1RTQT=R−1R−TRTQT=R−1QT​ 对于方阵非奇异矩阵AAA，其逆为： A−1=(QR)−1=R−1QTA^{-1}=(QR)^{-1}=R^{-1}Q^T A−1=(QR)−1=R−1QT 矩阵RRR为上三角矩阵，设x=R−1x=R^{-1}x=R−1，使用前向回代法求解xR=IxR=IxR=I或使用后向回代法求解Rx=IRx=IRx=I Chapter10 LU分解(可能考了，但我没用) LLL为上三角矩阵且对角线元素全为1，UUU为上三角矩阵 A=LUA=LU A=LU 矩阵UUU的第一行元素： u1j=a1j,j=1,⋯ ,nu_{1j}=a_{1j},j=1,\\cdots,n u1j​=a1j​,j=1,⋯,n 矩阵LLL的第一列元素： li1=ai1u11,i=2,3,⋯ ,nl_{i1}=\\frac{a_{i1}}{u_{11}},i=2,3,\\cdots,n li1​=u11​ai1​​,i=2,3,⋯,n 从r=2r=2r=2开始直到r=nr=nr=n 矩阵UUU第r行主对角线以右元素urju_{rj}urj​ urj=arj−∑k=1r−1lrkukj,j=r,⋯ ,nu_{rj}=a_{rj}-\\sum_{k=1}^{r-1}l_{rk}u_{kj},j=r,\\cdots,n urj​=arj​−k=1∑r−1​lrk​ukj​,j=r,⋯,n 矩阵LLL第r列主对角线以下元素lirl_{ir}lir​ lir=(air−∑k=1r−1likukr)/urr,i=r+1,⋯ ,nl_{ir}=\\left(a_{ir}- \\sum_{k=1}^{r-1} l_{ik}u_{kr} \\right)/u_{rr},i=r+1,\\cdots,n lir​=(air​−k=1∑r−1​lik​ukr​)/urr​,i=r+1,⋯,n LU分解求解方程组 例： (2100−3−3−4−1213123−44149−13)(x1x2x3x4)=(105−27)\\begin{pmatrix} 2 &amp; 10 &amp;0 &amp; -3 \\\\ -3 &amp; -4 &amp; -12 &amp; 13 \\\\ 1 &amp; 2 &amp;3 &amp; -4 \\\\ 4 &amp; 14 &amp; 9 &amp;-13 \\end{pmatrix} \\begin{pmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\ x_4 \\end{pmatrix}=\\begin{pmatrix} 10 \\\\ 5 \\\\ -2 \\\\ 7 \\end{pmatrix} ⎝⎜⎜⎜⎛​2−314​10−4214​0−1239​−313−4−13​⎠⎟⎟⎟⎞​⎝⎜⎜⎜⎛​x1​x2​x3​x4​​⎠⎟⎟⎟⎞​=⎝⎜⎜⎜⎛​105−27​⎠⎟⎟⎟⎞​ 解： 对矩阵AAA进行LULULU分解： A=(2100−3−3−4−1213123−44149−13)A=\\begin{pmatrix} 2 &amp; 10 &amp;0 &amp; -3 \\\\ -3 &amp; -4 &amp; -12 &amp; 13 \\\\ 1 &amp; 2 &amp;3 &amp; -4 \\\\ 4 &amp; 14 &amp; 9 &amp;-13 \\end{pmatrix} A=⎝⎜⎜⎜⎛​2−314​10−4214​0−1239​−313−4−13​⎠⎟⎟⎟⎞​ L=(1000−3210012−311102−611−91), U=(2100−3011−1217200−311−211000−4)L=\\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ -\\frac 3 2 &amp; 1 &amp; 0 &amp; 0 \\\\ \\frac 1 2 &amp; -\\frac 3 {11}&amp; 1 &amp; 0 \\\\ 2 &amp;-\\frac 6 {11} &amp; -9 &amp; 1 \\end{pmatrix}, \\ U = \\begin{pmatrix} 2 &amp; 10 &amp; 0 &amp; -3 \\\\ 0 &amp; 11 &amp; -12 &amp; \\frac {17} 2 \\\\ 0 &amp; 0 &amp; -\\frac 3 {11} &amp; -\\frac 2 {11} \\\\ 0 &amp; 0 &amp; 0 &amp; -4 \\end{pmatrix} L=⎝⎜⎜⎜⎛​1−23​21​2​01−113​−116​​001−9​0001​⎠⎟⎟⎟⎞​, U=⎝⎜⎜⎜⎛​2000​101100​0−12−113​0​−3217​−112​−4​⎠⎟⎟⎟⎞​ 前向回代法求解yyy： LUx=Ly=b=(105−27)⇒y=(1020−1711−16)LUx=Ly=b=\\begin{pmatrix} 10 \\\\ 5 \\\\ -2 \\\\ 7 \\end{pmatrix} \\Rightarrow y=\\begin{pmatrix} 10 \\\\ 20 \\\\ -\\frac{17}{11} \\\\ -16\\end{pmatrix} LUx=Ly=b=⎝⎜⎜⎜⎛​105−27​⎠⎟⎟⎟⎞​⇒y=⎝⎜⎜⎜⎛​1020−1117​−16​⎠⎟⎟⎟⎞​ 后向回代法求解xxx： Ux=y⇒x=(1234)Ux=y \\Rightarrow x= \\begin{pmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 4 \\end{pmatrix} Ux=y⇒x=⎝⎜⎜⎜⎛​1234​⎠⎟⎟⎟⎞​ Chapter11 最小二乘法的性质(考了，跟投影一起考) 要求： x^=arg min⁡x∣∣Ax−b∣∣22\\hat x = \\argmin_x ||Ax-b||_2^2 x^=xargmin​∣∣Ax−b∣∣22​ 当矩阵AAA列线性无关时，有 ATAx^=ATbA^TA\\hat x=A^Tb ATAx^=ATb 不能直接得出x^=A−1b\\hat x = A^{-1}bx^=A−1b，AAA很多时候不可右逆(因为可能是高矩阵)： x^=A+b=(ATA)−1ATb\\hat x = A^+ b = (A^TA)^{-1}A^Tb x^=A+b=(ATA)−1ATb QR分解求解正规方程(考了) 若矩阵AAA列向量线性无关，则最小二乘法问题的解： x^=(ATA)−1ATb=(RTQTQR)−1RTQTb=(RTR)−1RTQTb=R−1QTb\\begin{aligned} \\hat x &amp;= (A^TA)^{-1}A^Tb \\\\ &amp;= (R^TQ^TQR)^{-1} R^TQ^Tb \\\\ &amp;= (R^TR)^{-1}R^TQ^Tb \\\\ &amp;= R^{-1}Q^Tb \\end{aligned} x^​=(ATA)−1ATb=(RTQTQR)−1RTQTb=(RTR)−1RTQTb=R−1QTb​ 可能会用式子x^=R−1QTb\\hat x = R^{-1} Q^Tbx^=R−1QTb进行计算 流程： 对矩阵AAA进行QR分解 计算矩阵向量乘积d=QTbd=Q^Tbd=QTb 通过回代法求解Rx=dRx=dRx=d Chapter13 KKT条件(利润最大化)(考了等式约束) 如果是max的话，式子化为g(x)≤0g(x)\\le0g(x)≤0的形式，min的话式子化为g(x)≥0g(x)\\ge0g(x)≥0，拉格朗日函数用减号：−-− max⁡x1,x2{40x1+50x2}s.t.x1+2x2≤40,4x1+3x2≤120,x1≥0,x2≥0\\max_{x_1,x_2}\\left \\{40x_1+50x_2 \\right \\}\\\\ s.t. \\quad x_1+2x_2 \\le 40,4x_1+3x_2\\le120,x_1\\ge0,x_2\\ge0 x1​,x2​max​{40x1​+50x2​}s.t.x1​+2x2​≤40,4x1​+3x2​≤120,x1​≥0,x2​≥0 构造f(x)f(x)f(x)与g(x)g(x)g(x)(注意g(x)≤0g(x)\\le0g(x)≤0)： x=[x1x2],max⁡x{f(x)=40x1+50x2}s.t.g1(x)=x1+2x2−40≤0,g2(x)=4x1+3x2−120≤0,g3(x)=−x1≤0,g4(x)=−x2≤0x=\\begin{bmatrix} x_1 \\\\ x_2 \\end{bmatrix} , \\max_x \\left \\{ f(x) = 40x_1+50x_2 \\right \\} \\\\ \\begin{aligned} s.t.\\quad &amp;g_1(x)=x_1+2x_2-40\\le 0, g_2(x)=4x_1+3x_2-120 \\le 0, \\\\ &amp; g_3(x)=-x_1 \\le 0,g_4(x)=-x_2 \\le 0 \\end{aligned} x=[x1​x2​​],xmax​{f(x)=40x1​+50x2​}s.t.​g1​(x)=x1​+2x2​−40≤0,g2​(x)=4x1​+3x2​−120≤0,g3​(x)=−x1​≤0,g4​(x)=−x2​≤0​ 引入拉格朗日函数： L(x,u)=f(x)−u1g1(x)−u2g2(x)−u3g3(x)−u4g4(x)L(x,u)=f(x)-u_1g_1(x)-u_2g_2(x)-u_3g_3(x)-u_4g_4(x) L(x,u)=f(x)−u1​g1​(x)−u2​g2​(x)−u3​g3​(x)−u4​g4​(x) 对拉格朗日函数求偏导： ∇xL(x,u)=∇xf(x)−u1∇xg1(x)−u2∇xg2(x)−u3∇xg3(x)−u4∇xg4(x)=0,uj≥0∇xf(x)=[4050],∇xg1(x)=[12],∇xg2(x)=[43],∇xg3(x)=[−10],∇xg4(x)=[0−1]\\begin{aligned} &amp;\\nabla_xL(x,u)=\\nabla_xf(x)-u_1\\nabla_xg_1(x)-u_2\\nabla_xg_2(x)-u_3\\nabla_xg_3(x)-u_4\\nabla_xg_4(x)=0,u_j\\ge0 \\\\ &amp;\\nabla_xf(x)=\\begin{bmatrix} 40 \\\\ 50 \\end{bmatrix}, \\nabla_xg_1(x)=\\begin{bmatrix}1 \\\\ 2 \\end{bmatrix}, \\nabla_xg_2(x)=\\begin{bmatrix}4 \\\\ 3 \\end{bmatrix}, \\nabla_xg_3(x)=\\begin{bmatrix}-1 \\\\ 0 \\end{bmatrix}, \\nabla_xg_4(x)=\\begin{bmatrix}0 \\\\ -1 \\end{bmatrix} \\end{aligned} ​∇x​L(x,u)=∇x​f(x)−u1​∇x​g1​(x)−u2​∇x​g2​(x)−u3​∇x​g3​(x)−u4​∇x​g4​(x)=0,uj​≥0∇x​f(x)=[4050​],∇x​g1​(x)=[12​],∇x​g2​(x)=[43​],∇x​g3​(x)=[−10​],∇x​g4​(x)=[0−1​]​ 对x求偏导，得到KKT方程组： {∂L∂x1=40−u1−4u2+u3=0∂L∂x2=50−2u1−3u2+u4=0x1+2x2−40≤04x1+3x2−120≤0−x1≤0−x2≤0uj=1,2,3,4≥0∑j=1,2,3,4ujgj(x)=0\\begin{cases} \\frac{\\partial L}{\\partial x_1} = 40 - u_1 - 4u_2 + u_3 = 0 \\\\ \\frac{\\partial L}{\\partial x_2} = 50 - 2u_1 - 3u_2 + u_4 = 0 \\\\ x_1+2x_2-40\\le 0 \\\\ 4x_1+3x_2-120 \\le 0 \\\\ -x_1 \\le 0 \\\\-x_2 \\le 0 \\\\ u_{j=1,2,3,4} \\ge 0 \\\\ \\sum_{j=1,2,3,4} u_jg_j(x) = 0 \\end{cases} ⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​∂x1​∂L​=40−u1​−4u2​+u3​=0∂x2​∂L​=50−2u1​−3u2​+u4​=0x1​+2x2​−40≤04x1​+3x2​−120≤0−x1​≤0−x2​≤0uj=1,2,3,4​≥0∑j=1,2,3,4​uj​gj​(x)=0​ 讨论可能取值(点击展开) 讨论可能的取值：当u1≠0,u2=u3=u4=0u_1\\ne 0,u_2=u_3=u_4=0u1​=0,u2​=u3​=u4​=0时，有{∂L∂x1=40−u1=0∂L∂x2=50−2u1=0\\begin{cases}\\frac{\\partial L}{\\partial x_1} = 40 - u_1 = 0 \\\\\\frac{\\partial L}{\\partial x_2} = 50 - 2u_1 = 0 \\end{cases}{∂x1​∂L​=40−u1​=0∂x2​∂L​=50−2u1​=0​无解，当满足其中一条式子时另外一条不满足当u2≠0,u1=u3=u4=0u_2 \\ne 0,u_1=u_3=u_4=0u2​=0,u1​=u3​=u4​=0时，有{∂L∂x1=40−4u2=0∂L∂x2=50−3u2=0\\begin{cases}\\frac{\\partial L}{\\partial x_1} = 40 - 4u_2 = 0 \\\\\\frac{\\partial L}{\\partial x_2} = 50 - 3u_2 = 0 \\end{cases}{∂x1​∂L​=40−4u2​=0∂x2​∂L​=50−3u2​=0​无解，当满足其中一条式子时另外一条不满足当u3≠0,u1=u2=u4=0u_3 \\ne 0,u_1=u_2=u_4=0u3​=0,u1​=u2​=u4​=0时，有40+u3=040+u_3=040+u3​=0无解当u4≠0,u1=u2=u3=0u_4\\ne0,u_1=u_2=u_3=0u4​=0,u1​=u2​=u3​=0时，有50+u4=050 + u_4=050+u4​=0无解当u1≠0,u2≠0,u3=u4=0u_1\\ne 0,u_2 \\ne 0,u_3=u_4=0u1​=0,u2​=0,u3​=u4​=0，有{∂L∂x1=40−u1−4u2=0∂L∂x2=50−2u1−3u2=0\\begin{cases}\\frac{\\partial L}{\\partial x_1} = 40 - u_1 - 4u_2 = 0 \\\\\\frac{\\partial L}{\\partial x_2} = 50 - 2u_1 - 3u_2 = 0 \\\\\\end{cases}{∂x1​∂L​=40−u1​−4u2​=0∂x2​∂L​=50−2u1​−3u2​=0​解得{u1=16u2=6\\begin{cases}u_1=16 \\\\u_2=6\\end{cases}{u1​=16u2​=6​此时g1(x)=g2(x)=0g_1(x)=g_2(x)=0g1​(x)=g2​(x)=0，解得{x1=24x2=8\\begin{cases}x_1=24 \\\\x_2=8\\end{cases}{x1​=24x2​=8​将解代入KKT条件进行验证，该解可以成立当u1≠0,u3≠0,u2=u4=0u_1\\ne 0,u_3\\ne 0, u_2=u_4=0u1​=0,u3​=0,u2​=u4​=0，有{∂L∂x1=40−u1+u3=0∂L∂x2=50−2u1=0\\begin{cases}\\frac{\\partial L}{\\partial x_1} = 40 - u_1+ u_3 = 0 \\\\\\frac{\\partial L}{\\partial x_2} = 50 - 2u_1= 0 \\\\\\end{cases}{∂x1​∂L​=40−u1​+u3​=0∂x2​∂L​=50−2u1​=0​解得{u1=25u3=−15\\begin{cases}u_1 = 25 \\\\ u_3=-15\\end{cases}{u1​=25u3​=−15​舍去当u1≠0,u4≠0,u2=u3=0u_1\\ne0,u_4\\ne0,u_2=u_3=0u1​=0,u4​=0,u2​=u3​=0，有{∂L∂x1=40−u1=0∂L∂x2=50−2u1+u4=0\\begin{cases}\\frac{\\partial L}{\\partial x_1} = 40 - u_1= 0 \\\\\\frac{\\partial L}{\\partial x_2} = 50 - 2u_1+ u_4 = 0 \\\\\\end{cases}{∂x1​∂L​=40−u1​=0∂x2​∂L​=50−2u1​+u4​=0​解得{u1=40u4=30\\begin{cases}u_1=40 \\\\u_4=30\\end{cases}{u1​=40u4​=30​此时g1(x)=0,g4(x)=0g_1(x)=0,g_4(x)=0g1​(x)=0,g4​(x)=0，解得{x1=40x2=0\\begin{cases}x_1=40 \\\\ x_2=0\\end{cases}{x1​=40x2​=0​将解代入KKT条件验证，不满足所有KKT条件(g2(x)=4x1+3x2−120≰0g_2(x)=4x_1 + 3x_2 -120\\nleq 0g2​(x)=4x1​+3x2​−120≰0)，舍去当u2≠0,u3≠0,u1=u4=0u_2 \\ne 0, u_3 \\ne 0, u_1=u_4=0u2​=0,u3​=0,u1​=u4​=0{∂L∂x1=40−4u2+u3=0∂L∂x2=50−3u2=0\\begin{cases}\\frac{\\partial L}{\\partial x_1} = 40 - 4u_2 + u_3 = 0 \\\\\\frac{\\partial L}{\\partial x_2} = 50 - 3u_2= 0 \\\\\\end{cases}{∂x1​∂L​=40−4u2​+u3​=0∂x2​∂L​=50−3u2​=0​解得{u2=503u3=803\\begin{cases}u_2= \\frac {50}3 \\\\u_3 = \\frac{80} 3\\end{cases}{u2​=350​u3​=380​​此时g2(x)=g3(x)=0g_2(x)=g_3(x)=0g2​(x)=g3​(x)=0，解得{x1=0x2=40\\begin{cases}x_1=0 \\\\x_2= 40\\end{cases}{x1​=0x2​=40​将解代入KKT条件验证，不满足所有KKT条件(g1(x)=x1+2x2−40≰0g_1(x) =x_1+2x_2 -40 \\nleq 0g1​(x)=x1​+2x2​−40≰0)，舍去当u2≠0,u4≠0,u1=u3=0u_2\\ne0,u_4\\ne0,u_1=u_3=0u2​=0,u4​=0,u1​=u3​=0{∂L∂x1=40−4u2=0∂L∂x2=50−3u2+u4=0\\begin{cases}\\frac{\\partial L}{\\partial x_1} = 40 - 4u_2 = 0 \\\\\\frac{\\partial L}{\\partial x_2} = 50 - 3u_2 + u_4 = 0 \\\\\\end{cases}{∂x1​∂L​=40−4u2​=0∂x2​∂L​=50−3u2​+u4​=0​解得{u2=10u4=−20\\begin{cases}u_2=10 \\\\ u_4= -20\\end{cases}{u2​=10u4​=−20​舍去当u3≠0,u4≠0,u1=u2=0u_3\\ne0,u_4\\ne0,u_1=u_2=0u3​=0,u4​=0,u1​=u2​=0{∂L∂x1=40+u3=0∂L∂x2=50+u4=0\\begin{cases}\\frac{\\partial L}{\\partial x_1} = 40+ u_3 = 0 \\\\\\frac{\\partial L}{\\partial x_2} = 50+ u_4 = 0 \\\\\\end{cases}{∂x1​∂L​=40+u3​=0∂x2​∂L​=50+u4​=0​显然无解 综上所述，只有一种情况满足条件 {x1=24x2=8,f(x)=40x1+50x2=1360\\begin{cases}x_1=24 \\\\ x_2=8 \\end{cases}, f(x)=40x_1+50x_2=1360 \\\\ {x1​=24x2​=8​,f(x)=40x1​+50x2​=1360 ∴\\therefore∴最优解为x1=24,x2=8x_1=24,x_2=8x1​=24,x2​=8，最大利润为1360 最小范数优化问题(考了) 一般为单个xxx，否则用yyy换元，一般系数不为12\\frac 1 221​，以下仅为一般形式 min⁡x12∣∣x∣∣22s.t.Cx=d\\min_x \\frac 1 2||x||_2^2 \\quad s.t. \\quad Cx=d xmin​21​∣∣x∣∣22​s.t.Cx=d 矩阵CCC行向量线性无关，存在右逆C†C^\\daggerC†，要求x^\\hat xx^ 引入拉格朗日函数： L(x,λ)=12∣∣x∣∣22−λT(Cx−d)L(x,\\lambda)=\\frac 1 2||x||_2^2-\\lambda^T(Cx-d) L(x,λ)=21​∣∣x∣∣22​−λT(Cx−d) 对拉格朗日函数求偏导得到KKT条件： {∇xL(x,λ)=x−CTλ=0∇λL(x,λ)=Cx−d=0\\begin{cases} \\nabla_xL(x,\\lambda)=x-C^T\\lambda=0 \\\\ \\nabla_\\lambda L(x,\\lambda)=Cx-d=0 \\end{cases} {∇x​L(x,λ)=x−CTλ=0∇λ​L(x,λ)=Cx−d=0​ 由矩阵CCC行向量线性无关可得： Cx=CCTλ=d,λ=(CCT)−1dCx=CC^T\\lambda=d,\\lambda = (CC^T)^{-1}d Cx=CCTλ=d,λ=(CCT)−1d 则有： x^=CTλ=CT(CCT)−1d=C†d\\hat x = C^T \\lambda = C^T (CC^T)^{-1} d = C^\\dagger d x^=CTλ=CT(CCT)−1d=C†d 如果要求确切值需要进行对矩阵CTC^TCT进行QR分解： x^=CT(CCT)−1d=QR(RTQTQR)−1d=QR(RTR)−1d=QR−Td\\begin{aligned} \\hat x &amp;= C^T(CC^T)^{-1}d \\\\ &amp;= QR(R^TQ^TQR)^{-1}d \\\\ &amp;= QR(R^TR)^{-1}d \\\\ &amp;= QR^{-T}d \\end{aligned} x^​=CT(CCT)−1d=QR(RTQTQR)−1d=QR(RTR)−1d=QR−Td​ 回代法求解RTz=dR^Tz=dRTz=d，再计算x^=Qz\\hat x=Qzx^=Qz","categories":[{"name":"学","slug":"学","permalink":"https://yzs020220.github.io/categories/%E5%AD%A6/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://yzs020220.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"自用","slug":"自用","permalink":"https://yzs020220.github.io/tags/%E8%87%AA%E7%94%A8/"}]},{"title":"最优化方法学习笔记","slug":"最优化方法学习笔记","date":"2023-01-30T04:15:21.000Z","updated":"2023-03-03T05:45:46.559Z","comments":true,"path":"posts/54570/","link":"","permalink":"https://yzs020220.github.io/posts/54570/","excerpt":"明年再来，我给你加位。","text":"明年再来，我给你加位。 Chapter1 1.1 向量 向量：一个有序的数字列表 可写成 [−1.10.03.6−7.2]or(−1.10.03.6−7.2)or(−1.1,0.0,3.6,−7.2)\\begin{bmatrix}-1.1 \\\\ 0.0 \\\\ 3.6 \\\\ -7.2\\end{bmatrix} or \\begin{pmatrix}-1.1 \\\\ 0.0 \\\\ 3.6 \\\\ -7.2\\end{pmatrix} or \\begin{pmatrix}-1.1, 0.0, 3.6, -7.2\\end{pmatrix} ⎣⎢⎢⎢⎡​−1.10.03.6−7.2​⎦⎥⎥⎥⎤​or⎝⎜⎜⎜⎛​−1.10.03.6−7.2​⎠⎟⎟⎟⎞​or(−1.1,0.0,3.6,−7.2​) 列表中的数字是元素（项、系数、分量） 元素的数量是向量的大小（维数、长度），大小为n的向量称为n维向量 向量中的数字通常被称作标量 向量默认为列向量 1.1.1 向量的符号表示 aia_iai​中的iii表示为索引，注意：有时i指的是向量列表中的第i个向量 对于所有iii，如果有ai=bia_i=b_iai​=bi​，则称两个相同大小的向量aaa和bbb是相等的，可写成a=ba=ba=b 1.1.2 块向量 块向量a=[bcd]a = \\begin{bmatrix} b \\\\ c \\\\ d \\end{bmatrix}a=⎣⎢⎡​bcd​⎦⎥⎤​具有块项bbb，ccc，ddd 块向量aaa的大小是m+n+pm+n+pm+n+p（各块项的大小之和） 1.1.3 零向量、全一向量和单位向量 零向量：所有项全为0 全一向量：所有项全为1 单位向量：仅有一个元素为1，其余全为0；当第iii项为1，其余项为0时表示为eie_iei​ 1.1.4 稀疏向量 如果一个向量的许多项是0，该向量为稀疏（Sparse）的 nnz(x)nnz(x)nnz(x)是指向量中非零的项数（number of non-zeros），有时用ℓ0\\ell_0ℓ0​表示 例：零向量，单位向量 1.2 数域 有理数 实数 复数 符号 Q\\bold{Q}Q R\\bold{R}R C\\bold{C}C 例 13\\frac{1}{3}31​ π\\piπ 1+i1+i1+i 数的非空集合P，且其中任意两个数的和、差、积、商（除数不为0）仍属于该集合，则称数集P为一个数域。 1.2 向量空间 设VVV是非空子集，PPP是一数域，向量空间VVV满足： 向量加法：V+V→VV+V\\to VV+V→V，即∀x,y∈V,x+y∈V\\forall x,y \\in V, x+y \\in V∀x,y∈V,x+y∈V（加法封闭） 标量乘法：F×V→VF \\times V \\to VF×V→V，即∀x∈V,λ∈P,λx∈v\\forall x \\in V, \\lambda \\in P, \\lambda x \\in v∀x∈V,λ∈P,λx∈v（乘法封闭） 上述两种运算满足如下八条规则 ∀x,y,z∈V,λ,μ∈P:\\forall x,y,z \\in V, \\lambda , \\mu \\in P:∀x,y,z∈V,λ,μ∈P: 交换律：x+y=y+xx+y=y+xx+y=y+x 结合律：x+(y+z)=(x+y)+zx+(y+z)=(x+y)+zx+(y+z)=(x+y)+z VVV存在一个零元素，记作000，x+0=xx+0=xx+0=x 存在xxx的负元素，记作−x-x−x，满足x+(−x)=0x+(-x)=0x+(−x)=0 ∀x∈V,1x=x,1∈P\\forall x \\in V, 1x=x,1 \\in P∀x∈V,1x=x,1∈P λ(μx)=(λμ)x\\lambda ( \\mu x)=( \\lambda \\mu)xλ(μx)=(λμ)x (λ+μ)x=λx+μx( \\lambda + \\mu )x= \\lambda x + \\mu x(λ+μ)x=λx+μx λ(x+y)=λx+λy\\lambda(x+y)=\\lambda x+\\lambda yλ(x+y)=λx+λy 向量空间也被称为线性空间 1.2.1 向量加法的性质 设向量a,b,c∈Va,b,c \\in Va,b,c∈V，VVV是一个向量空间，有： 交换律：a+b=b+aa+b=b+aa+b=b+a 结合律：(a+b)+c=a+(b+c)(a+b)+c=a+(b+c)(a+b)+c=a+(b+c) a+0=0+a=aa+0=0+a=aa+0=0+a=a a−a=0a-a=0a−a=0 1.2.3 一点到另一点的位移 点q\\color{red}{q}q到点p\\color{yellow}{p}p的位移是p−q\\color{yellow}{p} \\color{grey}- \\color{red}{q}p−q，不确定可以找个原点想象一下 1.3 标量与向量的乘法 标量β\\betaβ与n维向量aaa进行相乘（也可表示为aβa\\betaaβ）： βa=[βa1⋮βan]\\beta a = \\begin{bmatrix} \\beta a_1 \\\\ \\vdots \\\\ \\beta a_n\\end{bmatrix} βa=⎣⎢⎢⎡​βa1​⋮βan​​⎦⎥⎥⎤​ 1.3.1 标向量乘法（纯量乘法）的性质 标量β,γ\\beta, \\gammaβ,γ，向量a,ba,ba,b： 结合律：(βγ)a=β(γa)(\\beta \\gamma )a=\\beta(\\gamma a)(βγ)a=β(γa) 左分配律：(β+γ)a=βa+γa(\\beta+\\gamma)a=\\beta a+\\gamma a(β+γ)a=βa+γa 右分配律：β(a+b)=βa+βb\\beta(a+b)=\\beta a+\\beta bβ(a+b)=βa+βb 1.3.2 线性组合 对于向量a1,⋯ ,ama_1, \\cdots , a_ma1​,⋯,am​和标量β1,⋯ ,βm\\beta_1, \\cdots, \\beta_mβ1​,⋯,βm​，β1a1+⋯+βmam\\beta_1 a_1 + \\cdots + \\beta_m a_mβ1​a1​+⋯+βm​am​是向量的线性组合，β1,⋯ ,βm\\beta_1, \\cdots, \\beta_mβ1​,⋯,βm​是该向量的系数 1.4 内积 ⟨a,b⟩=a1b1+a2b2+⋯+anbn=aTb\\langle a, b \\rangle = a_1 b_1+a_2 b_2+\\cdots + a_n b_n = a^T b ⟨a,b⟩=a1​b1​+a2​b2​+⋯+an​bn​=aTb 定义：在数域R\\mathbb{R}R上的向量空间VVV，定义函数⟨⋅,⋅⟩:V×V→R\\langle\\cdot,\\cdot \\rangle:V \\times V \\to \\mathbb{R}⟨⋅,⋅⟩:V×V→R，满足： ⟨a,a⟩≥0,∀a∈V\\langle a, a \\rangle \\ge 0, \\forall a \\in V⟨a,a⟩≥0,∀a∈V，当且仅当a=0时，⟨a,a⟩=0\\langle a, a \\rangle = 0⟨a,a⟩=0 ⟨αa+βb,c⟩=α⟨a,c⟩+β⟨b,c⟩,∀α,β∈R\\langle \\alpha a + \\beta b, c \\rangle = \\alpha \\langle a, c \\rangle + \\beta \\langle b, c \\rangle,\\forall \\alpha, \\beta \\in \\mathbb{R}⟨αa+βb,c⟩=α⟨a,c⟩+β⟨b,c⟩,∀α,β∈R,且a,b,c∈Va,b,c \\in Va,b,c∈V ⟨a,b⟩=⟨b,a⟩,∀a,b∈V\\langle a, b \\rangle = \\langle b, a \\rangle, \\forall a,b \\in V⟨a,b⟩=⟨b,a⟩,∀a,b∈V 则函数⟨⋅,⋅⟩\\langle\\cdot,\\cdot \\rangle⟨⋅,⋅⟩称为内积 1.4.1 内积的性质 交换律：aTb=bTaa^T b=b^T aaTb=bTa 结合律：(γa)Tb=γ(aTb)(\\gamma a)^T b = \\gamma (a^T b)(γa)Tb=γ(aTb) 分配律：(a+b)Tc=aTc+bTc(a+b)^T c = a^T c + b^T c(a+b)Tc=aTc+bTc 1.4.2 常用的内积等式 选出第iii项：eiTa=aie_i^T a = a_ieiT​a=ai​ 向量每一项之和：1Ta=a1+⋯+an\\bold{1}^T a = a_1 + \\cdots + a_n1Ta=a1​+⋯+an​ 向量每一项的平方和：aTa=a12+⋯+an2a^T a = a_1^2+\\cdots +a_n^2aTa=a12​+⋯+an2​ 1.4.3 柯西-施瓦茨不等式(Cauchy-Schwartzn) 设⟨⋅,⋅⟩\\langle\\cdot,\\cdot \\rangle⟨⋅,⋅⟩是向量空间VVV上的内积，∀x,y∈V\\forall x,y \\in V∀x,y∈V，有 ∣⟨x,y⟩∣2≤⟨x,x⟩⟨y,y⟩|\\langle x,y \\rangle |^2 \\le \\langle x,x \\rangle \\langle y,y \\rangle ∣⟨x,y⟩∣2≤⟨x,x⟩⟨y,y⟩ 当x=βy,β∈Rx=\\beta y, \\beta \\in \\mathbb{R}x=βy,β∈R等式成立 Chapter2 2.1 线性函数 线性函数：f:Rn→R.ff: \\mathbb{R}^n \\to \\mathbb{R. f}f:Rn→R.f是一个将n维向量映射成数的函数 线性函数fff满足（k∈R,x,y∈Rnk\\in \\mathbb{R}, x,y \\in \\mathbb{R}^nk∈R,x,y∈Rn）: 齐次性（homogeneity）：f(kx)=kf(x)f(kx)=kf(x)f(kx)=kf(x) 叠加性（Additivity）：f(x+y)=f(x)+f(y)f(x+y)=f(x)+f(y)f(x+y)=f(x)+f(y) 一个函数如果满足这两个性质，就称其为线性函数 2.1.1 内积函数 对于n维向量aaa，满足以下形式的函数成为内积函数（inner product function）： f(x)=aTx=a1x1+a2x2+⋯+anxnf(x)=a^T x=a_1 x_1 + a_2 x_2 + \\cdots + a_n x_n f(x)=aTx=a1​x1​+a2​x2​+⋯+an​xn​ 内积函数都是线性的 2.1.2 所有线性函数都是内积 线性函数表示为内积形式： f(x)=f(x1e1+x2e2+⋯+xnen)=x1f(e1)+x2f(e2)+⋯+xnf(en)\\begin{aligned} f(x)&amp;=f(x_1 e_1 + x_2 e_2 + \\cdots + x_n e_n)\\\\ &amp;= x_1 f(e_1) + x_2 f(e_2) + \\cdots + x_n f(e_n) \\end{aligned} f(x)​=f(x1​e1​+x2​e2​+⋯+xn​en​)=x1​f(e1​)+x2​f(e2​)+⋯+xn​f(en​)​ 此时表示为内积形式（f(en)f(e_n)f(en​)为常量对应ana_nan​） 2.1.3 仿射函数 定义：一个线性函数加上一个常数称为仿射函数(affine function) 一般形式为f(x)=aTx+b, a∈Rn,b∈Rf(x)=a^T x+b, \\space a \\in \\mathbb{R}^n,b \\in \\mathbb{R}f(x)=aTx+b, a∈Rn,b∈R 函数f:Rn→Rf:\\mathbb{R}^n \\to \\mathbb{R}f:Rn→R满足： f(αx+βy)=αf(x)+βf(y), α+β=1,α,β∈R,x,y∈Rnf(\\alpha x + \\beta y)=\\alpha f(x) + \\beta f(y), \\space \\alpha + \\beta =1,\\alpha, \\beta \\in \\mathbb{R},x,y \\in \\mathbb{R} ^n f(αx+βy)=αf(x)+βf(y), α+β=1,α,β∈R,x,y∈Rn 2.2 梯度与偏导 假设：f:Rn→Rf:\\mathbb{R}^n \\to \\mathbb{R}f:Rn→R，函数fff在zzz点可微，其第iii个分量的一阶偏导为： ∂f∂zi(z)=lim⁡t→0f(z1,⋯ ,zi−1,zi+t,zi+1,⋯ ,zn)−f(z)t=lim⁡t→0f(z+tei)−f(z)t\\begin{aligned} \\frac{\\partial f}{\\partial z_i}(z) &amp;=\\lim_{t \\to 0} \\frac{f(z_1,\\cdots,z_{i-1},z_i+t,z_{i+1},\\cdots,z_n)-f(z)}{t} \\\\ &amp;=\\lim_{t \\to 0} \\frac{f(z+te_i)-f(z)}{t} \\end{aligned} ∂zi​∂f​(z)​=t→0lim​tf(z1​,⋯,zi−1​,zi​+t,zi+1​,⋯,zn​)−f(z)​=t→0lim​tf(z+tei​)−f(z)​​ fff在点zzz的梯度为： ∇f(z)=[∂f∂z1(z)⋮∂f∂zn(z)]\\nabla f(z)=\\begin{bmatrix} \\frac{\\partial f}{\\partial z_1}(z) \\\\ \\vdots \\\\ \\frac{\\partial f}{\\partial z_n}(z)\\end{bmatrix} ∇f(z)=⎣⎢⎢⎡​∂z1​∂f​(z)⋮∂zn​∂f​(z)​⎦⎥⎥⎤​ 2.2 一阶泰勒近似 假设：f:Rn→Rf:\\mathbb{R}^n \\to \\mathbb{R}f:Rn→R，函数fff在zzz点可导，其附近的一阶泰勒公式为： f^(x)=f(z)+∂f∂x1(z)(x1−z)+∂f∂x2(z)(x2−z)+⋯+∂f∂xn(z)(xn−z)\\hat{f}(x)=f(z)+\\frac{\\partial f}{\\partial x_1}(z)(x_1-z)+\\frac{\\partial f}{\\partial x_2}(z)(x_2-z)+\\cdots+\\frac{\\partial f}{\\partial x_n}(z)(x_n-z) f^​(x)=f(z)+∂x1​∂f​(z)(x1​−z)+∂x2​∂f​(z)(x2​−z)+⋯+∂xn​∂f​(z)(xn​−z) 当xxx非常接近zzz时，f^(x)\\hat{f}(x)f^​(x)也非常接近f(z)f(z)f(z) f^(x)\\hat{f}(x)f^​(x)是一个关于xxx的仿射函数 写成内积形式： f^(x)=f(z)+∇f(z)T(x−z)∇f(z)=[∂f∂x1(z)⋮∂f∂xn(z)]\\hat{f}(x)=f(z)+\\nabla f(z)^T(x-z) \\\\ \\nabla f(z)=\\begin{bmatrix} \\frac{\\partial f}{\\partial x_1}(z) \\\\ \\vdots \\\\ \\frac{\\partial f}{\\partial x_n}(z) \\end{bmatrix} f^​(x)=f(z)+∇f(z)T(x−z)∇f(z)=⎣⎢⎢⎡​∂x1​∂f​(z)⋮∂xn​∂f​(z)​⎦⎥⎥⎤​ 2.3 回归模型 y^=xTβ+v\\hat{y}=x^T\\beta+v y^​=xTβ+v xxx是特征向量，它的元素xix_ixi​称为回归元 n维向量β\\betaβ是权重向量 标量vvv是偏移量 标量y^\\hat{y}y^​是预测值 Chapter3 3.1 范数 向量范数：在向量空间中存在一个函数∣∣⋅∣∣:Rn→R||\\cdot||:\\mathbb{R}^n\\to\\mathbb{R}∣∣⋅∣∣:Rn→R，且满足以下条件： 齐次性：∣∣αx∣∣=∣α∣∣∣x∣∣,α∈R且x∈Rn||\\alpha x||=|\\alpha|||x||,\\alpha \\in \\mathbb{R}且x \\in \\mathbb{R}^n∣∣αx∣∣=∣α∣∣∣x∣∣,α∈R且x∈Rn 三角不等性：∣∣x+y∣∣≤∣∣x∣∣+∣∣y∣∣,x,y∈Rn||x+y|| \\le ||x||+||y||,x,y \\in \\mathbb{R}^n∣∣x+y∣∣≤∣∣x∣∣+∣∣y∣∣,x,y∈Rn 非负性：∣∣x∣∣≥0,x∈Rn且∣∣x∣∣=0⇔x=0||x|| \\ge 0,x\\in \\mathbb{R}^n 且 ||x||=0 \\Leftrightarrow x=0∣∣x∣∣≥0,x∈Rn且∣∣x∣∣=0⇔x=0 则称∣∣⋅∣∣||\\cdot ||∣∣⋅∣∣为向量范数 常用的范数与不等式（抄在书上） ℓ1\\ell_1ℓ1​-范数（曼哈顿范数） ∣∣x∣∣1=∣x1∣+∣x2∣+⋯+∣xn∣,x,y∈Rn,α∈R||x||_1=|x_1|+|x_2|+ \\cdots +|x_n|,x,y \\in \\bold{R}^n,\\alpha \\in \\bold{R} ∣∣x∣∣1​=∣x1​∣+∣x2​∣+⋯+∣xn​∣,x,y∈Rn,α∈R ℓ2\\ell_2ℓ2​-范数（欧几里得范数，一般的∣∣⋅∣∣||\\cdot||∣∣⋅∣∣也是） ∣∣x∣∣2=(x12+x22+⋯+xn2)=xTx=(⟨x,x⟩)12||x||_2=\\sqrt{(x_1^2+x_2^2+ \\cdots +x_n^2)}=\\sqrt{x^Tx}=(\\langle x,x \\rangle )^\\frac{1}{2} ∣∣x∣∣2​=(x12​+x22​+⋯+xn2​)​=xTx​=(⟨x,x⟩)21​ ℓp\\ell_pℓp​-范数 ∣∣x∣∣p=(∣x1∣p+∣x2∣p+⋯+∣xn∣p)1p,x∈Rn||x||_p=(|x_1|^p+|x_2|^p+\\cdots+|x_n|^p)^\\frac{1}{p},x \\in \\mathbb{R}^n ∣∣x∣∣p​=(∣x1​∣p+∣x2​∣p+⋯+∣xn​∣p)p1​,x∈Rn ℓ∞\\ell_\\infinℓ∞​-范数 ∣∣x∣∣∞=max⁡1≤i≤n∣xi∣,x∈Rn||x||_\\infin = \\max_{1 \\le i \\le n} |x_i|,x \\in \\bold{R}^n ∣∣x∣∣∞​=1≤i≤nmax​∣xi​∣,x∈Rn ℓ0\\ell_0ℓ0​-范数 （非0元素的个数） ∣∣x∣∣0=nnz(x)||x||_0=nnz(x) ∣∣x∣∣0​=nnz(x) 柯西-施瓦茨不等式 可用于证明ℓ2\\ell_2ℓ2​-范数的三角不等性 ∣⟨x,y⟩∣2≤⟨x,x⟩⟨y,y⟩=∣∣x∣∣22∣∣y∣∣22|\\langle x,y \\rangle |^2 \\le \\langle x,x \\rangle \\langle y,y \\rangle = ||x||_2^2 ||y||_2^2 ∣⟨x,y⟩∣2≤⟨x,x⟩⟨y,y⟩=∣∣x∣∣22​∣∣y∣∣22​ Minkowshi不等式 可用于证明ℓp\\ell_pℓp​-范数的三角不等性 (∑i=1n∣xi+yi∣p)1p≤(∑i=1n∣xi∣p)1p+(∑i=1n∣yi∣p)1p,p≥1,x,y∈Rn(\\sum_{i=1}^n |x_i+y_i|^p)^\\frac{1}{p} \\le (\\sum_{i=1}^n|x_i|^p)^\\frac{1}{p} + (\\sum_{i=1}^n|y_i|^p)^\\frac{1}{p},p \\ge 1, x,y \\in \\bold{R}^n (i=1∑n​∣xi​+yi​∣p)p1​≤(i=1∑n​∣xi​∣p)p1​+(i=1∑n​∣yi​∣p)p1​,p≥1,x,y∈Rn Hölder不等式 ∑i=1n∣xiyi∣≤(∑i=1n∣xi∣p)1p(∑i=1n∣yi∣p)1p,1p+1q=1,1&lt;p,q&lt;∞\\sum_{i=1}^n |x_iy_i| \\le (\\sum_{i=1}^n|x_i|^p)^\\frac{1}{p} (\\sum_{i=1}^n|y_i|^p)^\\frac{1}{p},\\frac{1}{p}+\\frac{1}{q}=1,1&lt;p,q&lt;\\infin i=1∑n​∣xi​yi​∣≤(i=1∑n​∣xi​∣p)p1​(i=1∑n​∣yi​∣p)p1​,p1​+q1​=1,1&lt;p,q&lt;∞ 3.1.1 均方根 n维向量xxx的均方值： x12+x22+⋯+xn2n=∣∣x∣∣22n\\frac{x_1^2+x_2^2+\\cdots+x_n^2}{n}=\\frac{||x||_2^2}{n} nx12​+x22​+⋯+xn2​​=n∣∣x∣∣22​​ n维向量xxx的均方根： rms(x)=x12+x22+⋯+xn2n=∣∣x∣∣2n\\mathit{rms}(x)=\\sqrt{\\frac{x_1^2+x_2^2+\\cdots+x_n^2}{n}}=\\frac{||x||_2}{\\sqrt n} rms(x)=nx12​+x22​+⋯+xn2​​​=n​∣∣x∣∣2​​ 3.1.2 切比雪夫不等式 假设k为向量xxx分量满足条件∣xi∣≥a|x_i|\\ge a∣xi​∣≥a的个数 则：∣∣x∣∣22=x12+x22+⋯+xn2≥ka2||x||_2^2=x_1^2+x_2^2+\\cdots + x_n^2 \\ge ka^2∣∣x∣∣22​=x12​+x22​+⋯+xn2​≥ka2 即：k≤∣∣x∣∣22a2k\\le \\frac{||x||_2^2}{a^2}k≤a2∣∣x∣∣22​​ 即满足∣xi∣≥a|x_i|\\ge a∣xi​∣≥a的xix_ixi​个数不会超过∣∣x∣∣22a2\\frac{||x||_2^2}{a^2}a2∣∣x∣∣22​​ 使用均方根来描述即为： kn≤(rms(x)a)2\\frac{k}{n}\\le (\\frac{\\mathit{rms}(x)}{a})^2 nk​≤(arms(x)​)2 例：不超过4%4\\%4%的项满足∣xi∣≥5×rms(x)|x_i| \\ge 5 \\times \\mathit{rms}(x)∣xi​∣≥5×rms(x) 3.2 距离 n维向量aaa和bbb之间的欧氏距离： dist(a,b)=∣∣a−b∣∣2\\mathit{dist}(a,b)=||a-b||_2 dist(a,b)=∣∣a−b∣∣2​ 3.2.1 三角不等式 顶点为a,b,ca,b,ca,b,c 两点之间的距离大于0，如∣∣a−b∣∣2&gt;0||a-b||_2 &gt; 0∣∣a−b∣∣2​&gt;0 第三边长度不大于另外两边之和，即三角不等式关系： ∣∣a−c∣∣2=∣∣(a−b)+(b−c)∣∣2≤∣∣a−b∣∣2+∣∣b−c∣∣2||a-c||_2=||(a-b)+(b-c)||_2\\le ||a-b||_2+||b-c||_2 ∣∣a−c∣∣2​=∣∣(a−b)+(b−c)∣∣2​≤∣∣a−b∣∣2​+∣∣b−c∣∣2​ 3.2.2 特征距离与最近邻 对于特征向量xxx和yyy，它们的特征距离为∣∣x−y∣∣2||x-y||_2∣∣x−y∣∣2​ 对于向量xxx，在一组向量z1,z2,⋯ ,zmz_1,z_2,\\cdots,z_mz1​,z2​,⋯,zm​中找到zjz_jzj​满足：∣∣x−zj∣∣2≤∣∣x−zi∣∣2, i=1,⋯ ,m||x-z_j||_2 \\le ||x-z_i||_2,\\space i=1,\\cdots,m∣∣x−zj​∣∣2​≤∣∣x−zi​∣∣2​, i=1,⋯,m 则zjz_jzj​是xxx的最近邻 3.3 标准差 平均值： avg(x)=1Txn\\mathit{avg}(x)=\\frac{\\bold1^Tx}{n} avg(x)=n1Tx​ 去均值向量： x~=x−avg(x)1\\tilde{x}=x-\\mathit{avg}(x)\\bold1 x~=x−avg(x)1 标准差： std(x)=rms(x~)=∣∣x−(1Tx/n)1∣∣2n\\mathit{std}(x)=\\mathit{rms}(\\tilde{x})=\\frac{||x-(\\bold1^Tx/n)\\bold1||_2}{\\sqrt n} std(x)=rms(x~)=n​∣∣x−(1Tx/n)1∣∣2​​ rms(x)2=avg(x)2+std(x)2\\mathit{rms}(x)^2=\\mathit{avg}(x)^2+\\mathit{std}(x)^2 rms(x)2=avg(x)2+std(x)2 3.4 角 ∠(a,b)=arccos⁡(aTb∣∣a∣∣2∣∣b∣∣2)\\angle(a,b)=\\arccos(\\frac{a^Tb}{||a||_2||b||_2}) ∠(a,b)=arccos(∣∣a∣∣2​∣∣b∣∣2​aTb​) Chapter4 4.1 优化问题 假设NNN个样本向量x1,x2,⋯ ,xN∈Rnx_1,x_2,\\cdots,x_N\\in \\mathbb{R}^nx1​,x2​,⋯,xN​∈Rn，需要找到中心向量zzz满足： min⁡z∈Rn∑i=1N∣∣xi−z∣∣22\\min_{z\\in \\mathbb R^n}\\sum_{i=1}^N ||x_i-z||_2^2 z∈Rnmin​i=1∑N​∣∣xi​−z∣∣22​ 4.1.1 渐近符号 高阶无穷小记号ooo 设x,yx,yx,y是同一变化过程中的无穷小，即x→0,y→0x \\to 0, y\\to 0x→0,y→0，如果它们极限 lim⁡yx=0\\lim \\frac y x = 0 limxy​=0 则称yyy是xxx的高阶无穷小，记作y=o(x)y=o(x)y=o(x) 4.1.2 必要条件 假设函数fff在x^\\hat xx^可微，则有 x^=arg min⁡x inRnf(x)⇒∇f(x^)=0\\hat x = \\argmin_{x \\ in\\mathbb{R}^n} f(x) \\Rightarrow \\nabla f(\\hat x)=0 x^=x inRnargmin​f(x)⇒∇f(x^)=0 ∇f(x^)=0\\nabla f(\\hat x)=0∇f(x^)=0是最优问题解的必要条件 ∇f(x^)=0⇎x^=arg min⁡x∈Rnf(x)\\nabla f(\\hat x)=0\\nLeftrightarrow \\hat x = \\argmin_{x \\in \\mathbb{R}^n} f(x) ∇f(x^)=0⇎x^=x∈Rnargmin​f(x) 有可能意味着最大值 4.2 凸集 定义域为Ω∈Rn\\Omega \\in \\mathbb{R}^nΩ∈Rn成为凸的(Convex)集合，则∀x,y∈Ω,α∈R,0≤α≤1\\forall x,y \\in \\Omega, \\alpha \\in \\mathbb{R},0 \\le \\alpha \\le 1∀x,y∈Ω,α∈R,0≤α≤1有 αx+(1−α)y∈Ω\\alpha x + (1-\\alpha)y \\in \\Omega αx+(1−α)y∈Ω 4.2 凸函数 满足 f(αx+(1−α)y)≤αf(x)+(1−α)f(y),∀x,y∈Ω,α∈R,0≤α≤1f(\\alpha x + (1-\\alpha )y) \\le \\alpha f(x) + (1-\\alpha) f(y), \\\\ \\forall x,y \\in \\Omega,\\alpha \\in \\bold R, 0\\le\\alpha\\le 1 f(αx+(1−α)y)≤αf(x)+(1−α)f(y),∀x,y∈Ω,α∈R,0≤α≤1 引理：可微函数fff是凸函数的充要条件(应该不会考)，见证明： f(y)≥f(x)+⟨∇f(x),y−x⟩,∀x,yf(y) \\ge f(x) + \\langle \\nabla f(x), y-x \\rangle , \\forall x,y f(y)≥f(x)+⟨∇f(x),y−x⟩,∀x,y 定理：如果可微函数fff是凸函数，则有： x^=arg min⁡x∈Rn⇔∇f(x^)=0\\hat x = \\argmin_{x \\in \\mathbb{R}^n} \\Leftrightarrow \\nabla f(\\hat x) = 0 x^=x∈Rnargmin​⇔∇f(x^)=0 4.3 优化问题 向量偏导 就是求偏导 聚类中心 假设NNN个样本向量x1,x2,⋯ ,xN∈Rnx_1,x_2,\\cdots,x_N\\in \\mathbb{R}^nx1​,x2​,⋯,xN​∈Rn，需要找到中心向量z满足： min⁡z∈Rn∑i=1N∣∣xi−z∣∣22\\min_{z\\in \\mathbb R^n}\\sum_{i=1}^N ||x_i-z||_2^2 z∈Rnmin​i=1∑N​∣∣xi​−z∣∣22​ f(z)=min⁡z∈Rn∑i=1N∣∣xi−z∣∣22=∑i=1N⟨xi−z,xi−z⟩=∑i=1N{xiTxi−2xiTz+zTz}\\begin{aligned}f(z)&amp;= \\min_{z\\in \\mathbb R^n}\\sum_{i=1}^N ||x_i-z||_2^2 \\\\ &amp;= \\sum_{i=1}^N \\langle x_i-z,x_i-z \\rangle \\\\ &amp;= \\sum_{i=1}^N \\{ x_i^Tx_i - 2x_i^Tz + z^Tz \\} \\end{aligned} f(z)​=z∈Rnmin​i=1∑N​∣∣xi​−z∣∣22​=i=1∑N​⟨xi​−z,xi​−z⟩=i=1∑N​{xiT​xi​−2xiT​z+zTz}​ ∇f(z)=∑i=1N{−2xi+2z}=0\\nabla f(z)=\\sum_{i=1}^N \\{ -2x_i + 2z \\} =0 ∇f(z)=i=1∑N​{−2xi​+2z}=0 z=1N∑i=1Nxiz=\\frac{1}{N} \\sum_{i=1}^N x_i z=N1​i=1∑N​xi​ 标量 同上，优化问题的思路基本是求偏导，找到偏导为0的情况 4.4 聚类 分成k个集合尽量使得同一个集合中的向量彼此接近 聚类目标：找到簇ccc与聚类中心zzz使得 ci=arg min⁡zj∑j={1,⋯ ,k}∣∣xi−zj∣∣22,i=1,2,⋯ ,Nc_i=\\argmin_{z_j} \\sum_{j=\\{ 1, \\cdots, k \\} } || x_i - z_j||_2^2,i=1,2,\\cdots , N ci​=zj​argmin​j={1,⋯,k}∑​∣∣xi​−zj​∣∣22​,i=1,2,⋯,N 4.4 k-means 懒得写了，看看实验报告吧 Chapter5 5.1 线性相关 对于向量a1,⋯ ,am∈Rna_1,\\cdots,a_m\\in\\mathbb{R}^na1​,⋯,am​∈Rn，如果存在不全为0的数β1,⋯ ,βm∈R\\beta_1,\\cdots,\\beta_m\\in\\mathbb{R}β1​,⋯,βm​∈R，使得 β1a1+⋯+βmam=0\\beta_1 a_1 + \\cdots + \\beta_m a_m = 0 β1​a1​+⋯+βm​am​=0 则称向量a1,⋯ ,ama_1,\\cdots,a_ma1​,⋯,am​线性相关 等价于：至少有一个向量aia_iai​是其他向量的线性组合 5.2 线性无关(又叫线性独立) 向量a1,⋯ ,am∈Rna_1,\\cdots,a_m\\in\\mathbb{R}^na1​,⋯,am​∈Rn线性无关，即 β1a1+⋯+βmam=0\\beta_1 a_1 + \\cdots + \\beta_m a_m =0 β1​a1​+⋯+βm​am​=0 当且仅当β1=⋯=βm=0\\beta_1=\\cdots=\\beta_m=0β1​=⋯=βm​=0，上述等式成立 等价于：不存在一个向量aia_iai​是其他向量的线性组合 一个n维向量集最多有n个线性无关的向量 5.2.1 线性无关向量的线性组合 线性无关向量a1,⋯ ,aka_1,\\cdots,a_ka1​,⋯,ak​的线性组合的系数是唯一的 5.3 基 n个线性相关的n维向量a1,⋯ ,ana_1,\\cdots,a_na1​,⋯,an​的集合称为基 任何一个n维向量bbb都可以用它们的线性组合来表示 b=β1a1+⋯+βnanb=\\beta_1 a_1 + \\cdots + \\beta_n a_n b=β1​a1​+⋯+βn​an​ 5.4 标准正交向量 对于a1,⋯ ,am∈Rna_1,\\cdots,a_m\\in\\mathbb{R}^na1​,⋯,am​∈Rn 相互正交： aiTaj=0,i≠ja_i^Ta_j = 0,i \\ne j aiT​aj​=0,i=j 标准正交(每个向量的模长都为单位长度1): aiTaj={1, i=j0, i≠ja_i^Ta_j=\\begin{cases} 1 ,\\ i=j \\\\ 0, \\ i \\ne j\\end{cases} aiT​aj​={1, i=j0, i=j​ 当m=n时，a1,⋯ ,ana_1,\\cdots, a_na1​,⋯,an​是n维向量的一个标准正交基 5.4.2 标准正交分解 a1,⋯ ,ana_1,\\cdots, a_na1​,⋯,an​是n维向量的一个标准正交基，对于任意n维向量xxx： x=(a1Tx)a1+⋯+(anTx)anx=(a_1^Tx)a_1+\\cdots+(a_n^Tx)a_n x=(a1T​x)a1​+⋯+(anT​x)an​ 验证上式两边同乘任意aia_iai​： aiTx=(a1Tx)aiTa1+⋯+(aiTx)aiTai+⋯+(anTx)aiTan=aiTxa_i^Tx=(a_1^Tx)a_i^Ta_1+\\cdots+(a_i^Tx)a_i^Ta_i+\\cdots+(a_n^Tx)a_i^Ta_n=a_i^Tx aiT​x=(a1T​x)aiT​a1​+⋯+(aiT​x)aiT​ai​+⋯+(anT​x)aiT​an​=aiT​x 5.5 Gram-Schmidt(正交化)算法 对于n维向量a1,⋯ ,aka_1,\\cdots,a_ka1​,⋯,ak​，将其标准正交化。见[流程](最优化方法例题解法 - 没有秃头基因的燊的博客 (yzs020220.github.io)) 时间复杂度为2nk22nk^22nk2 Chapter6 涉及概念较多，很多不一定考，看ppt吧(题型主要是从矩阵计算分解到向量计算) 6.11 矩阵乘法 不要记混了，行(左)与列(右)元素一一对应相乘之后相加 Cij=∑k=1PAikBkjC_{ij}=\\sum_{k=1}^P A_{ik}B_{kj} Cij​=k=1∑P​Aik​Bkj​ Chapter7 7.1 矩阵左逆 当一个矩阵XXX满足XA=IXA=IXA=I时，XXX被称为AAA的左逆 7.2 矩阵右逆 当一个矩阵XXX满足AX=IAX=IAX=I时，XXX被称为AAA的右逆 7.3 性质 一个大小为m×nm × nm×n的矩阵，其左逆或右逆的维度为n×mn × mn×m A的左逆为X当且仅当XTX^TXT是ATA^TAT的右逆 A的右逆为X当且仅当XTX^TXT是ATA^TAT的左逆 7.4 矩阵的逆 如果矩阵A存在左逆和右逆，则左逆和右逆一定相等 XA=I,AY=I⇒X=XI=X(AY)=(XA)Y=YXA=I,AY=I \\Rightarrow X=XI=X(AY)=(XA)Y=Y XA=I,AY=I⇒X=XI=X(AY)=(XA)Y=Y 矩阵XXX记作A−1A^{-1}A−1 7.7 非奇异矩阵 对于方阵A∈Rn×nA \\in \\mathbb{R}^{n\\times n}A∈Rn×n，以下条件都是等价的 A可左逆 A的列向量线性无关 A可右逆 A的行向量线性无关 7.12 Gram矩阵 实矩阵： G=ATAG=A^TA G=ATA 复矩阵： G=AHAG=A^HA G=AHA 7.14 伪逆 矩阵A∈Rm×nA \\in \\mathbb{R}^{m\\times n}A∈Rm×n,当m≥nm\\ge nm≥n时，列向量线性无关，即ATAA^TAATA可逆 定义伪逆： A+=(ATA)−1ATA^+=(A^TA)^{-1}A^T A+=(ATA)−1AT 为矩阵A的左逆： A+A=(ATA)−1ATA=(ATA)−1(ATA)=IA^+A=(A^TA)^{-1}A^TA=(A^TA)^{-1}(A^TA)=I A+A=(ATA)−1ATA=(ATA)−1(ATA)=I 当A为方阵，伪逆等于矩阵的逆 矩阵A∈Rm×nA \\in \\mathbb{R}^{m\\times n}A∈Rm×n,当m≤nm\\le nm≤n时，行向量线性无关，即AATAA^TAAT可逆 定义伪逆： A†=AT(AAT)−1A^\\dagger=A^T(AA^T)^{-1} A†=AT(AAT)−1 伪逆A†A^\\daggerA†为A的右逆 AA†=AAT(AAT)−1=(AAT)−1(AAT)=IAA^\\dagger=AA^T(AA^T)^{-1}=(AA^T)^{-1}(AA^T)=I AA†=AAT(AAT)−1=(AAT)−1(AAT)=I 当A为方阵，伪逆等于矩阵的逆 Chapter8 8.2 标准列正交矩阵 如果A的Gram矩阵为单位矩阵，则A∈Rm×nA\\in \\mathbb R^{m\\times n}A∈Rm×n具有标准正交列： ATA=IA^TA=I ATA=I 8.5 正交矩阵 定义：所有列两两相互正交的方形实矩阵称为正交矩阵 如果矩阵AAA正交则 AAA是可逆的，左逆等于右逆，且逆为ATA^TAT ATA=IA是方的}⇒AAT=I\\left. \\begin{aligned} A^TA=I \\\\ A是方的 \\end{aligned}\\right \\} \\Rightarrow AA^T=I ATA=IA是方的​}⇒AAT=I ATA^TAT也是一个正交矩阵 AAA的行是标准正交的，即范数为1且相互正交 8.6 置换矩阵 置换矩阵AAA在每一行和每一列中都有一个等于1的元素，置换矩阵满足正交性： ATA=IA^TA=IATA=I AT=A−1A^T=A^{-1}AT=A−1是逆置换矩阵 Chapter9 9.1 三角矩阵 上三角矩阵(Upper) 下三角矩阵(Lower) 对角元素都为1称为单位上三角矩阵/下三角矩阵 9.2 前向回代 AAA是具有非零对角元素的下三角矩阵，解Ax=bAx=bAx=b x1=b1/A11x2=(b2−A21x1)/A22x3=(b3−A31x1−A32x2)/A33 ⋮xn=(bn−An1x1−An2x2−⋯−An,n−1xn−1)/Ann\\begin{aligned} &amp;x_1=b_1/A_{11} \\\\ &amp;x_2=(b_2-A_{21}x_1)/A_{22} \\\\ &amp;x_3=(b_3-A_{31}x_1-A_{32}x_2)/A_{33} \\\\ &amp; \\ \\ \\vdots \\\\ &amp;x_n=(b_n-A_{n1}x_1-A_{n2}x_2-\\cdots-A_{n,n-1}x_{n-1})/A_{nn} \\end{aligned} ​x1​=b1​/A11​x2​=(b2​−A21​x1​)/A22​x3​=(b3​−A31​x1​−A32​x2​)/A33​ ⋮xn​=(bn​−An1​x1​−An2​x2​−⋯−An,n−1​xn−1​)/Ann​​ 9.3 后向回代 AAA是具有非零对角元素的上三角矩阵，解Ax=bAx=bAx=b xn=bn/Annxn−1=(bn−1−An−1,nxn)/An−1,n−1xn−2=(bn−2−An−2,n−1xn−1−An−2,nxn)/An−2,n−2 ⋮x1=(b1−A12x2−A13x3−⋯−A1nxn)/A11\\begin{aligned} &amp;x_n=b_n/A_{nn} \\\\ &amp;x_{n-1}=(b_{n-1}-A_{n-1,n}x_n)/A_{n-1,n-1} \\\\ &amp;x_{n-2}=(b_{n-2}-A_{n-2,n-1}x_{n-1}-A_{n-2,n}x_n)/A_{n-2,n-2} \\\\ &amp; \\ \\ \\vdots \\\\ &amp;x_1=(b_1-A_{12}x_2-A_{13}x_3-\\cdots-A_{1n}x_{n})/A_{11} \\end{aligned} ​xn​=bn​/Ann​xn−1​=(bn−1​−An−1,n​xn​)/An−1,n−1​xn−2​=(bn−2​−An−2,n−1​xn−1​−An−2,n​xn​)/An−2,n−2​ ⋮x1​=(b1​−A12​x2​−A13​x3​−⋯−A1n​xn​)/A11​​ 9.4 三角矩阵的逆矩阵 矩阵AAA的逆可以通过逐列解方程AX=IAX=IAX=I来计算得到 9.5 QR分解 如果矩阵A∈Rm×nA\\in \\R^{m\\times n}A∈Rm×n的列向量线性无关，则可以分解为一组标准正交向量QQQ与上三角矩阵RRR A=[a1a2⋯an]=[q1q2⋯qn][R11R12⋯R1n0R22⋯R2n⋮⋮⋱⋮00⋯Rnn]=QR\\begin{aligned} A&amp;=\\begin{bmatrix}a_1&amp; a_2&amp; \\cdots &amp; a_n\\end{bmatrix} \\\\ &amp;=\\begin{bmatrix}q_1&amp; q_2&amp; \\cdots &amp; q_n \\end{bmatrix} \\begin{bmatrix} R_{11}&amp; R_{12}&amp; \\cdots &amp; R_{1n} \\\\ 0&amp; R_{22} &amp; \\cdots &amp; R_{2n} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; \\cdots &amp; R_{nn} \\end{bmatrix} \\\\ &amp;= QR \\end{aligned} A​=[a1​​a2​​⋯​an​​]=[q1​​q2​​⋯​qn​​]⎣⎢⎢⎢⎢⎡​R11​0⋮0​R12​R22​⋮0​⋯⋯⋱⋯​R1n​R2n​⋮Rnn​​⎦⎥⎥⎥⎥⎤​=QR​ Gram-Schmidt正交化 qi~=ai−(q1Tai)q1−⋯−(qi−1Tai)qi−1\\tilde{q_i}=a_i-(q_1^Ta_i)q_1-\\cdots-(q_{i-1}^Ta_i)q_{i-1} qi​~​=ai​−(q1T​ai​)q1​−⋯−(qi−1T​ai​)qi−1​ Rji=(qjTai)R_{ji}=(q_j^Ta_i) Rji​=(qjT​ai​) 一般要求Rii&gt;0R_{ii}&gt;0Rii​&gt;0使得QQQ和RRR是唯一的 9.6 QR分解和伪逆 具有线性无关列向量的矩阵AAA的伪逆为 A+=(ATA)−1ATA^+=(A^TA)^{-1}A^T A+=(ATA)−1AT 将AAA的伪逆表示为QRQRQR因子： A+=((QR)T(QR))−1(QR)T=(RTQTQR)−1RTQT=(RTR)−1RTQT=R−1R−TRTQT=R−1QT\\begin{aligned} A^+ &amp;= \\left( (QR)^T(QR) \\right)^{-1}(QR)^T \\\\ &amp;= (R^TQ^TQR)^{-1}R^TQ^T \\\\ &amp;= (R^TR)^{-1}R^TQ^T \\\\ &amp;= R^{-1}R^{-T}R^TQ^T \\\\ &amp;= R^{-1}Q^T \\end{aligned} A+​=((QR)T(QR))−1(QR)T=(RTQTQR)−1RTQT=(RTR)−1RTQT=R−1R−TRTQT=R−1QT​ 对于方阵非奇异矩阵AAA，其逆为： A−1=(QR)−1=R−1QTA^{-1}=(QR)^{-1}=R^{-1}Q^T A−1=(QR)−1=R−1QT Chapter10 10.2 应用QR分解 计算非奇异矩阵A∈Rn×nA\\in \\R^{n\\times n}A∈Rn×n的逆A−1A^{-1}A−1，通过AX=IAX=IAX=I，即QRX=IQRX=IQRX=I X=[x1,x2,⋯ ,xn],xi∈Rn,i=1,⋯ ,nI=[e1,e2,⋯ ,en],ei∈Rn,i=1,⋯ ,nQRX=I⇒RX=QTIRx1=QTe1,Rx2=QTe2,⋯ ,Rxn=QTen\\begin{aligned} &amp;X=[x_1,x_2,\\cdots,x_n],x_i\\in\\R^n,i=1,\\cdots,n \\\\ &amp;I=[e_1,e_2,\\cdots,e_n],e_i\\in\\R^n,i=1,\\cdots,n \\\\ &amp;QRX=I \\Rightarrow RX=Q^TI \\\\ &amp;Rx_1=Q^Te_1,Rx_2=Q^Te_2,\\cdots,Rx_n=Q^Te_n \\end{aligned} ​X=[x1​,x2​,⋯,xn​],xi​∈Rn,i=1,⋯,nI=[e1​,e2​,⋯,en​],ei​∈Rn,i=1,⋯,nQRX=I⇒RX=QTIRx1​=QTe1​,Rx2​=QTe2​,⋯,Rxn​=QTen​​ 回代法求解 10.3 LU分解 LLL为下三角矩阵且对角线元素全为1，UUU为上三角矩阵 A=LUA=LU A=LU 矩阵UUU的第一行元素： u1j=a1j,j=1,⋯ ,nu_{1j}=a_{1j},j=1,\\cdots,n u1j​=a1j​,j=1,⋯,n 矩阵LLL的第一列元素： li1=ai1u11,i=2,3,⋯ ,nl_{i1}=\\frac{a_{i1}}{u_{11}},i=2,3,\\cdots,n li1​=u11​ai1​​,i=2,3,⋯,n 从r=2r=2r=2开始直到r=nr=nr=n 矩阵UUU第r行主对角线以右元素urju_{rj}urj​ urj=arj−∑k=1r−1lrkukj,j=r,⋯ ,nu_{rj}=a_{rj}-\\sum_{k=1}^{r-1}l_{rk}u_{kj},j=r,\\cdots,n urj​=arj​−k=1∑r−1​lrk​ukj​,j=r,⋯,n 矩阵LLL第r列主对角线以下元素lirl_{ir}lir​ lir=(air−∑k=1r−1likukr)/urr,i=r+1,⋯ ,nl_{ir}=\\left(a_{ir}- \\sum_{k=1}^{r-1} l_{ik}u_{kr} \\right)/u_{rr},i=r+1,\\cdots,n lir​=(air​−k=1∑r−1​lik​ukr​)/urr​,i=r+1,⋯,n 10.4 LU求解方程 求解Ax=bAx=bAx=b 对矩阵AAA进行LU分解 回代法求出yyy：Ax=LUx=Ly=bAx=LUx=Ly=bAx=LUx=Ly=b 回代法求出xxx：Ux=bUx=bUx=b Chapter11 11.2 最小二乘法 寻找超定方程组(方程组系数矩阵为高矩阵，可能无解)的近似解，并尽可能地逼近方程组的目标bbb： min⁡x∣∣Ax−b∣∣22=min⁡x∑i=1m(∑j=1nAijxj−bj)2\\min_x ||Ax-b||_2^2 = \\min_x \\sum_{i=1}^m (\\sum_{j=1}^n A_{ij}x_j - b_j)^2 xmin​∣∣Ax−b∣∣22​=xmin​i=1∑m​(j=1∑n​Aij​xj​−bj​)2 对xxx上的xix_ixi​求偏导，当∇f(x)=0\\nabla f(x)=0∇f(x)=0时，得到x^\\hat xx^即为近似解 当残差r^=Ax^−b=0\\hat r=A\\hat x - b=0r^=Ax^−b=0时，x^\\hat xx^是线性方程组Ax=bAx=bAx=b的解，否则为误差最小平方和下方程组的近似解 11.5 目标求解 ∇f(x)=2(ATAx−ATb)=0⇒ATAx=ATb\\nabla f(x)= 2(A^TAx-A^Tb)=0 \\Rightarrow A^TAx = A^Tb ∇f(x)=2(ATAx−ATb)=0⇒ATAx=ATb 则在AAA的列向量线性无关时，x^=(ATA)−1ATb\\hat x=(A^TA)^{-1}A^Tbx^=(ATA)−1ATb 11.7 正规方程 ATAx=ATbA^TAx=A^Tb ATAx=ATb 若AAA列向量线性无关，则 ATAA^TAATA为非奇异矩阵 正规方程此时有唯一解 11.8 QR分解求解正规方程 若矩阵AAA列向量线性无关，则最小二乘法问题的解： x^=(ATA)−1ATb=(RTQTQR)−1RTQTb=(RTR)−1RTQTb=R−1QTb\\begin{aligned} \\hat x &amp;= (A^TA)^{-1}A^Tb \\\\ &amp;= (R^TQ^TQR)^{-1} R^TQ^Tb \\\\ &amp;= (R^TR)^{-1}R^TQ^Tb \\\\ &amp;= R^{-1}Q^Tb \\end{aligned} x^​=(ATA)−1ATb=(RTQTQR)−1RTQTb=(RTR)−1RTQTb=R−1QTb​ 流程： 对矩阵AAA进行QR分解 计算矩阵向量乘积d=QTbd=Q^Tbd=QTb 通过回代法求解Rx=dRx=dRx=d Chapter13 13.1 约束优化问题 min⁡x{f(x)}s.t.h(x)=0\\min_x \\left \\{ f(x) \\right \\} \\quad s.t. \\quad h(x)=0 xmin​{f(x)}s.t.h(x)=0 引入拉格朗日函数： L(x,λ)=f(x)−λh(x)L(x,\\lambda)=f(x)-\\lambda h(x) L(x,λ)=f(x)−λh(x) 对拉格朗日函数求偏导： {∇xL(x,λ)=∇xf(x)−λ∇xh(x)=0∇λL(x,λ)=−h(x)=0\\begin{cases} \\nabla_xL(x,\\lambda)=\\nabla_x f(x)-\\lambda \\nabla_x h(x)=0 \\\\ \\nabla_\\lambda L(x,\\lambda)=-h(x)=0 \\end{cases} {∇x​L(x,λ)=∇x​f(x)−λ∇x​h(x)=0∇λ​L(x,λ)=−h(x)=0​ 13.1 KKT条件：必要条件 min⁡x/max⁡f(x)s.t.hi(x)=0, i∈I≜{1,⋯ ,p}gj(x)≤0, j∈J≜{1,⋯ ,q}\\min_x/\\max f(x) \\\\ \\begin{aligned} s.t. \\quad &amp; h_i(x)=0, \\ i\\in I \\triangleq \\left \\{ 1, \\cdots,p\\right \\} \\\\ &amp; g_j(x) \\le 0, \\ j\\in J \\triangleq \\{ 1, \\cdots ,q \\} \\end{aligned} xmin​/maxf(x)s.t.​hi​(x)=0, i∈I≜{1,⋯,p}gj​(x)≤0, j∈J≜{1,⋯,q}​ 引入拉格朗日函数： L(x,λ,μ)=f(x)−∑i∈Iλihi(x)−∑j∈Jμjgj(x)L(x,\\lambda,\\mu) = f(x)-\\sum_{i\\in I} \\lambda_ih_i(x) - \\sum_{j\\in J} \\mu_jg_j(x) L(x,λ,μ)=f(x)−i∈I∑​λi​hi​(x)−j∈J∑​μj​gj​(x) KKT条件： ∇xL(x,λ,u)=∇xf(x)−∑i∈Iλi∇xhi(x)−∑j∈Juj∇xgj(x)=0∑i∈Iλihi(x)=0,hi(x)=0∑j∈Jujgj(x)=0,gj(x)≤0,uj≥0(不全为0)\\begin{aligned} &amp;\\nabla_xL(x,\\lambda,u)=\\nabla_xf(x)- \\sum_{i \\in I} \\lambda_i \\nabla_x h_i(x) -\\sum_{j \\in J}u_j\\nabla_xg_j(x) =0 \\\\ &amp;\\sum_{i\\in I}\\lambda_ih_i(x)=0,h_i(x)=0 \\\\ &amp;\\sum_{j\\in J}u_j g_j(x)=0,g_j(x)\\le0,u_j \\ge 0(不全为0) \\end{aligned} ​∇x​L(x,λ,u)=∇x​f(x)−i∈I∑​λi​∇x​hi​(x)−j∈J∑​uj​∇x​gj​(x)=0i∈I∑​λi​hi​(x)=0,hi​(x)=0j∈J∑​uj​gj​(x)=0,gj​(x)≤0,uj​≥0(不全为0)​","categories":[{"name":"学","slug":"学","permalink":"https://yzs020220.github.io/categories/%E5%AD%A6/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://yzs020220.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"自用","slug":"自用","permalink":"https://yzs020220.github.io/tags/%E8%87%AA%E7%94%A8/"}]},{"title":"从Cards到Fluid主题","slug":"从Card到Fluid主题","date":"2023-01-29T09:48:10.000Z","updated":"2023-03-03T05:45:46.569Z","comments":true,"path":"posts/28931/","link":"","permalink":"https://yzs020220.github.io/posts/28931/","excerpt":"选择博客主题，就像在挑选琳琅满目的商品，总是将一个看得顺眼的搞到手，然后又看上了另一个，但是这个时候已经不能退货了。","text":"选择博客主题，就像在挑选琳琅满目的商品，总是将一个看得顺眼的搞到手，然后又看上了另一个，但是这个时候已经不能退货了。 博客换主题虽然不花钱，但是却是一件非常消耗时间成本的事，每换一个主题都要消耗很长时间来使用，使用的时候又会难免地遇到多种多样的问题。 Cards不好吗 不好的不是Cards，是我，人类总是喜新厌旧的。 我为什么会用到Cards 最早的时候，我看着那些各式各样的主题，Next实在是朴素得好像白纸，Butterfly花里胡哨的，我有没有看到Fluid呢？有，但是没有选择它，那个时候Cards更加吸引我Cardsd给人的第一印象是很好的，加上我曾经学习过一年的安卓，CardsrdView有一种莫名其妙的执着。于是第一眼我就看中他了。 我为什么会换到Fluid 那它究竟有什么不好，我只能说每个人的需求不一样，最早选主题的时候，我总是先看一眼预览图，然后再点进去翻翻，但当时的我从来没想过一件事，那就是动效，这个东西重要吗，作为一个曾经写过安卓的，我特别喜欢用插值器来作一些淡入淡出的动画，只需要短短的几行代码，但是一个傻傻呆呆的画面就活灵活现地动了起来。然而对于一个大学三年没有修过任何网页相关的课程，对css一窍不通的菜鸡来说，主题给我啥，我就基本只能用啥，当我有一次等待着博客更新到网站上，它一如既往那么傻快地“刷”一下出现在我眼前，在打开过n个一打开就绚丽多彩的博客后，我承认我产生了一种羡慕嫉妒恨的心理，我发现我终究是个不够朴素的人，我也许不会接受Butterfly那么绚丽的主题，但是我骨子里的闷骚却接受不了像Cards这样那么朴素的主题了，于是我选择了Fluid。 Cards主题的缺点（非常主观） 我说的缺点是我觉得有一些不太舒服的点，有很多地方实际上是不同点，大家的审美也不会完全相同，所以这一部分非常主观。 移动端页面间距不好看 在移动端查看网站的时候，Cards主题的卡片会和屏幕边缘有一定的间距，然后再加上文章和卡片的间距，看起来就很别扭，也许这个东西是可以调整的，但是像Fluid那样卡片和屏幕边缘之间没有间距看着确实会好受一点。 数学公式过长会直接超出去 一般是在移动端或者分屏的时候，数学公式为单行的时候当它过长会出现横向滚动条，但是当数学公式为多行又太长的时候，这个数学公式既不会出现滚动条，也不会自动缩进缩在文章里面，而是直接往右超出去一截，这不仅会让人觉得很难受，而且回到顶部和目录的按钮也会被公式顶到最右边（我有一次写文章发现两个按钮没了找了半天为什么，也没有人提到过这个问题，也许我之后想起来会去提交issues）。 没有动画 这个在上面已经提过了，Cards主题给人的感觉太简单了，没有那种灵动的感觉。 高冷的说明文档 Cards主题的说明文档虽然整体上非常的清晰明了（目录很好），但是落实到细节，却对初次使用Hexo的人来说比较困难，一般做的时候总是会想，这样真的搞定了吗，我按照这样敲效果就会出来吗。加上使Cardsd主题并且出教程的人并不算多，就会遇到各种各样的问题。从这方面上来Cardsrd主题也许对于初次使用Hexo的新手来说是有点困难了。 没有代码一键复制 很多主题都有这个功能，虽然说代码可以直接选中再复制，但我还是认为这个功能在博客中非常的有用。 Cards主题的优点 有优点当然也是要夸的 简洁好用的设置 Cards主题的设置非常的简洁，但是却涵盖了非常多的插件以及功能，一开始只需要非常简单的配置就能跑起来，后续添加功能与插件要进行设置也很方便，不得不说相比于其他的动辄八百一千行的config文件Cardsd主题的亲和度还是不错的。 文章无封面图与有封面图的两种情况比较匹配 不同于大部分的主题有封面图和无封面图总是只能选择一种情况（这实在是太难受了，总是要在Canva网站为纯文字的博客做一个封面），得益于统一使用卡片式布局，有无封面图的文章同时出现在Cards主题的主页并不会让人觉得很突兀，这实在是众多主题中不可多得的优点。 非常齐全的功能 也许你可以说Cards主题在某些美观地方上差强人意，但它确实做到了基本在功能上你能想到的它都基本做了，例如像在移动端文章右侧目录（toc）会变成一个按钮，只要点击就可以打开目录了（而Fluid却没有），方便的文章折叠功能（Fluid还要专门安装插件并进行设置），它虽然没有足够多的人去使用它以致于没有很详细的教程，但是却基本不会有什么你在其他地方见到的功能它却没有，在这方面它不输其他非常流行的主题。 Fluid好不好用 当然好用，否则我也不会用了，接下来慢慢讲。 Fluid主题的优点 令人感到如婴儿般舒适的说明文档 说明文档中不仅有详细的流程，还有实例，按照步骤做都能把效果做出来，可谓是保姆教程了。 简洁但灵动的画面效果 主页的打字机效果，文章目录的动画效果（还能自动展开与折叠），在不会给人感觉冗杂的情况下让博客具有灵动的感觉，真的很舒适。 非常齐全的功能 作为收藏数达到5.5k的主题，大部分功能都拥有，再加上舒服的说明文档可以很方便地添加新功能，许多问题也能在issues下找到。 易上手 和Cards主题一样，Fluid主题虽然config文件要长很多，但是很多都在于UI的设置，配合说明文档很快就能配置并跑起来。 移动端的支持比较好 页面间距上给人的阅读体验很不错，公式也会缩进而不会有格式上的问题。唯一的硬伤是它并没有目录缩成一个按钮而是直接取消了目录。 Fluid主题的缺点 这一部分其实倒不如说是期待之后的版本能够改进的地方。 折叠模块的加入 虽然可以依赖第三方的插件，但是选择什么配色方案还是令人纠结，加上我不会css，我更不会写动画效果啥的，希望作者之后能把这个功能集成进去，这个功能确实挺有用的。 进一步适配移动端 目录可以很方便地跳转到文章的选定位置，我觉得这还是比较重要的一个功能，作为md的一大特性，直接将该功能取消实在是非常的可惜，希望能像其他主题一样在移动端或者分屏下能缩成一个按钮。 必须都加封面图或都不加封面图 这一点在说明文档有提到并且作者表示无能为力，我也必须得承认这个是有点吹毛求疵了，毕竟要做到这个真的很难，做封面虽然花时间，但是博客确实会更美观。只能说是Cards主题在这方面做的很好。封面图制作网站 - Canva 总结 如果你的博客以文字为主，希望能快速地使用且界面足够的简洁，那么Cards主题是一个很不错的选择；如果你总是会自己捣鼓插件，并且希望在简洁的同时还能有些舒服的动画效果，那么Fluid主题绝对Cardsd主题更对你的胃口。另外在一开始选择主题的时候，还是应该点进去多翻几个demo看看，有很多东西看预览图是看不出来的。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://yzs020220.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yzs020220.github.io/tags/Hexo/"},{"name":"折腾","slug":"折腾","permalink":"https://yzs020220.github.io/tags/%E6%8A%98%E8%85%BE/"},{"name":"Cards主题","slug":"Cards主题","permalink":"https://yzs020220.github.io/tags/Cards%E4%B8%BB%E9%A2%98/"},{"name":"Fluid主题","slug":"Fluid主题","permalink":"https://yzs020220.github.io/tags/Fluid%E4%B8%BB%E9%A2%98/"}]},{"title":"Hexo美化|Cards主题","slug":"hexo美化-Card主题","date":"2023-01-05T03:43:09.000Z","updated":"2023-03-03T05:45:46.569Z","comments":true,"path":"posts/22490/","link":"","permalink":"https://yzs020220.github.io/posts/22490/","excerpt":"记录了刚开始这个博客怎么美化主题的，希望后来人能少走弯路吧，遇到问题多看官方文档","text":"记录了刚开始这个博客怎么美化主题的，希望后来人能少走弯路吧，遇到问题多看官方文档 官方文档 基本配置 | Theme Cards (ichr.me) 网站图标 favicon的路径设置在source下的目录，打开Card主题文件夹下的_config.yml文件，例： head: # 网站图标 favicon: ico: /img/icon.ico small: /img/icon.png medium: apple_touch_icon: safari_pinned_tab: 具体关于图像尺寸格式请查阅官方文档 封面头像 在cover下： # 封面 cover 设置 cover: # 显示在最上方 cover 处的站点名称 sitename: 的博客 # 若 avatar 配置不为空，则优先使用 avatar 覆盖 sitename avatar: /img/avatar.jpg # sitename/avatar 下方的一句话介绍 description: 颜色配置与代码高亮主题 style下可以设置颜色配置，[色号查询网站](查询色号“null”相关结果 - 千通彩色库 (qtccolor.com))： # 颜色配置 color: main_color: '#26251c' main_color_dark: '#ded7a2' 在highlight中指定默认模式和深色模式使用的代码高亮主题，主题样式可在node_modules-&gt;highlight.js-&gt;styles中查看： # 默认代码高亮 highlight: # 默认代码高亮主题 default: atom-one-light # 暗色代码高亮主题 darkmode: atom-one-dark 文章缩略图 在meta中启用thumbnail： # 文章缩略图 thumbnail: enable: true default: # 默认缩略图，当页面 `thumbnail` 字段为空时 fallback 至此参数 之后只要在front-matter中指定thumbnail即可： thumbnail: /img/.png 博客自动更新日期 我也不太确定是什么时候我博客的更新日期不需要专门指定updated就可以通过博客的更改来更新日期，大概是在_config.yml文件中指定timezone即可： timezone: \"Asia/Shanghai\" 文章目录 meta中启用toc： # 文章目录 toc: enable: true list_number: false 注：文章目录不要使用一级标题，不要跨级使用标题否则会出现乱码，如2级到5级到2级，请严格一级一级使用如2级到3级到2级（hexo博客的特性） 插件 启用站内搜索 启用站内搜索插件： # 站内搜索插件 search: enable: true path: search.json field: All # Page | Post | All 使用cmd新建页面 hexo new page \"search\" 在新建页面下的index.md文档中修改front-matter： --- layout: search --- 启用标签页 cmd新建页面： hexo new page \"tags\" 在新建页面下的index.md文档中修改front-matter： --- layout: tags --- 启用友链 cmd新建页面： hexo new page \"friends\" 在新建页面下的index.md文档中修改front-matter，详见独立页面 | Theme Cards ： --- layout: links links: - name: HCY-ASLEEP url: https://hcy-asleep.github.io avatar: https://hcy-asleep.github.io/images/logo.svg desc: 喜欢ctrl+c（chicken）的男人 tags: [唱, 跳, rap, 篮球] target: _blank backgroundColor: '#226' textColor: '#CC8' --- 设置返回顶部按钮 在主题目录下的_config.yml文件中设置： # 返回顶部 back_to_top: true 折叠内容 在主题目录下的_config.yml文件中设置： fold: enable: true summary: motion: 在文章中需要折叠的内容前后分别添加 &#123;% fold 摘要内容 %&#125; 正文 &#123;% endfold %&#125; 评论系统 这一个颇为麻烦，我本来满心欢喜的点进gitment，gitment用的是github的issues系统来实现评论的，配好之后才发现作者的服务器过期，gitment得转自己的域名，issues里的人都在推荐gitalk，那么就搞gitalk吧gitalk/readme-cn.md at master · gitalk/gitalk (github.com) 安装gitalk npm i --save gitalk 创建Github Application并配置 点击申请链接，HomepageUrl填写你的repo的地址，Authorization callback URL 填写当前使用插件页面的域名，申请后会出现clientID与clientSecret（需要generate一下） 在主题目录下的_config.yml文件中设置： comments: use: gitalk --- # Gitalk gitalk: repo: yzs020220.github.io # 存放评论的仓库（评论会上传到issues上） owner: yzs020220 # github的id clientID: ***** clientSecret: ******** 完成以上步骤基本就可以显示了，初次打开会需要使用github账号登录，生成的评论也都可以在issues中查看，但还会有一个关于中文的问题 解决Error: Validation Failed 中文标题会被转码到很长，而issues的label长度限制在了50个字符，在项目的issues中我找到了解决办法，在cards/layout/_plugins/comments/gitalk目录下打开source.ejs，在gitalk的构造函数中给id加上decodeURI即可。 id: decodeURI(window.location.pathname), 数学公式 见Hexo博客显示数学公式|Card主题 让你的网站能被搜到（SEO但无优化） Google 进入链接，点击立即使用并添加资源 在右边输入你的网址进入html验证 下载html文件放到source下，在根目录下的_config.yml文件中跳过该文件的渲染 skip_render: - 'README.md' - 'google9f6e9cf05881a1e4.html' 同步博客后点击验证即可 Bing 进入webMaster tools直接导入gsc即可 Sitemap 生成站点地图能更好地索引，使用npm命令安装sitemap npm install sitemap --save 在根目录的_config.yml中设置sitemap的路径： sitemap: path: sitemap.xml tag: false category: false 我们只需要在站点地图中，添加新的站点地图中输入sitemap.xml即可","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://yzs020220.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yzs020220.github.io/tags/Hexo/"},{"name":"折腾","slug":"折腾","permalink":"https://yzs020220.github.io/tags/%E6%8A%98%E8%85%BE/"},{"name":"Cards主题","slug":"Cards主题","permalink":"https://yzs020220.github.io/tags/Cards%E4%B8%BB%E9%A2%98/"}]},{"title":"Unity Shader入门精要学习记录","slug":"Unity-Shader入门精要学习记录","date":"2023-01-03T03:09:23.000Z","updated":"2023-03-09T08:26:52.728Z","comments":true,"path":"posts/20934/","link":"","permalink":"https://yzs020220.github.io/posts/20934/","excerpt":"主要记录了学习Shader时，由于版本更新，书中与实际操作中不一样的地方，我的unity版本是2021.3.5，因为是中途开始写的，如有遗漏请见谅","text":"主要记录了学习Shader时，由于版本更新，书中与实际操作中不一样的地方，我的unity版本是2021.3.5，因为是中途开始写的，如有遗漏请见谅 官方勘误列表 都快要把书看完了才发现《Unity Shader入门精要》勘误 附带：《Unity Shader入门精要》随书彩色插图 我的代码仓库 yzs020220/my-unity-shaders-book P35 3.4.2最聪明的孩子：顶点/片元着色器 之后也会用到的，在顶点着色器中将坐标从模型空间转换到世界空间中。代码需include “UnityCG.cginc”（在其他库中经常会被include，比如Lighting.cginc） 修改后代码原代码#include \"UnityCG.cginc\" ··· return UnityWorldToClipPos(v);return mul(UNITY_MATRIX_MVP, v); P101 5.2.1 去掉天空盒 在Window-&gt;Rendering-&gt;Lighting-&gt;Environment-&gt;skybox中 P113 5.5.3最新利器：帧调节器 在Window-&gt;Analysis-&gt;Frame Debugger中 P128 6.4.1逐顶点漫反射光照 在顶点着色器中将法线从模型空间变换到世界空间中 修改后代码原代码fixed3 worldNormal = normalize(mul(v.normal, (float3x3)unity_WorldToObject));fixed3 worldNormal = normalize(mul(v.normal, (float3x3)_World2Object)); P134 6.5.1逐顶点高光反射光照 在顶点着色器中将顶点位置从模型空间变换到世界空间中 修改后代码原代码fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - mul(unity_ObjectToWorld, v.vertex).xyz);fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - mul(Object2World, v.vertex).xyz); P180 9.1渲染路径 Unity的Edit-&gt;Project Settings-&gt;Graphics中能看到不同图像质量下对应的Rendering Path P192 9.2.2处理不同光源的衰减 在Additional Pass的片元着色器中计算不同光源的衰减前，要将片元的坐标转换到光源空间，在采样衰减纹理来得到衰减值 修改后代码原代码float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, 1)).xyz;float3 lightCoord = mul(_LightMatrix0, float4(i.worldPos, 1)).xyz; P226 10.3.1声明程序纹理参数 书中使用了一个开源插件，我个人没有去尝试这个开源插件，可能这个开源插件能够让修改更丝滑一点，考虑到其实我们就是检测inspector中是否被修改，然后调用_UpdateMaterial方法就好，要实现这个我们可以使用onValidate方法，这个方法在inspector中参数被修改时会被调用，这个写法也能让代码简洁很多： 修改后代码原代码[SerializeField] private int textureWidth = 512; [SerializeField] private Color backgroundColor = Color.white; ··· private void OnValidate() &#123; _UpdateMaterial(); &#125;[SerializeField, SetProperty(\"textureWidth\")] private int m_textureWidth = 512;- public int textureWidth &#123; get &#123; return m_textureWidth; &#125; set &#123; m_textureWidth = value; _UpdateMaterial(); &#125; &#125; P245 12.1PostEffectsBase.cs 检查各种资源和条件的代码，在新版本中已经被弃用，返回值总会是True，所以可以不写 using UnityEngine; [ExecuteInEditMode] [RequireComponent(typeof(Camera))] public class PostEffectBase : MonoBehaviour &#123; protected Material CheckShaderAndCreateMaterial(Shader shader, Material material) &#123; if (shader == null) return null; if (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader) return material; if (!shader.isSupported) return null; else &#123; material = new Material(shader); material.hideFlags = HideFlags.DontSave; if (material) return material; else return null; &#125; &#125; &#125; P264 12.6运动模糊 RenderTexture.MarkRestoreExpected会显示已被弃用，具体可以查看官方文档Unity - Scripting API: RenderTexture.MarkRestoreExpected，大概意思是在移动端，Unity会对还原renderTexture的操作进行警告，因为恢复发生在渲染纹理的时候，不将内容清除或丢弃在许多移动端GPU和多GPU系统中需要很大消耗，不过如果你确实需要（就像我们现在写运动模糊），我们仍可以使用该方法禁用警告（感觉好像没完全被禁用，不过是否使用该代码都不会影响运行结果）。 // We are accumulating motion over frames without clear/discard // by design, so silence any performance warnings from Unity accumulationTexture.MarkRestoreExpected(); P275 13.2再谈运动模糊中的片元着色器 如果直接使用书本的代码会有一种很奇怪的感觉，会感觉只是有一大堆重影，总而言之会觉得不对，这是因为物体的运动是有方向的，而书中的代码直接将前两帧和当前帧取平均会让人不知道往哪个方向运动，我在“再谈运动模糊”效果改进建议 · Issue #195 中找到了改进方法，我们可以设置权重，当前帧的权重调大，后两帧权重调小，这样我们就能从三帧混合的图像中知道画面中知道哪一帧在前，我们只需要修改最后对三帧取平均的代码即可 修改后代码原代码float2 velocity = (currentPos.xy - previousPos.xy)/2.0f; float2 uv = i.uv; float vecColRate[3] = &#123; 0.7,0.2,0.1 &#125;; float4 c = tex2D(_MainTex, uv) * vecColRate[0]; uv += velocity * _BlurSize; for (int it = 1; it &lt; 3; it++, uv += velocity * _BlurSize) &#123; float4 currentColor = tex2D(_MainTex, uv); c += currentColor * vecColRate[it]; &#125; return fixed4(c.rgb, 1.0);float2 velocity = (currentPos.xy - previousPos.xy)/2.0f; float2 uv = i.uv; float4 c = tex2D(_MainTex, uv); uv += velocity * _BlurSize; for (int it = 1; it &lt; 3; it++, uv += velocity * _BlurSize) &#123; float4 currentColor = tex2D(_MainTex, uv); c += currentColor; &#125; c /= 3; return fixed4(c.rgb, 1.0); P302 15.2水波效果 难绷，这个地方不能算是一个错误，但还是提上一嘴，看彩图的图片可能会自然地以为地板是经过水的折射形成这个颜色，但其实地板和墙的贴图颜色是不一样的，地板对应的贴图是Wall04那一张贴图（其实观察墙经过水面和地板经过水面的颜色估计也能察觉到了，但是看着图片太想当然了）。 P313 16.3.2性能分析器 点击Window-&gt;Analysis-&gt;Profiler打开 P315 16.4.1动态批处理 如果物体满足条件却没有进行动态批处理，很大可能是没有开启动态批处理，在Edit-&gt;Project Settings-&gt;Player的Other Settings中找到Dynamic Batching并勾选即可。 具体的没有进行动态批处理的原因可以在Frame Debugger中查看到 P336 17.5 编译指令指定参数不要换行 由于书本的排版原因，会让人误以为这个地方要换行，这一句指定参数的编译指令如果换行会报错（在作者github中的代码是正确的） 修改后代码原代码#pragma surface surf CustomLambert vertex:myvert finalColor:mycolor addshadow exclude_path:deferred exclude_path:prepass nometa#pragma surface surf CustomLambert vertex:myvert finalColor:mycolor addshadow exclude_path:deferred exclude_path:prepass nometa P348 18.2 Unity5的Standard Shader（Standard.Shader） 书上说Standard的Shader源代码可以在DefaultResourcesExtra文件夹下找到，但是在新版本中，虽然可以在安装路径下的Editor-&gt;Data-&gt;CGIncludes中查看到相关头文件，但是却找不到DefaultResourcesExtra这个文件夹，根据在网上论坛上翻的一些讨论，这个文件夹应该是被打包了，我们可以在Editor-&gt;Data-&gt;Resources中找到一个叫unity-builtin-extra的文件，这个文件是打不开的。如果真的要查看Standard.Shader的源代码，我在github上找到一个项目是比较全的：unity-built-in-shaders，各个版本也可以在branches中查看。 P352 18.3一个更加复杂的例子 需要将导入的.HDR文件的Texture Shape设置为Cube，在Lighting-&gt;Scene中需先点击New Lighting Settings然后启用Realtime Global Illumination，建议先拖拽贴图，然后再拖拽项目内的材质，如果是自己新建材质并拖拽贴图（Shader选择Specular Setup），贴图与材质属性大致对应如下： 材质属性 贴图后缀 Albedo a Specular sg Normal Map n Occlusion o Detail Mask m 还有一些木头材质（如桶、棚）需要设置Secondary Map，还是建议拖拽贴图后拖拽材质，有不少参数需要调整。 场景中物体没有阴影 如果发现物体没有阴影，很可能不是Shader的问题，而是需要设置光源的Shadow Type（默认的平行光会产生阴影，自己手动创建的光源默认Shadow Type为No Shadows，删除默认光源后创建的光源需重新设置）","categories":[{"name":"Unity","slug":"Unity","permalink":"https://yzs020220.github.io/categories/Unity/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://yzs020220.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Unity Shader","slug":"Unity-Shader","permalink":"https://yzs020220.github.io/tags/Unity-Shader/"}]},{"title":"Hexo博客显示数学公式|Cards主题","slug":"博客显示数学公式-Card主题","date":"2022-12-30T05:09:07.000Z","updated":"2023-11-28T12:20:37.030Z","comments":true,"path":"posts/46597/","link":"","permalink":"https://yzs020220.github.io/posts/46597/","excerpt":"痛，太痛了","text":"痛，太痛了 前言 最早的时候上网搜的大致流程是安装hexo-filter-mathjax然后安装渲染器hexo-renderer-kramed，但是我在装kramed的时候说highlight的版本不兼容，装的是最新版11.x需要的版本是9.x，也不怎么想调版本，打开hexo-filter-mathjax的readme文档，它推荐安装的渲染器是hexo-renderer-pandoc，我们只要使用hexo-filter-mathjax和hexo-renderer-pandoc即可（由于折腾的时候卡了不少步骤，我不能保证里面的每个步骤都是必须的，但是应该没问题）。 之后我又遇到了一个非常难受的问题，那就是不知道为什么pandoc的表格渲染出来，表头和表格会分开，哇真的太难看了，我上网查也没找到问题所在，于是我尝试装了kramed，实际上kramed虽然会警告但其实是不会有影响的，然而kramed其实对公式的支持还是一言难尽，我在渲染多行公式的时候下面的文字以及行号会出问题，在终于接受Mathjax实在没办法同时解决上述这两个问题后，我决定使用KateX，于是我也开始后悔为什么没早用KateX。 下面我也会分Mathjax和KateX的配置方法分开来讲（如果你没有特别需要，那么我还是推荐KateX，两者的区别在网上也能看得到）。 需要注意的是博客的Front-matter的选项取决于你的主题，我这里的是Cards主题，具体请查看主题的文档 Mathjax hexo-filter-mathjax 先检查是否安装了hexo-math npm list hexo-math 如果出现empty则表示没有安装，否则我们需要先卸载 npm uninstall hexo-math --save 安装hexo-filter-mathjax npm install hexo-filter-mathjax --save 打开根目录下的_config.yml，不是主题的那个，添加如下代码，该代码的解释可以在hexo-filter-mathjax的reame文档找到 # Mathjax mathjax: tags: none # or 'ams' or 'all' single_dollars: true # enable single dollar signs as in-line math delimiters cjk_width: 0.9 # relative CJK char width normal_width: 0.6 # relative normal (monospace) width append_css: true # add CSS to pages rendered by MathJax every_page: false # if true, every page will be rendered by MathJax regardless the `mathjax` setting in Front-matter packages: # extra packages to load extension_options: &#123;&#125; # you can put your extension options here # see http://docs.mathjax.org/en/latest/options/input/tex.html#tex-extension-options for more detail hexo-renderer-pandoc 卸载hexo-renderer-marked，不再赘述原生的渲染器有什么问题了 npm uninstall hexo-renderer-marked 安装Pandoc Pandoc - Installing pandoc npm安装hexo-renderer-pandoc npm install hexo-renderer-pandoc 在根目录下的_config.yml指定pandoc的路径能够更快地找到pandoc（官方文档大概是这个意思） # pandoc pandoc: # 此处填的是你的pandoc的路径 pandoc_path: \"C:/Users/Jason/AppData/Local/Pandoc/pandoc.exe\" filters: extra: template: meta: mathEngine: # 默认为mathjax 公式格式 公式格式为lateX，需要注意的是公式的注意事项，在readme文档都有写，在node_modules文件夹下找到对应的模块即可找到文档，这里还是归纳出来： 在Front-matter中添加： --- mathjax: true --- 行内公式$不要贴着加空格，也就是开头的$的后面以及结尾的$的前面不要加空格，例： -$ \\epsilon_0 $ +$\\epsilon_0$ -$ \\frac&#123;\\partial&#125;&#123;\\partial t&#125; $ +$\\frac&#123;\\partial&#125;&#123;\\partial t&#125;$ 行间公式的$$注意中间只能有一行，不要出现额外的回车，例： +$$ +i\\hbar\\frac&#123;\\partial&#125;&#123;\\partial t&#125;\\psi=-\\frac&#123;\\hbar^2&#125;&#123;2m&#125;\\nabla^2\\psi+V\\psi +$$ -$$ -i\\hbar\\frac&#123;\\partial&#125;&#123;\\partial t&#125;\\psi=-\\frac&#123;\\hbar^2&#125;&#123;2m&#125;\\nabla^2\\psi+V\\psi - -$$ 多行的显示在mathjax3.0中不再支持\\\\，可以用\\displaylines，issues链接，例： +\\displaylines&#123;x+y=1\\\\2x+y=3&#125; -x+y=1\\\\2x+y=3 KateX 首先要说的是关于格式，KateX的换行直接使用\\\\即可，所以用KateX就能比较准确地对上Markdown预览的格式。接下来我们来说步骤。 hexo-renderer-markdown-it-plus 卸载本来的渲染器 安装渲染器hexo-renderer-markdown-it-plus，自动包含了hexo-renderer-markdown-it-katex该渲染器对katex支持得很好，同时比原生的marked渲染器还快，比pandoc就更快了 npm i hexo-renderer-markdown-it-plus --save 在根目录下的_config.yml文件中添加配置代码 markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ pre_class: highlight 使用KateX 在根目录下的_config.yml文件中添加math模块，指定engine # Math Equations Render Support math: enable: true # Default(true) will load mathjax/katex script on demand # That is it only render those page who has 'mathjax: true' in Front Matter. # If you set it to false, it will load mathjax/katex srcipt EVERY PAGE. per_page: true #engine: mathjax engine: katex 在文章的Front-matter中添加： --- katex: true --- 碎碎念 本来是在写别的博客，突然要写一条公式才发现显示公式还挺麻烦的，当时选Card主题也是因为比较戳我，不过其实看网上我还是感觉Next主题的教程实在是丰富，不过我本来也是喜欢折腾的人，如果这篇博客能帮到谁那也是很不错的。 难蚌，因为大部分的博客都比较老了，所以上网搜索的话其实很可能直接就选Mathjax，毕竟基数大。总之各有好处吧，问题的出现总是很突然，说不定我用着用着KateX也出问题。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://yzs020220.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yzs020220.github.io/tags/Hexo/"},{"name":"折腾","slug":"折腾","permalink":"https://yzs020220.github.io/tags/%E6%8A%98%E8%85%BE/"},{"name":"Cards主题","slug":"Cards主题","permalink":"https://yzs020220.github.io/tags/Cards%E4%B8%BB%E9%A2%98/"}]},{"title":"光照模型","slug":"光照模型","date":"2022-12-30T01:50:08.000Z","updated":"2022-12-31T04:08:08.000Z","comments":true,"path":"posts/34941/","link":"","permalink":"https://yzs020220.github.io/posts/34941/","excerpt":"几种光照模型有什么不同","text":"几种光照模型有什么不同 进入摄像机光线的四个部分 自发光部分（emissive） 高光反射部分（specular） 漫反射（diffuse） 环境光（ambient） 逐像素与逐顶点 在片元着色器中计算，即逐像素光照，在顶点着色器中计算，即逐顶点光照。 在逐像素光照中，以每个像素为基础，对顶点法线进行插值（也可以从法线纹理中采样）得到它的法线，这种在面片之间对顶点法线进行插值的技术也被称为Phong着色（不同于Phong光照模型）。 逐顶点光照，也被称为高洛德着色（Gouraud shading），在逐顶点光照中，计算每个顶点上的光照，然后在渲染图元内部进行线性插值，最后输出成像素颜色。由于顶点数目往往远小于像素数目，所以计算量很小。但是，逐顶点光照依赖于线性插值，当光照模型的计算有非线性的计算（例如计算高光反射）时，逐顶点光照就会出现问题，渲染图元内部的颜色总会暗于顶点处的最高颜色值（通过插值计算得到的），某些情况下会导致非常明显的棱角现象。 漫反射光照模型 兰伯特光照模型公式： cdiffuse =(clight ⋅mdiffuse )max⁡(0,n^⋅l^)c_{\\text {diffuse }}=(c_{\\text {light }} \\cdot m_{\\text {diffuse }}) \\max (0, \\hat{n} \\cdot \\hat{l}) cdiffuse ​=(clight ​⋅mdiffuse ​)max(0,n^⋅l^) 半兰伯特光照模型，为了解决兰伯特光照模型背光面的明暗一致问题，Valve在开发游戏《半条命》时提出的一种技术，公式如下： cdiffuse=(clight⋅mdiffuse)(α(n^⋅l^)+β)c_{\\text {diffuse}}=(c_{\\text {light}} \\cdot m_{\\text {diffuse}})(\\alpha (\\hat{n}\\cdot\\hat{l})+\\beta) cdiffuse​=(clight​⋅mdiffuse​)(α(n^⋅l^)+β) 半兰伯特模型对n^⋅l^\\hat{n}\\cdot\\hat{l}n^⋅l^进行了一个α\\alphaα倍的缩放和一个β\\betaβ大小的偏移，一般α\\alphaα和β\\betaβ都取0.5，公式也就变成： cdiffuse=(clight⋅mdiffuse)(0.5(n^⋅l^)+0.5)c_{\\text {diffuse}}=(c_{\\text {light}} \\cdot m_{\\text {diffuse}})(0.5 (\\hat{n}\\cdot\\hat{l})+0.5) cdiffuse​=(clight​⋅mdiffuse​)(0.5(n^⋅l^)+0.5) 可以看出，不同的地方就是用什么方法将[−1,1][-1,1][−1,1]映射到[0,1][0,1][0,1]，在半兰伯特模型中，负值不是直接映射为0，而是映射到[0,0.5][0,0.5][0,0.5]（取决于你的参数），从而使得背光面也有明暗变化。 需要注意的是，半兰伯特是没有任何物理依据的，它仅仅是一个视觉增强技术。 高光反射光照模型 Phong光照模型 Phong光照模型非常的直观，反射后的光线会进入眼睛，我们只需要计算反射方向与视角方向的夹角就可以得知反射光有多少光线进入眼睛。 高光反射部分的计算公式： cspecular=(clight⋅mspecular)max⁡(0,v^⋅r^)mglossc_{\\text{specular}}=(c_{\\text{light}}\\cdot m_{\\text{specular}}){\\max(0, \\hat{v}\\cdot\\hat{r})}^{m_{\\text{gloss}}} cspecular​=(clight​⋅mspecular​)max(0,v^⋅r^)mgloss​ 从公式可以看出，高光反射的计算需要四个四个参数：入射光线的颜色和强度clightc_{\\text{light}}clight​，材质的高光反射系数mspecularm_{\\text{specular}}mspecular​，视角方向v^\\hat{v}v^以及反射方向r^\\hat{r}r^。其中，反射方向可以由表面法线n^\\hat{n}n^和光源方向l^\\hat{l}l^计算而得： r^=l^−2(n^⋅l^)n^\\hat{r}=\\hat{l}-2(\\hat{n}\\cdot\\hat{l})\\hat{n} r^=l^−2(n^⋅l^)n^ 上述公式非常简单，甚至在Unity Shader和OpenGL中，都有reflect函数可以直接使用。 Blinn-Phong光照模型 Blinn-Phong光照模型稍微有一点绕，它避免了计算反射方向r^\\hat{r}r^，你可以想象你在你的头上举一个手电筒，打在一面镜子上，当镜子朝向你的眼睛和手电筒连线的中点时，那么反射出来的光线会正好照在你的眼睛里，因此我们只需要计算朝向中点的方向与镜子朝向的角度（即法向）的夹角即可。 Blinn模型引入了一个新的向量h^\\hat{h}h^（代码中一般的命名是halfDir），它是由视角方向v^\\hat{v}v^和光源方向l^\\hat{l}l^取平均后再归一化得到的： h^=v^+l^∣v^+l^∣\\hat{h}=\\frac{\\hat{v}+\\hat{l}}{|\\hat{v}+\\hat{l}|} h^=∣v^+l^∣v^+l^​ 然后，使用n^\\hat{n}n^和h^\\hat{h}h^之间的夹角进行计算，公式如下： cspecular=(clight⋅mspecular)max⁡(0,n^⋅h^)mglossc_{\\text{specular}}=(c_{\\text{light}}\\cdot m_{\\text{specular}}){\\max(0, \\hat{n}\\cdot\\hat{h})}^{m_{\\text{gloss}}} cspecular​=(clight​⋅mspecular​)max(0,n^⋅h^)mgloss​ 两种光照模型的对比 当摄像机和光源距离模型足够远时，Blinn模型会快于Phong模型，因为可以认为v^\\hat{v}v^和l^\\hat{l}l^为定值，则h^\\hat{h}h^将会是一个常量。但是当v^\\hat{v}v^和l^\\hat{l}l^不为定值时，Phong模型可能反而会更快一些。需要注意的是，两者都是经验模型，我们不应该认为Phong模型更加的正确，实际上在一些情况下，Blinn模型更符合实验结果。 解释图源《Unity Shader入门精要》","categories":[{"name":"学","slug":"学","permalink":"https://yzs020220.github.io/categories/%E5%AD%A6/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://yzs020220.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"图形学","slug":"图形学","permalink":"https://yzs020220.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"基于openGL的船只航行模拟与水模拟","slug":"计算机图形学大作业","date":"2022-12-28T01:57:33.000Z","updated":"2023-11-28T12:16:46.914Z","comments":true,"path":"posts/34890/","link":"","permalink":"https://yzs020220.github.io/posts/34890/","excerpt":"计算机图形学大作业","text":"计算机图形学大作业 项目地址 yzs020220/Sailing-Stimulation-using-openGL: 基于openGL的船只航行模拟与水模拟 (github.com) 引言 因为这次实验花费了比较多的时间，个人感觉自己完成的也很不错，但是当时交报告实在是不太够时间写，所以专门写一篇博客，来记录一下（可能是刚刚建起来的博客实在是太空了，所以写一下丰富一下博客的内容）。 虽然花费了比较多的时间，但其实还是有一些不尽如人意的地方，比如我尝试将Phong光照模型应用在水上，但是却会出错，不知道为什么Phong光照模型总是只会返回大概2/3水面的效果，剩下1/3几乎是全黑的，于是只好放弃做水面的光照效果了，毕竟时间有限。 现在现实游戏里的水面大部分使用的是顶点动画来制作的，而我在这次作业中更新顶点的方法是简单粗暴地删除平面后添加平面，因为最近还在学Unity Shader入门精要，等到看到这部分的内容之后也许会来做补充（挖个坑） 现在在游戏里比较经典的做法是用噪声纹理作为高度图，不断修改水面的法向，不过比较麻烦的是，在我们这一次作业里没有读取法线的方法（已经做完作业了也不想写），上网去找了github的代码我没翻到用法线贴图做的，虽然别人做的效果都很不错，但是我也不太想研究是怎么弄出来的（OpenGL每个人配的环境都不太一样），我也尝试了将菲涅耳反射应用在水面中，但法线还是不行，因为水面本身获得的光照就不正确。 我在github中翻到的看着效果挺不错的一个项目，我反正没有尝试过。opengl_examples: Collection of examples for OpenGL: Perlin noise, ambient occlusion, shadow mapping, water reflection and others 详细步骤 水面实现 参考博客：(65条消息) [OpenGL] 动态的水面模拟_ZJU_fish1996的博客-CSDN博客_opengl水面 我更推荐看这篇博客来了解实现思路，其实水面模拟不是一件很困难的事情，我主要是创建了一个Fluid类继承TriMesh，实现思路都是大相径庭的。 水的平面可以看成是一个正方形平面，不同的是它不是只有四个顶点，而是由多个四顶点的正方形平面构成的一个网格： 根据我们每一条边的顶点数n+1，计算出每个相邻顶点的间距，然后再根据顺序计算出各顶点的坐标与纹理坐标： float step = 1.0f / n; // 计算顶点位置 for (float i = 0; i &lt; n + 1; i++) &#123; for (float j = 0; j &lt; n + 1; j++) &#123; vertex_positions.push_back(glm::vec3(-0.5f + step * j, 0, -0.5f + step * i)); vertex_colors.push_back(color); vertex_textures.push_back(glm::vec2(step * j, step * i)); &#125; &#125; 根据网格的坐标计算出每个三角面片的顶点下标，颜色法向纹理的下标跟面片的顶点下标相同，最后调用storeFacesPoints方法将信息存储到需要传入GPU的数据： // 每个三角面片的顶点下标 for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; int a, b, c, d; a = i * (n + 1) + j; b = a + 1; c = b + n; d = c + 1; faces.push_back(vec3i(a, b, c)); faces.push_back(vec3i(b, c, d)); &#125; &#125; normal_index = faces; color_index = faces; texture_index = faces; storeFacesPoints(); 在main.cpp中的init方法中生成水平面，设置坐标旋转与大小，并将其与贴图加载到painter容器中： water->generateSurface(30, glm::vec3(0.0, 0.0, 0.0), 0.03f, 0.0f, 0.05f); water->coefficientCount(0.1f); water->setTranslation(glm::vec3(0, 0.25, 0)); water->setRotation(glm::vec3(0, 0, 0)); water->setScale(glm::vec3(waterScale, 1.0, waterScale)); painter->addMesh(water, \"mesh_water\", \"./assets/water1.jpg\", vshader, fshader, 2); meshList.push_back(water); 完成这一步骤之后我们应该能生成一个网格，如果直接生成应该能看到一个平面，想看到网格我们可以调整mesh的绘制模式，在MeshPainter.cpp文件下的drawMesh函数下调用glDrawArrays的参数中将GL_TRIANGLES换成GL_LINE_STRIP即可（可能需要更多参数，如报错请自行上网搜索），该步骤非必须，但是我建议你如果出现不知道什么问题试一下这个方法能让你更直观地观察这个平面是长什么样的 水的波动实现 水波的运动位移满足微分方程，其中ccc是波速，是μ\\muμ描述阻力大小的系数，xyzxyzxyz是空间坐标，ttt是时间： ∂2z∂t2=c2(∂2z∂x2+∂2z∂y2)−μ∂z∂t\\frac {∂^2 z}{∂t^2}=c^2 (\\frac{∂^2 z}{∂x^2}+\\frac{∂^2 z}{∂y^2 })-μ \\frac{∂z}{∂t} ∂t2∂2z​=c2(∂x2∂2z​+∂y2∂2z​)−μ∂t∂z​ 这个方程的求解比较复杂，我们也不是使用代码来求解，所以我们直接关注用近似的方法得到的在i，j点的顶点的z方向上的位移公式： z(i,j,k+1)=4−8c2t2/d2μt+2z(i,j,k)+μt−2μt+2z(i,j,k−1)+2c2t2/d2μt+2[z(i+1,j,k)+z(i−1,j,k)+z(i,j+1,k)+z(i,j−1,k)]z(i,j,k+1)=\\frac{4-8c^2 t^2/d^2}{μt+2} z(i,j,k)+\\frac{μt-2}{μt+2} z(i,j,k-1) \\\\ +\\frac{2c^2 t^2/d^2}{μt+2}[z(i+1,j,k)+z(i-1,j,k)+z(i,j+1,k)+z(i,j-1,k)] z(i,j,k+1)=μt+24−8c2t2/d2​z(i,j,k)+μt+2μt−2​z(i,j,k−1)+μt+22c2t2/d2​[z(i+1,j,k)+z(i−1,j,k)+z(i,j+1,k)+z(i,j−1,k)] 其中k代表所在的帧，我们要计算下一帧需要依赖当前帧与上一帧的结果。 为了保证迭代方程收敛，ttt和ccc满足如下条件： 0&lt;t&lt;μ+μ2+32c2/d28c2/d20&lt;t&lt;\\frac{μ+\\sqrt{μ^2+32c^2/d^2}}{8c^2/d^2} 0&lt;t&lt;8c2/d2μ+μ2+32c2/d2​​ 0&lt;c&lt;d2tμt+20&lt;c&lt;\\frac{d}{2t} \\sqrt{μt+2} 0&lt;c&lt;2td​μt+2​ 接下来只需要跟据位移公式写出对应代码即可，在coefficientCount方法下计算出2）中公式的三个系数k1，k2，k3，这一步在初始化水平面时计算一次即可： void Fluid::coefficientCount(float t) &#123; float f1 = c * c * t * t / d / d; float f2 = 1.0f / (u * t + 2); k1 = (4 - 8 * f1) * f2; k2 = (u * t - 2) * f2; k3 = 2 * f1 * f2; &#125; 在generateSurface方法下随机化vpb的坐标（即上一帧，若与当前帧相同则水面保持稳定），在openGL水面高度对应的是y轴坐标： // 随机化之前的坐标 for (int i = 1; i &lt; n; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; tmp = rand() % 2; vpb[i * (n + 1) + j].y = d * (tmp - 0.5f) * 0.5f; &#125; &#125; 在方法updateSurfacePosition中根据公式更新顶点位置，其中vertex_positions存储当前顶点位置，vpa和vpb分别存储下一帧与上一帧的顶点位置信息。最后将坐标值转换成需要传入GPU的信息： void Fluid::updateSurfacePosition() &#123; // 顶点位置为最新的顶点 vertex_positions = vpa; for (int i = 0; i &lt; numOfWidth + 1; i++) &#123; for (int j = 0; j &lt; numOfWidth + 1; j++) &#123; float curY = vertex_positions[i * (numOfWidth + 1) + j].y; float beforeY = vpb[i * (numOfWidth + 1) + j].y; float updateY = k1 * curY + k2 * beforeY; float deltaY = 0.0f; if (i > 0) deltaY += vertex_positions[(i - 1) * (numOfWidth + 1) + j].y; if (i &lt; numOfWidth) deltaY += vertex_positions[(i + 1) * (numOfWidth + 1) + j].y; if (j > 0) deltaY += vertex_positions[i * (numOfWidth + 1) + j - 1].y; if (j &lt; numOfWidth) deltaY += vertex_positions[i * (numOfWidth + 1) + j + 1].y; updateY += deltaY * k3; vpa[i * (numOfWidth + 1) + j].y = updateY; &#125; &#125; // 之前的顶点位置变成当前顶点位置，当前更新为计算出后的顶点位置 vpb = vertex_positions; vertex_positions = vpa; int j = 0; for (int i = 0; i &lt; faces.size(); i++) &#123; // 坐标 points[j++] = vertex_positions[faces[i].x]; points[j++] = vertex_positions[faces[i].y]; points[j++] = vertex_positions[faces[i].z]; &#125; &#125; 给MeshPainter类添加replaceMesh方法，弹出最后一个mesh并添加新的mesh来更新水面的顶点信息（修改顶点位置不是通过模式变化矩阵来完成，而是直接修改了mesh的points变量，所以只能用这个方法），此处使用的方法其实有非常大的内存隐患，这个vector容器使用的类型是TriMesh而压入栈与弹出栈的是Fluid类，不过这毕竟只是一个作业所以我觉得能跑起来比什么都重要，这种地方要改都是牵一发而动全身： void MeshPainter::replaceMesh(TriMesh* mesh, const std::string&amp; name, const std::string&amp; texture_image, const std::string&amp; vshader, const std::string&amp; fshader, int type) &#123; mesh_names.pop_back(); mesh_names.push_back(name); meshes.pop_back(); meshes.push_back(mesh); mesh_types.pop_back(); mesh_types.push_back(type); openGLObject object; // 绑定openGL对象，并传递顶点属性的数据 bindObjectAndData(mesh, object, texture_image, vshader, fshader); opengl_objects.pop_back(); opengl_objects.push_back(object); &#125;; 在main函数中打开窗口的循环中调用replaceMesh方法将更新顶点后的水替换上去，t表示循环3次更新一次顶点，如果更新频率太高水会非常的鬼畜： if (t > 3) &#123; t = 0; water->updateSurfacePosition(); painter->replaceMesh(water, \"mesh_water\", \"./assets/water1.jpg\", vshader, fshader, 2); &#125; 船的模型读取与添加贴图 在网上的许多obj模型文件用代码读取有时会出现贴图错误的问题，这是因为obj模型文件有两种版本的格式，两种格式的uv mapping的方式不同，如果你使用blender可以看到导出文件时的obj有两个选项分别是.obj与.obj(legacy)，我们可以使用blender打开模型文件（blender对fbx格式的模型文件支持比较好），再转成.obj(legacy)，关于贴图最好选择只有一张贴图的模型，而不是在mtl文件中带有多张贴图。 使用readObj读取🚢模型文件，并在addMesh中指定贴图文件即可（🦈和🪨也是同理）： ship->setNormalize(true); ship->readObj(\"./assets/ship.obj\"); // 设置物体的旋转位移 ship->setTranslation(glm::vec3(0.0, 0.5, 0.0)); ship->setRotation(glm::vec3(0.0, -65.0, 0.0)); ship->setScale(glm::vec3(1.0, 1.0, 1.0)); // 设置材质 ship->setAmbient(mat_ambient); // 环境光 ship->setDiffuse(mat_diffuse); // 漫反射 ship->setSpecular(mat_specular); // 镜面反射 ship->setShininess(shine); //高光系数 painter->addMesh(ship, \"mesh_ship\", \"./assets/Texture_01_A.png\", vshader, fshader, 3); meshList.push_back(ship); 将Phong着色应用在船上 在shader文件fshader.frag中（修改后缀名有语法提示方便修改代码，只需要修改后缀名并安装glsl扩展即可）实现Phong光照模型（如不了解可以去看看博客里的光照模型文章），取一个权重将它和纹理混合起来（本来shader中应该避免用if等条件判断，gpu执行逻辑计算需要绕弯而且都是对多个顶点或片元来执行，但是由于时间问题来不及重构代码，建议开多个shader文件并在drawmesh的时候根据类型指定使用的shader）： // 贴图+Phong光照 else if(type == 3)&#123; // 将顶点坐标、光源坐标和法向量转换到相机坐标系 vec3 pos = position - eye_position; vec3 norm = (vec4(normal, 0.0)).xyz; vec3 l_pos = light.position - eye_position; vec3 N = normalize(norm); vec3 V = normalize(-pos); vec3 L = normalize(l_pos - pos); vec3 R = reflect(-L, N); // 环境光分量I_a vec4 I_a = light.ambient * material.ambient; // @TODO: Task2 计算系数和漫反射分量I_d float diffuse_dot = max(dot(L, N), 0); vec4 I_d = diffuse_dot * light.diffuse * material.diffuse; // @TODO: Task2 计算系数和镜面反射分量I_s float specular_dot_pow = pow(max(dot(R, V), 0), material.shininess); vec4 I_s = specular_dot_pow * light.specular * material.specular; vec4 I = I_a + I_d + I_s; if( dot(L, N) &lt; 0.0 ) &#123; I_s = vec4(0.0, 0.0, 0.0, 1.0); &#125; fColor = texture(texture1, texCoord) * 0.7 + I * 0.3; fColor.a = 1; &#125; 在init函数下设定光源 // 设置光源位置 light->setTranslation(glm::vec3(0.0, waterScale / 2, -waterScale / 2)); light->setAmbient(glm::vec4(1.0, 1.0, 1.0, 1.0)); // 环境光 light->setDiffuse(glm::vec4(1.0, 1.0, 1.0, 1.0)); // 漫反射 light->setSpecular(glm::vec4(1.0, 1.0, 1.0, 1.0)); // 镜面反射 light->setAttenuation(1.0, 0.45, 0.075); // 衰减系数 设定船的材质参数 glm::vec4 mat_ambient = &#123; 1, 1, 1,1.0f &#125;; glm::vec4 mat_diffuse = &#123; 1, 1, 1, 1.0f &#125;; glm::vec4 mat_specular = &#123; 0.5f, 0.5f, 0.5f, 1.0f &#125;; float shine = 200.0f; 计算船的阴影并投影到平面上 在meshPainter类下修改drawMesh函数，当类型为3时绘制阴影（投射到y=0的平面上）： // 阴影绘制 if (type == 3) &#123; // 三角形阴影绘制 glBindVertexArray(object.vao); // 根据光源位置，计算阴影投影矩阵 glm::mat4 shadowProjMatrix = light->getShadowProjectionMatrix(); modelMatrix = shadowProjMatrix * modelMatrix; glUniform1i(object.typeLocation, 5); // 传递 unifrom 关键字的矩阵数据。 glUniformMatrix4fv(object.modelLocation, 1, GL_FALSE, &amp;modelMatrix[0][0]); glUniformMatrix4fv(object.viewLocation, 1, GL_TRUE, &amp;camera->viewMatrix[0][0]); glUniformMatrix4fv(object.projectionLocation, 1, GL_TRUE, &amp;camera->projMatrix[0][0]); // 绘制 glDrawArrays(GL_TRIANGLES, 0, mesh->getPoints().size()); &#125; 修改fshader.frag（最好另开shader文件），当type为5时绘制阴影（颜色输出为黑色）： // 阴影 else if (type == 5) &#123; fColor = vec4(0.0, 0.0, 0.0, 1.0); &#125; 船的移动与旋转 在TriMesh类中添加Movement方法（因为模型读取不一定是摆正的，所以需要一个初始的修正），船的航行是向前的，不能像螃蟹一样横着走，所以他的位移要乘上当前旋转的角度： void TriMesh::movement(float speed) &#123; float theta = 0.005; setTranslation(glm::vec3( translation.x + speed * theta * -sin(glm::radians(rotation.y + 65)), translation.y, translation.z + speed * theta * -cos(glm::radians(rotation.y + 65)))); &#125; 添加changeDir方法，修改船在y轴上的旋转（Movement应用了y轴的旋转，所以可以做到转向航行）： void TriMesh::changeDir(float dir) &#123; float theta = 0.2; rotation.y += dir * theta; &#125; 添加键盘监听，修改全局变量speed和dir（w、s加速减速，a、d向左向右）： // 键盘响应函数 void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode) &#123; if (action == GLFW_PRESS) &#123; switch (key) &#123; case GLFW_KEY_ESCAPE: exit(EXIT_SUCCESS); break; case GLFW_KEY_H: printHelp(); break; case GLFW_KEY_2: controlShark = true; speed = 0; dir = 0; break; case GLFW_KEY_1: controlShark = false; speed = 0; dir = 0; break; case GLFW_KEY_W: speed += 1; printMsg(); break; case GLFW_KEY_S: speed -= 1; printMsg(); break; case GLFW_KEY_A: dir += 1; printMsg(); break; case GLFW_KEY_D: dir -= 1; printMsg(); break; default: camera->keyboard(key, action, mode); break; &#125; &#125; &#125; 船只跟随水面高低波动，由于水面时高时低，在y轴上不会有位移的船很容易变成潜水艇或者飞船，所以要根据所在水面的顶点位置更新它的y轴位置，由于水面的网格的x，z值不会发生改变，我们只要根据船所在的位置映射到当前水面并获取周围的四个顶点的y值，计算出当前水面相对初始值的偏移量： float Fluid::getOffset(glm::vec3 pos) &#123; float x = pos.x; float z = pos.z; int i = (x + 0.5) * (numOfWidth + 1.0); int j = (z + 0.5) * (numOfWidth + 1.0); if (i &lt; numOfWidth + 1 &amp;&amp; j &lt; numOfWidth + 1 &amp;&amp; i >= 0 &amp;&amp; j >= 0) &#123; float ay = vertex_positions[i * (numOfWidth + 1) + j].y; float by = vertex_positions[i * (numOfWidth + 1) + j + 1].y; float cy = vertex_positions[(i + 1) * (numOfWidth + 1) + j].y; float dy = vertex_positions[(i + 1) * (numOfWidth + 1) + j + 1].y; return (ay + by + cy + dy) / 4; &#125; return 0.0f; &#125; 根据offset加入船只的左右前后晃动，让它更有在海上的感觉： void TriMesh::shake(float offset) &#123; rotation.x = offset * 60; rotation.z = offset * 30; &#125; 在main函数中根据速度和方向调用movement和changeDir函数并根据偏移值在main函数中实时更新船只的y轴坐标并调用： ship->movement(speed); if(fabs(speed) > 0.01f) &#123; ship->changeDir(dir); glm::vec3 pos = ship->getTranslation(); pos.y = 0.5; camera->focus(glm::vec4(pos, 1.0f)); camera->updateCamera(); &#125; glm::vec3 pos = ship->getTranslation(); float offset = water->getOffset(pos / waterScale); pos.y = 0.5 + offset / 10; ship->setTranslation(pos); ship->shake(offset); 相机跟随 为Camera类添加focus方法，修改at： void Camera::focus(glm::vec4 _at) &#123; at = _at; &#125; 修改updateCamera方法，让相机跟随焦点位置更新： eye = at + glm::vec4(eyex, eyey, eyez, 1.0); 天空盒的实现 从网上下载一个天空盒图片切成6张图片（可以在网上找设定像素切割的工具，如果你是PS好手也可以直接处理，暗藏玄🐔） 直接生成6个正方形平面拼起来，不想赘述了，简单的很 skybox1->generateSquare(glm::vec3(0.0, 0.0, 0.0)); skybox1->setTranslation(glm::vec3(0.0, waterScale / 15, -waterScale / 2)); skybox1->setRotation(glm::vec3(0.0, 0.0, 0.0)); skybox1->setScale(glm::vec3(waterScale, waterScale, waterScale)); painter->addMesh(skybox1, \"skybox1\", \"./assets/_skybox_6.jpg\", vshader, fshader, 1); meshList.push_back(skybox1); 水的半透明效果 在fshader中修改水输出颜色的透明度： // 水 else if(type == 2)&#123; fColor = texture(texture1, texCoord); fColor.a = 0.7; &#125; 透明效果详细来讲的话会涉及非常多的东西，简略地讲，我们就是将前面的透明物体与后面的物体的颜色进行混合，混合因子就是控制它们的系数，我们选择用透明度与1-透明度作为混合因子，启动混合功能并设置混合函数，最后在设置深度缓冲区为读写： void display() &#123; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); painter->drawMeshes(light, camera); glDepthMask(GL_TRUE); &#125; 最终结果","categories":[{"name":"学","slug":"学","permalink":"https://yzs020220.github.io/categories/%E5%AD%A6/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://yzs020220.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"作业","slug":"作业","permalink":"https://yzs020220.github.io/tags/%E4%BD%9C%E4%B8%9A/"}]},{"title":"Hexo guide","slug":"hexo-guide","date":"2022-12-28T01:05:52.000Z","updated":"2023-03-03T05:45:46.617Z","comments":true,"path":"posts/48031/","link":"","permalink":"https://yzs020220.github.io/posts/48031/","excerpt":"一个拿来提醒自己怎么上传文章与修改网站的博客","text":"一个拿来提醒自己怎么上传文章与修改网站的博客 链接 (Markdown 语法速查表 | Markdown 官方教程) 文章头 文章更新日期 update: tags后跟标签 tags: [标签1, 标签2] 文章缩略图（根目录为source），或者在线图片链接，以下为本地方法 thumbnail: /img/文件路径 文章详细信息，要在结尾添加 &lt;!-- more --> 文章上传 新建文章 hexo new \"title\" // 标题替换掉title 同步博客 hexo clean // 清楚静态页面缓存（清除public文件夹） hexo g // 在本地生成静态页面（生成public文件夹） hexo d // 远程部署，同步到github （可选）启动本地服务，Ctrl+C终止服务 hexo s // 本地服务 http://localhost:4000 给cmd挂代理(用于装包装不上的时候) set http_proxy=\"http://127.0.0.1:7890\" set https_proxy=\"http://127.0.0.1:7890\"","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://yzs020220.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yzs020220.github.io/tags/Hexo/"},{"name":"自用","slug":"自用","permalink":"https://yzs020220.github.io/tags/%E8%87%AA%E7%94%A8/"},{"name":"学习","slug":"学习","permalink":"https://yzs020220.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]}],"categories":[{"name":"Android","slug":"Android","permalink":"https://yzs020220.github.io/categories/Android/"},{"name":"杂谈","slug":"杂谈","permalink":"https://yzs020220.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"杂","slug":"杂","permalink":"https://yzs020220.github.io/categories/%E6%9D%82/"},{"name":"Godot","slug":"Godot","permalink":"https://yzs020220.github.io/categories/Godot/"},{"name":"学","slug":"学","permalink":"https://yzs020220.github.io/categories/%E5%AD%A6/"},{"name":"Unity","slug":"Unity","permalink":"https://yzs020220.github.io/categories/Unity/"},{"name":"C#","slug":"C","permalink":"https://yzs020220.github.io/categories/C/"},{"name":"Hexo","slug":"Hexo","permalink":"https://yzs020220.github.io/categories/Hexo/"}],"tags":[{"name":"Android开发","slug":"Android开发","permalink":"https://yzs020220.github.io/tags/Android%E5%BC%80%E5%8F%91/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://yzs020220.github.io/tags/Kotlin/"},{"name":"杂谈","slug":"杂谈","permalink":"https://yzs020220.github.io/tags/%E6%9D%82%E8%B0%88/"},{"name":"杂","slug":"杂","permalink":"https://yzs020220.github.io/tags/%E6%9D%82/"},{"name":"自腾","slug":"自腾","permalink":"https://yzs020220.github.io/tags/%E8%87%AA%E8%85%BE/"},{"name":"Godot","slug":"Godot","permalink":"https://yzs020220.github.io/tags/Godot/"},{"name":"学","slug":"学","permalink":"https://yzs020220.github.io/tags/%E5%AD%A6/"},{"name":"自用","slug":"自用","permalink":"https://yzs020220.github.io/tags/%E8%87%AA%E7%94%A8/"},{"name":"C#","slug":"C","permalink":"https://yzs020220.github.io/tags/C/"},{"name":"Unity","slug":"Unity","permalink":"https://yzs020220.github.io/tags/Unity/"},{"name":"PlasticSCM","slug":"PlasticSCM","permalink":"https://yzs020220.github.io/tags/PlasticSCM/"},{"name":"Unity Shader","slug":"Unity-Shader","permalink":"https://yzs020220.github.io/tags/Unity-Shader/"},{"name":"Hexo","slug":"Hexo","permalink":"https://yzs020220.github.io/tags/Hexo/"},{"name":"Cards主题","slug":"Cards主题","permalink":"https://yzs020220.github.io/tags/Cards%E4%B8%BB%E9%A2%98/"},{"name":"volantis主题","slug":"volantis主题","permalink":"https://yzs020220.github.io/tags/volantis%E4%B8%BB%E9%A2%98/"},{"name":"Fluid主题","slug":"Fluid主题","permalink":"https://yzs020220.github.io/tags/Fluid%E4%B8%BB%E9%A2%98/"},{"name":"live2d_widget","slug":"live2d-widget","permalink":"https://yzs020220.github.io/tags/live2d-widget/"},{"name":"live2d_api","slug":"live2d-api","permalink":"https://yzs020220.github.io/tags/live2d-api/"},{"name":"NPM","slug":"NPM","permalink":"https://yzs020220.github.io/tags/NPM/"},{"name":"CDN","slug":"CDN","permalink":"https://yzs020220.github.io/tags/CDN/"},{"name":"Fluid","slug":"Fluid","permalink":"https://yzs020220.github.io/tags/Fluid/"},{"name":"音乐","slug":"音乐","permalink":"https://yzs020220.github.io/tags/%E9%9F%B3%E4%B9%90/"},{"name":"折腾","slug":"折腾","permalink":"https://yzs020220.github.io/tags/%E6%8A%98%E8%85%BE/"},{"name":"笔记","slug":"笔记","permalink":"https://yzs020220.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"图形学","slug":"图形学","permalink":"https://yzs020220.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"作业","slug":"作业","permalink":"https://yzs020220.github.io/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"学习","slug":"学习","permalink":"https://yzs020220.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]}